type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    /** The `BigInt` scalar type represents non-fractional signed whole numeric values. */
    BigInt: {
        input: any;
        output: any;
    };
    /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format. */
    DateTimeISO: {
        input: any;
        output: any;
    };
    /** GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library. */
    Decimal: {
        input: any;
        output: any;
    };
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    JSON: {
        input: any;
        output: any;
    };
};
type AccuracyRankType = {
    __typename?: 'AccuracyRankType';
    accuracyScore: Scalars['Float']['output'];
    attester: Scalars['String']['output'];
    rank?: Maybe<Scalars['Int']['output']>;
    totalForecasters: Scalars['Int']['output'];
};
type AggregateAttestation = {
    __typename?: 'AggregateAttestation';
    _avg?: Maybe<AttestationAvgAggregate>;
    _count?: Maybe<AttestationCountAggregate>;
    _max?: Maybe<AttestationMaxAggregate>;
    _min?: Maybe<AttestationMinAggregate>;
    _sum?: Maybe<AttestationSumAggregate>;
};
type AggregateCategory = {
    __typename?: 'AggregateCategory';
    _avg?: Maybe<CategoryAvgAggregate>;
    _count?: Maybe<CategoryCountAggregate>;
    _max?: Maybe<CategoryMaxAggregate>;
    _min?: Maybe<CategoryMinAggregate>;
    _sum?: Maybe<CategorySumAggregate>;
};
type AggregateCondition = {
    __typename?: 'AggregateCondition';
    _avg?: Maybe<ConditionAvgAggregate>;
    _count?: Maybe<ConditionCountAggregate>;
    _max?: Maybe<ConditionMaxAggregate>;
    _min?: Maybe<ConditionMinAggregate>;
    _sum?: Maybe<ConditionSumAggregate>;
};
type AggregateMarket = {
    __typename?: 'AggregateMarket';
    _avg?: Maybe<MarketAvgAggregate>;
    _count?: Maybe<MarketCountAggregate>;
    _max?: Maybe<MarketMaxAggregate>;
    _min?: Maybe<MarketMinAggregate>;
    _sum?: Maybe<MarketSumAggregate>;
};
type AggregateMarketGroup = {
    __typename?: 'AggregateMarketGroup';
    _avg?: Maybe<MarketGroupAvgAggregate>;
    _count?: Maybe<MarketGroupCountAggregate>;
    _max?: Maybe<MarketGroupMaxAggregate>;
    _min?: Maybe<MarketGroupMinAggregate>;
    _sum?: Maybe<MarketGroupSumAggregate>;
};
type AggregateMarketPrice = {
    __typename?: 'AggregateMarketPrice';
    _avg?: Maybe<MarketPriceAvgAggregate>;
    _count?: Maybe<MarketPriceCountAggregate>;
    _max?: Maybe<MarketPriceMaxAggregate>;
    _min?: Maybe<MarketPriceMinAggregate>;
    _sum?: Maybe<MarketPriceSumAggregate>;
};
type AggregatePosition = {
    __typename?: 'AggregatePosition';
    _avg?: Maybe<PositionAvgAggregate>;
    _count?: Maybe<PositionCountAggregate>;
    _max?: Maybe<PositionMaxAggregate>;
    _min?: Maybe<PositionMinAggregate>;
    _sum?: Maybe<PositionSumAggregate>;
};
type AggregateResource = {
    __typename?: 'AggregateResource';
    _avg?: Maybe<ResourceAvgAggregate>;
    _count?: Maybe<ResourceCountAggregate>;
    _max?: Maybe<ResourceMaxAggregate>;
    _min?: Maybe<ResourceMinAggregate>;
    _sum?: Maybe<ResourceSumAggregate>;
};
type AggregateResourcePrice = {
    __typename?: 'AggregateResourcePrice';
    _avg?: Maybe<ResourcePriceAvgAggregate>;
    _count?: Maybe<ResourcePriceCountAggregate>;
    _max?: Maybe<ResourcePriceMaxAggregate>;
    _min?: Maybe<ResourcePriceMinAggregate>;
    _sum?: Maybe<ResourcePriceSumAggregate>;
};
type AggregateTransaction = {
    __typename?: 'AggregateTransaction';
    _avg?: Maybe<TransactionAvgAggregate>;
    _count?: Maybe<TransactionCountAggregate>;
    _max?: Maybe<TransactionMaxAggregate>;
    _min?: Maybe<TransactionMinAggregate>;
    _sum?: Maybe<TransactionSumAggregate>;
};
type AggregatedProfitEntryType = {
    __typename?: 'AggregatedProfitEntryType';
    owner: Scalars['String']['output'];
    totalPnL: Scalars['Float']['output'];
};
type Attestation = {
    __typename?: 'Attestation';
    attestation_score?: Maybe<AttestationScore>;
    attester: Scalars['String']['output'];
    blockNumber: Scalars['Int']['output'];
    comment?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    data: Scalars['String']['output'];
    decodedDataJson: Scalars['String']['output'];
    id: Scalars['Int']['output'];
    marketAddress: Scalars['String']['output'];
    marketId: Scalars['String']['output'];
    prediction: Scalars['String']['output'];
    questionId: Scalars['String']['output'];
    recipient: Scalars['String']['output'];
    schemaId: Scalars['String']['output'];
    time: Scalars['Int']['output'];
    transactionHash: Scalars['String']['output'];
    uid: Scalars['String']['output'];
};
type AttestationAvgAggregate = {
    __typename?: 'AttestationAvgAggregate';
    blockNumber?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    time?: Maybe<Scalars['Float']['output']>;
};
type AttestationCountAggregate = {
    __typename?: 'AttestationCountAggregate';
    _all: Scalars['Int']['output'];
    attester: Scalars['Int']['output'];
    blockNumber: Scalars['Int']['output'];
    comment: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    data: Scalars['Int']['output'];
    decodedDataJson: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    marketAddress: Scalars['Int']['output'];
    marketId: Scalars['Int']['output'];
    prediction: Scalars['Int']['output'];
    questionId: Scalars['Int']['output'];
    recipient: Scalars['Int']['output'];
    schemaId: Scalars['Int']['output'];
    time: Scalars['Int']['output'];
    transactionHash: Scalars['Int']['output'];
    uid: Scalars['Int']['output'];
};
type AttestationGroupBy = {
    __typename?: 'AttestationGroupBy';
    _avg?: Maybe<AttestationAvgAggregate>;
    _count?: Maybe<AttestationCountAggregate>;
    _max?: Maybe<AttestationMaxAggregate>;
    _min?: Maybe<AttestationMinAggregate>;
    _sum?: Maybe<AttestationSumAggregate>;
    attester: Scalars['String']['output'];
    blockNumber: Scalars['Int']['output'];
    comment?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    data: Scalars['String']['output'];
    decodedDataJson: Scalars['String']['output'];
    id: Scalars['Int']['output'];
    marketAddress: Scalars['String']['output'];
    marketId: Scalars['String']['output'];
    prediction: Scalars['String']['output'];
    questionId: Scalars['String']['output'];
    recipient: Scalars['String']['output'];
    schemaId: Scalars['String']['output'];
    time: Scalars['Int']['output'];
    transactionHash: Scalars['String']['output'];
    uid: Scalars['String']['output'];
};
type AttestationMaxAggregate = {
    __typename?: 'AttestationMaxAggregate';
    attester?: Maybe<Scalars['String']['output']>;
    blockNumber?: Maybe<Scalars['Int']['output']>;
    comment?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    data?: Maybe<Scalars['String']['output']>;
    decodedDataJson?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketAddress?: Maybe<Scalars['String']['output']>;
    marketId?: Maybe<Scalars['String']['output']>;
    prediction?: Maybe<Scalars['String']['output']>;
    questionId?: Maybe<Scalars['String']['output']>;
    recipient?: Maybe<Scalars['String']['output']>;
    schemaId?: Maybe<Scalars['String']['output']>;
    time?: Maybe<Scalars['Int']['output']>;
    transactionHash?: Maybe<Scalars['String']['output']>;
    uid?: Maybe<Scalars['String']['output']>;
};
type AttestationMinAggregate = {
    __typename?: 'AttestationMinAggregate';
    attester?: Maybe<Scalars['String']['output']>;
    blockNumber?: Maybe<Scalars['Int']['output']>;
    comment?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    data?: Maybe<Scalars['String']['output']>;
    decodedDataJson?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketAddress?: Maybe<Scalars['String']['output']>;
    marketId?: Maybe<Scalars['String']['output']>;
    prediction?: Maybe<Scalars['String']['output']>;
    questionId?: Maybe<Scalars['String']['output']>;
    recipient?: Maybe<Scalars['String']['output']>;
    schemaId?: Maybe<Scalars['String']['output']>;
    time?: Maybe<Scalars['Int']['output']>;
    transactionHash?: Maybe<Scalars['String']['output']>;
    uid?: Maybe<Scalars['String']['output']>;
};
type AttestationScore = {
    __typename?: 'AttestationScore';
    attestation: Attestation;
    attestationId: Scalars['Int']['output'];
    attester: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    errorSquared?: Maybe<Scalars['Float']['output']>;
    id: Scalars['Int']['output'];
    madeAt: Scalars['Int']['output'];
    marketAddress: Scalars['String']['output'];
    marketId: Scalars['String']['output'];
    outcome?: Maybe<Scalars['Int']['output']>;
    probabilityD18?: Maybe<Scalars['String']['output']>;
    probabilityFloat?: Maybe<Scalars['Float']['output']>;
    questionId?: Maybe<Scalars['String']['output']>;
    scoredAt?: Maybe<Scalars['DateTimeISO']['output']>;
    used: Scalars['Boolean']['output'];
};
type AttestationSumAggregate = {
    __typename?: 'AttestationSumAggregate';
    blockNumber?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    time?: Maybe<Scalars['Int']['output']>;
};
type CandleAndTimestampType = {
    __typename?: 'CandleAndTimestampType';
    data: Array<CandleType>;
    lastUpdateTimestamp: Scalars['Int']['output'];
};
type CandleType = {
    __typename?: 'CandleType';
    close: Scalars['String']['output'];
    high: Scalars['String']['output'];
    low: Scalars['String']['output'];
    open: Scalars['String']['output'];
    timestamp: Scalars['Int']['output'];
};
type Category = {
    __typename?: 'Category';
    _count?: Maybe<CategoryCount>;
    conditions: Array<Condition>;
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    marketGroups: Array<MarketGroup>;
    name: Scalars['String']['output'];
    resources: Array<Resource>;
    slug: Scalars['String']['output'];
};
type CategoryAvgAggregate = {
    __typename?: 'CategoryAvgAggregate';
    id?: Maybe<Scalars['Float']['output']>;
};
type CategoryCount = {
    __typename?: 'CategoryCount';
    condition: Scalars['Int']['output'];
    market_group: Scalars['Int']['output'];
    resource: Scalars['Int']['output'];
};
type CategoryCountAggregate = {
    __typename?: 'CategoryCountAggregate';
    _all: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    name: Scalars['Int']['output'];
    slug: Scalars['Int']['output'];
};
type CategoryGroupBy = {
    __typename?: 'CategoryGroupBy';
    _avg?: Maybe<CategoryAvgAggregate>;
    _count?: Maybe<CategoryCountAggregate>;
    _max?: Maybe<CategoryMaxAggregate>;
    _min?: Maybe<CategoryMinAggregate>;
    _sum?: Maybe<CategorySumAggregate>;
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['String']['output'];
};
type CategoryMaxAggregate = {
    __typename?: 'CategoryMaxAggregate';
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    slug?: Maybe<Scalars['String']['output']>;
};
type CategoryMinAggregate = {
    __typename?: 'CategoryMinAggregate';
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    slug?: Maybe<Scalars['String']['output']>;
};
type CategorySumAggregate = {
    __typename?: 'CategorySumAggregate';
    id?: Maybe<Scalars['Int']['output']>;
};
type CollateralTransfer = {
    __typename?: 'CollateralTransfer';
    collateral: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    owner: Scalars['String']['output'];
    timestamp: Scalars['Int']['output'];
    transaction?: Maybe<Transaction>;
    transactionHash: Scalars['String']['output'];
};
type Condition = {
    __typename?: 'Condition';
    category?: Maybe<Category>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    claimStatement: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    description: Scalars['String']['output'];
    endTime: Scalars['Int']['output'];
    id: Scalars['String']['output'];
    public: Scalars['Boolean']['output'];
    question: Scalars['String']['output'];
    shortName?: Maybe<Scalars['String']['output']>;
    similarMarkets: Array<Scalars['String']['output']>;
};
type ConditionAvgAggregate = {
    __typename?: 'ConditionAvgAggregate';
    categoryId?: Maybe<Scalars['Float']['output']>;
    endTime?: Maybe<Scalars['Float']['output']>;
};
type ConditionCountAggregate = {
    __typename?: 'ConditionCountAggregate';
    _all: Scalars['Int']['output'];
    categoryId: Scalars['Int']['output'];
    claimStatement: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    description: Scalars['Int']['output'];
    endTime: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    public: Scalars['Int']['output'];
    question: Scalars['Int']['output'];
    shortName: Scalars['Int']['output'];
    similarMarkets: Scalars['Int']['output'];
};
type ConditionGroupBy = {
    __typename?: 'ConditionGroupBy';
    _avg?: Maybe<ConditionAvgAggregate>;
    _count?: Maybe<ConditionCountAggregate>;
    _max?: Maybe<ConditionMaxAggregate>;
    _min?: Maybe<ConditionMinAggregate>;
    _sum?: Maybe<ConditionSumAggregate>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    claimStatement: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    description: Scalars['String']['output'];
    endTime: Scalars['Int']['output'];
    id: Scalars['String']['output'];
    public: Scalars['Boolean']['output'];
    question: Scalars['String']['output'];
    shortName?: Maybe<Scalars['String']['output']>;
    similarMarkets?: Maybe<Array<Scalars['String']['output']>>;
};
type ConditionMaxAggregate = {
    __typename?: 'ConditionMaxAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    claimStatement?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    endTime?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['String']['output']>;
    public?: Maybe<Scalars['Boolean']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
};
type ConditionMinAggregate = {
    __typename?: 'ConditionMinAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    claimStatement?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    endTime?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['String']['output']>;
    public?: Maybe<Scalars['Boolean']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
};
type ConditionSumAggregate = {
    __typename?: 'ConditionSumAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    endTime?: Maybe<Scalars['Int']['output']>;
};
type ConditionSummary = {
    __typename?: 'ConditionSummary';
    endTime?: Maybe<Scalars['Int']['output']>;
    id: Scalars['String']['output'];
    question?: Maybe<Scalars['String']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
};
type Event = {
    __typename?: 'Event';
    blockNumber: Scalars['Int']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    logData: Scalars['JSON']['output'];
    logIndex: Scalars['Int']['output'];
    marketGroup?: Maybe<MarketGroup>;
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    timestamp: Scalars['BigInt']['output'];
    transaction?: Maybe<Transaction>;
    transactionHash: Scalars['String']['output'];
};
type ForecasterScoreType = {
    __typename?: 'ForecasterScoreType';
    accuracyScore: Scalars['Float']['output'];
    attester: Scalars['String']['output'];
    numScored: Scalars['Int']['output'];
    numTimeWeighted: Scalars['Int']['output'];
    sumErrorSquared: Scalars['Float']['output'];
    sumTimeWeightedError: Scalars['Float']['output'];
};
type Market = {
    __typename?: 'Market';
    _count?: Maybe<MarketCount>;
    baseAssetMaxPriceTick?: Maybe<Scalars['Int']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Int']['output']>;
    claimStatementNo?: Maybe<Scalars['String']['output']>;
    claimStatementYesOrNumeric?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    endTimestamp?: Maybe<Scalars['Int']['output']>;
    id: Scalars['Int']['output'];
    marketGroup?: Maybe<MarketGroup>;
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    marketId: Scalars['Int']['output'];
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    optionName?: Maybe<Scalars['String']['output']>;
    poolAddress?: Maybe<Scalars['String']['output']>;
    positions: Array<Position>;
    public: Scalars['Boolean']['output'];
    question?: Maybe<Scalars['String']['output']>;
    settled?: Maybe<Scalars['Boolean']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
    similarMarkets: Array<Scalars['String']['output']>;
    startTimestamp?: Maybe<Scalars['Int']['output']>;
    startingSqrtPriceX96?: Maybe<Scalars['String']['output']>;
};
type MarketAvgAggregate = {
    __typename?: 'MarketAvgAggregate';
    baseAssetMaxPriceTick?: Maybe<Scalars['Float']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Float']['output']>;
    endTimestamp?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    marketGroupId?: Maybe<Scalars['Float']['output']>;
    marketId?: Maybe<Scalars['Float']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Float']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    startTimestamp?: Maybe<Scalars['Float']['output']>;
};
type MarketCount = {
    __typename?: 'MarketCount';
    position: Scalars['Int']['output'];
};
type MarketCountAggregate = {
    __typename?: 'MarketCountAggregate';
    _all: Scalars['Int']['output'];
    baseAssetMaxPriceTick: Scalars['Int']['output'];
    baseAssetMinPriceTick: Scalars['Int']['output'];
    claimStatementNo: Scalars['Int']['output'];
    claimStatementYesOrNumeric: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    endTimestamp: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    marketGroupId: Scalars['Int']['output'];
    marketId: Scalars['Int']['output'];
    marketParamsAssertionliveness: Scalars['Int']['output'];
    marketParamsBondamount: Scalars['Int']['output'];
    marketParamsBondcurrency: Scalars['Int']['output'];
    marketParamsFeerate: Scalars['Int']['output'];
    marketParamsOptimisticoraclev3: Scalars['Int']['output'];
    marketParamsUniswappositionmanager: Scalars['Int']['output'];
    marketParamsUniswapquoter: Scalars['Int']['output'];
    marketParamsUniswapswaprouter: Scalars['Int']['output'];
    maxPriceD18: Scalars['Int']['output'];
    minPriceD18: Scalars['Int']['output'];
    optionName: Scalars['Int']['output'];
    poolAddress: Scalars['Int']['output'];
    public: Scalars['Int']['output'];
    question: Scalars['Int']['output'];
    settled: Scalars['Int']['output'];
    settlementPriceD18: Scalars['Int']['output'];
    shortName: Scalars['Int']['output'];
    similarMarkets: Scalars['Int']['output'];
    startTimestamp: Scalars['Int']['output'];
    startingSqrtPriceX96: Scalars['Int']['output'];
};
type MarketGroup = {
    __typename?: 'MarketGroup';
    _count?: Maybe<MarketGroupCount>;
    address?: Maybe<Scalars['String']['output']>;
    baseTokenName?: Maybe<Scalars['String']['output']>;
    category?: Maybe<Category>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    chainId: Scalars['Int']['output'];
    collateralAsset?: Maybe<Scalars['String']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    collateralSymbol?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    deployTimestamp?: Maybe<Scalars['Int']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Int']['output']>;
    events: Array<Event>;
    factoryAddress?: Maybe<Scalars['String']['output']>;
    id: Scalars['Int']['output'];
    initializationNonce?: Maybe<Scalars['String']['output']>;
    isBridged: Scalars['Boolean']['output'];
    isCumulative: Scalars['Boolean']['output'];
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    markets: Array<Market>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    quoteTokenName?: Maybe<Scalars['String']['output']>;
    resource?: Maybe<Resource>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    rules?: Maybe<Scalars['String']['output']>;
};
type MarketGroupAvgAggregate = {
    __typename?: 'MarketGroupAvgAggregate';
    categoryId?: Maybe<Scalars['Float']['output']>;
    chainId?: Maybe<Scalars['Float']['output']>;
    collateralDecimals?: Maybe<Scalars['Float']['output']>;
    deployTimestamp?: Maybe<Scalars['Float']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Float']['output']>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    resourceId?: Maybe<Scalars['Float']['output']>;
};
type MarketGroupBy = {
    __typename?: 'MarketGroupBy';
    _avg?: Maybe<MarketAvgAggregate>;
    _count?: Maybe<MarketCountAggregate>;
    _max?: Maybe<MarketMaxAggregate>;
    _min?: Maybe<MarketMinAggregate>;
    _sum?: Maybe<MarketSumAggregate>;
    baseAssetMaxPriceTick?: Maybe<Scalars['Int']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Int']['output']>;
    claimStatementNo?: Maybe<Scalars['String']['output']>;
    claimStatementYesOrNumeric?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    endTimestamp?: Maybe<Scalars['Int']['output']>;
    id: Scalars['Int']['output'];
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    marketId: Scalars['Int']['output'];
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    optionName?: Maybe<Scalars['String']['output']>;
    poolAddress?: Maybe<Scalars['String']['output']>;
    public: Scalars['Boolean']['output'];
    question?: Maybe<Scalars['String']['output']>;
    settled?: Maybe<Scalars['Boolean']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
    similarMarkets?: Maybe<Array<Scalars['String']['output']>>;
    startTimestamp?: Maybe<Scalars['Int']['output']>;
    startingSqrtPriceX96?: Maybe<Scalars['String']['output']>;
};
type MarketGroupCount = {
    __typename?: 'MarketGroupCount';
    event: Scalars['Int']['output'];
    market: Scalars['Int']['output'];
};
type MarketGroupCountAggregate = {
    __typename?: 'MarketGroupCountAggregate';
    _all: Scalars['Int']['output'];
    address: Scalars['Int']['output'];
    baseTokenName: Scalars['Int']['output'];
    categoryId: Scalars['Int']['output'];
    chainId: Scalars['Int']['output'];
    collateralAsset: Scalars['Int']['output'];
    collateralDecimals: Scalars['Int']['output'];
    collateralSymbol: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    deployTimestamp: Scalars['Int']['output'];
    deployTxnBlockNumber: Scalars['Int']['output'];
    factoryAddress: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    initializationNonce: Scalars['Int']['output'];
    isBridged: Scalars['Int']['output'];
    isCumulative: Scalars['Int']['output'];
    marketParamsAssertionliveness: Scalars['Int']['output'];
    marketParamsBondamount: Scalars['Int']['output'];
    marketParamsBondcurrency: Scalars['Int']['output'];
    marketParamsFeerate: Scalars['Int']['output'];
    marketParamsOptimisticoraclev3: Scalars['Int']['output'];
    marketParamsUniswappositionmanager: Scalars['Int']['output'];
    marketParamsUniswapquoter: Scalars['Int']['output'];
    marketParamsUniswapswaprouter: Scalars['Int']['output'];
    minTradeSize: Scalars['Int']['output'];
    owner: Scalars['Int']['output'];
    question: Scalars['Int']['output'];
    quoteTokenName: Scalars['Int']['output'];
    resourceId: Scalars['Int']['output'];
    rules: Scalars['Int']['output'];
};
type MarketGroupGroupBy = {
    __typename?: 'MarketGroupGroupBy';
    _avg?: Maybe<MarketGroupAvgAggregate>;
    _count?: Maybe<MarketGroupCountAggregate>;
    _max?: Maybe<MarketGroupMaxAggregate>;
    _min?: Maybe<MarketGroupMinAggregate>;
    _sum?: Maybe<MarketGroupSumAggregate>;
    address?: Maybe<Scalars['String']['output']>;
    baseTokenName?: Maybe<Scalars['String']['output']>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    chainId: Scalars['Int']['output'];
    collateralAsset?: Maybe<Scalars['String']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    collateralSymbol?: Maybe<Scalars['String']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    deployTimestamp?: Maybe<Scalars['Int']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Int']['output']>;
    factoryAddress?: Maybe<Scalars['String']['output']>;
    id: Scalars['Int']['output'];
    initializationNonce?: Maybe<Scalars['String']['output']>;
    isBridged: Scalars['Boolean']['output'];
    isCumulative: Scalars['Boolean']['output'];
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    quoteTokenName?: Maybe<Scalars['String']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    rules?: Maybe<Scalars['String']['output']>;
};
type MarketGroupMaxAggregate = {
    __typename?: 'MarketGroupMaxAggregate';
    address?: Maybe<Scalars['String']['output']>;
    baseTokenName?: Maybe<Scalars['String']['output']>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    chainId?: Maybe<Scalars['Int']['output']>;
    collateralAsset?: Maybe<Scalars['String']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    collateralSymbol?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    deployTimestamp?: Maybe<Scalars['Int']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Int']['output']>;
    factoryAddress?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    initializationNonce?: Maybe<Scalars['String']['output']>;
    isBridged?: Maybe<Scalars['Boolean']['output']>;
    isCumulative?: Maybe<Scalars['Boolean']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    quoteTokenName?: Maybe<Scalars['String']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    rules?: Maybe<Scalars['String']['output']>;
};
type MarketGroupMinAggregate = {
    __typename?: 'MarketGroupMinAggregate';
    address?: Maybe<Scalars['String']['output']>;
    baseTokenName?: Maybe<Scalars['String']['output']>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    chainId?: Maybe<Scalars['Int']['output']>;
    collateralAsset?: Maybe<Scalars['String']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    collateralSymbol?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    deployTimestamp?: Maybe<Scalars['Int']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Int']['output']>;
    factoryAddress?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    initializationNonce?: Maybe<Scalars['String']['output']>;
    isBridged?: Maybe<Scalars['Boolean']['output']>;
    isCumulative?: Maybe<Scalars['Boolean']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    quoteTokenName?: Maybe<Scalars['String']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    rules?: Maybe<Scalars['String']['output']>;
};
type MarketGroupSumAggregate = {
    __typename?: 'MarketGroupSumAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    chainId?: Maybe<Scalars['Int']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    deployTimestamp?: Maybe<Scalars['Int']['output']>;
    deployTxnBlockNumber?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    minTradeSize?: Maybe<Scalars['Decimal']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
};
type MarketMaxAggregate = {
    __typename?: 'MarketMaxAggregate';
    baseAssetMaxPriceTick?: Maybe<Scalars['Int']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Int']['output']>;
    claimStatementNo?: Maybe<Scalars['String']['output']>;
    claimStatementYesOrNumeric?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    endTimestamp?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    optionName?: Maybe<Scalars['String']['output']>;
    poolAddress?: Maybe<Scalars['String']['output']>;
    public?: Maybe<Scalars['Boolean']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    settled?: Maybe<Scalars['Boolean']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
    startTimestamp?: Maybe<Scalars['Int']['output']>;
    startingSqrtPriceX96?: Maybe<Scalars['String']['output']>;
};
type MarketMinAggregate = {
    __typename?: 'MarketMinAggregate';
    baseAssetMaxPriceTick?: Maybe<Scalars['Int']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Int']['output']>;
    claimStatementNo?: Maybe<Scalars['String']['output']>;
    claimStatementYesOrNumeric?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    endTimestamp?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondcurrency?: Maybe<Scalars['String']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    marketParamsOptimisticoraclev3?: Maybe<Scalars['String']['output']>;
    marketParamsUniswappositionmanager?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapquoter?: Maybe<Scalars['String']['output']>;
    marketParamsUniswapswaprouter?: Maybe<Scalars['String']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    optionName?: Maybe<Scalars['String']['output']>;
    poolAddress?: Maybe<Scalars['String']['output']>;
    public?: Maybe<Scalars['Boolean']['output']>;
    question?: Maybe<Scalars['String']['output']>;
    settled?: Maybe<Scalars['Boolean']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    shortName?: Maybe<Scalars['String']['output']>;
    startTimestamp?: Maybe<Scalars['Int']['output']>;
    startingSqrtPriceX96?: Maybe<Scalars['String']['output']>;
};
type MarketPrice = {
    __typename?: 'MarketPrice';
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    timestamp: Scalars['BigInt']['output'];
    transaction?: Maybe<Transaction>;
    value: Scalars['Decimal']['output'];
};
type MarketPriceAvgAggregate = {
    __typename?: 'MarketPriceAvgAggregate';
    id?: Maybe<Scalars['Float']['output']>;
    timestamp?: Maybe<Scalars['Float']['output']>;
    value?: Maybe<Scalars['Decimal']['output']>;
};
type MarketPriceCountAggregate = {
    __typename?: 'MarketPriceCountAggregate';
    _all: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    timestamp: Scalars['Int']['output'];
    value: Scalars['Int']['output'];
};
type MarketPriceGroupBy = {
    __typename?: 'MarketPriceGroupBy';
    _avg?: Maybe<MarketPriceAvgAggregate>;
    _count?: Maybe<MarketPriceCountAggregate>;
    _max?: Maybe<MarketPriceMaxAggregate>;
    _min?: Maybe<MarketPriceMinAggregate>;
    _sum?: Maybe<MarketPriceSumAggregate>;
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    timestamp: Scalars['BigInt']['output'];
    value: Scalars['Decimal']['output'];
};
type MarketPriceMaxAggregate = {
    __typename?: 'MarketPriceMaxAggregate';
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['BigInt']['output']>;
    value?: Maybe<Scalars['Decimal']['output']>;
};
type MarketPriceMinAggregate = {
    __typename?: 'MarketPriceMinAggregate';
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['BigInt']['output']>;
    value?: Maybe<Scalars['Decimal']['output']>;
};
type MarketPriceSumAggregate = {
    __typename?: 'MarketPriceSumAggregate';
    id?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['BigInt']['output']>;
    value?: Maybe<Scalars['Decimal']['output']>;
};
type MarketSumAggregate = {
    __typename?: 'MarketSumAggregate';
    baseAssetMaxPriceTick?: Maybe<Scalars['Int']['output']>;
    baseAssetMinPriceTick?: Maybe<Scalars['Int']['output']>;
    endTimestamp?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketGroupId?: Maybe<Scalars['Int']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    marketParamsAssertionliveness?: Maybe<Scalars['Decimal']['output']>;
    marketParamsBondamount?: Maybe<Scalars['Decimal']['output']>;
    marketParamsFeerate?: Maybe<Scalars['Int']['output']>;
    maxPriceD18?: Maybe<Scalars['Decimal']['output']>;
    minPriceD18?: Maybe<Scalars['Decimal']['output']>;
    settlementPriceD18?: Maybe<Scalars['Decimal']['output']>;
    startTimestamp?: Maybe<Scalars['Int']['output']>;
};
type ParlayType = {
    __typename?: 'ParlayType';
    chainId: Scalars['Int']['output'];
    endsAt?: Maybe<Scalars['Int']['output']>;
    id: Scalars['Int']['output'];
    maker: Scalars['String']['output'];
    makerCollateral?: Maybe<Scalars['String']['output']>;
    makerNftTokenId: Scalars['String']['output'];
    makerWon?: Maybe<Scalars['Boolean']['output']>;
    marketAddress: Scalars['String']['output'];
    mintedAt: Scalars['Int']['output'];
    predictedOutcomes: Array<PredictedOutcomeType>;
    refCode?: Maybe<Scalars['String']['output']>;
    settledAt?: Maybe<Scalars['Int']['output']>;
    status: Scalars['String']['output'];
    taker: Scalars['String']['output'];
    takerCollateral?: Maybe<Scalars['String']['output']>;
    takerNftTokenId: Scalars['String']['output'];
    totalCollateral: Scalars['String']['output'];
};
type PnLType = {
    __typename?: 'PnLType';
    collateralAddress?: Maybe<Scalars['String']['output']>;
    collateralDecimals?: Maybe<Scalars['Int']['output']>;
    collateralSymbol?: Maybe<Scalars['String']['output']>;
    marketId: Scalars['Int']['output'];
    openPositionsPnL: Scalars['String']['output'];
    owner: Scalars['String']['output'];
    positionCount: Scalars['Int']['output'];
    positions: Array<Scalars['Int']['output']>;
    totalDeposits: Scalars['String']['output'];
    totalPnL: Scalars['String']['output'];
    totalWithdrawals: Scalars['String']['output'];
};
type Position = {
    __typename?: 'Position';
    _count?: Maybe<PositionCount>;
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id: Scalars['Int']['output'];
    isLP: Scalars['Boolean']['output'];
    isSettled?: Maybe<Scalars['Boolean']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    lpBaseToken?: Maybe<Scalars['String']['output']>;
    lpQuoteToken?: Maybe<Scalars['String']['output']>;
    market?: Maybe<Market>;
    marketId?: Maybe<Scalars['Int']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    positionId: Scalars['Int']['output'];
    quoteToken?: Maybe<Scalars['String']['output']>;
    transactions: Array<Transaction>;
};
type PositionAvgAggregate = {
    __typename?: 'PositionAvgAggregate';
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    marketId?: Maybe<Scalars['Float']['output']>;
    positionId?: Maybe<Scalars['Float']['output']>;
};
type PositionCount = {
    __typename?: 'PositionCount';
    transaction: Scalars['Int']['output'];
};
type PositionCountAggregate = {
    __typename?: 'PositionCountAggregate';
    _all: Scalars['Int']['output'];
    baseToken: Scalars['Int']['output'];
    borrowedBaseToken: Scalars['Int']['output'];
    borrowedQuoteToken: Scalars['Int']['output'];
    collateral: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    highPriceTick: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    isLP: Scalars['Int']['output'];
    isSettled: Scalars['Int']['output'];
    lowPriceTick: Scalars['Int']['output'];
    lpBaseToken: Scalars['Int']['output'];
    lpQuoteToken: Scalars['Int']['output'];
    marketId: Scalars['Int']['output'];
    owner: Scalars['Int']['output'];
    positionId: Scalars['Int']['output'];
    quoteToken: Scalars['Int']['output'];
};
type PositionGroupBy = {
    __typename?: 'PositionGroupBy';
    _avg?: Maybe<PositionAvgAggregate>;
    _count?: Maybe<PositionCountAggregate>;
    _max?: Maybe<PositionMaxAggregate>;
    _min?: Maybe<PositionMinAggregate>;
    _sum?: Maybe<PositionSumAggregate>;
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral: Scalars['String']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id: Scalars['Int']['output'];
    isLP: Scalars['Boolean']['output'];
    isSettled?: Maybe<Scalars['Boolean']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    lpBaseToken?: Maybe<Scalars['String']['output']>;
    lpQuoteToken?: Maybe<Scalars['String']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    positionId: Scalars['Int']['output'];
    quoteToken?: Maybe<Scalars['String']['output']>;
};
type PositionMaxAggregate = {
    __typename?: 'PositionMaxAggregate';
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    isLP?: Maybe<Scalars['Boolean']['output']>;
    isSettled?: Maybe<Scalars['Boolean']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    lpBaseToken?: Maybe<Scalars['String']['output']>;
    lpQuoteToken?: Maybe<Scalars['String']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
};
type PositionMinAggregate = {
    __typename?: 'PositionMinAggregate';
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral?: Maybe<Scalars['String']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    isLP?: Maybe<Scalars['Boolean']['output']>;
    isSettled?: Maybe<Scalars['Boolean']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    lpBaseToken?: Maybe<Scalars['String']['output']>;
    lpQuoteToken?: Maybe<Scalars['String']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
};
type PositionSumAggregate = {
    __typename?: 'PositionSumAggregate';
    highPriceTick?: Maybe<Scalars['Decimal']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    lowPriceTick?: Maybe<Scalars['Decimal']['output']>;
    marketId?: Maybe<Scalars['Int']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
};
type PredictedOutcomeType = {
    __typename?: 'PredictedOutcomeType';
    condition?: Maybe<ConditionSummary>;
    conditionId: Scalars['String']['output'];
    prediction: Scalars['Boolean']['output'];
};
type ProfitRankType = {
    __typename?: 'ProfitRankType';
    owner: Scalars['String']['output'];
    rank?: Maybe<Scalars['Int']['output']>;
    totalParticipants: Scalars['Int']['output'];
    totalPnL: Scalars['Float']['output'];
};
type Query = {
    __typename?: 'Query';
    accuracyRankByAddress: AccuracyRankType;
    aggregateAttestation: AggregateAttestation;
    aggregateCategory: AggregateCategory;
    aggregateCondition: AggregateCondition;
    aggregateMarket: AggregateMarket;
    aggregateMarketGroup: AggregateMarketGroup;
    aggregateMarketPrice: AggregateMarketPrice;
    aggregatePosition: AggregatePosition;
    aggregateResource: AggregateResource;
    aggregateResourcePrice: AggregateResourcePrice;
    aggregateTransaction: AggregateTransaction;
    allTimeProfitLeaderboard: Array<AggregatedProfitEntryType>;
    attestation?: Maybe<Attestation>;
    attestations: Array<Attestation>;
    categories: Array<Category>;
    category?: Maybe<Category>;
    condition?: Maybe<Condition>;
    conditions: Array<Condition>;
    findFirstAttestation?: Maybe<Attestation>;
    findFirstAttestationOrThrow?: Maybe<Attestation>;
    findFirstCategory?: Maybe<Category>;
    findFirstCategoryOrThrow?: Maybe<Category>;
    findFirstCondition?: Maybe<Condition>;
    findFirstConditionOrThrow?: Maybe<Condition>;
    findFirstMarket?: Maybe<Market>;
    findFirstMarketGroup?: Maybe<MarketGroup>;
    findFirstMarketGroupOrThrow?: Maybe<MarketGroup>;
    findFirstMarketOrThrow?: Maybe<Market>;
    findFirstMarketPrice?: Maybe<MarketPrice>;
    findFirstMarketPriceOrThrow?: Maybe<MarketPrice>;
    findFirstPosition?: Maybe<Position>;
    findFirstPositionOrThrow?: Maybe<Position>;
    findFirstResource?: Maybe<Resource>;
    findFirstResourceOrThrow?: Maybe<Resource>;
    findFirstResourcePrice?: Maybe<ResourcePrice>;
    findFirstResourcePriceOrThrow?: Maybe<ResourcePrice>;
    findFirstTransaction?: Maybe<Transaction>;
    findFirstTransactionOrThrow?: Maybe<Transaction>;
    forecasterScore?: Maybe<ForecasterScoreType>;
    getAttestation?: Maybe<Attestation>;
    getCategory?: Maybe<Category>;
    getCondition?: Maybe<Condition>;
    getMarket?: Maybe<Market>;
    getMarketGroup?: Maybe<MarketGroup>;
    getMarketLeaderboard: Array<PnLType>;
    getMarketPrice?: Maybe<MarketPrice>;
    getParlayLeaderboard: Array<PnLType>;
    getPosition?: Maybe<Position>;
    getResource?: Maybe<Resource>;
    getResourcePrice?: Maybe<ResourcePrice>;
    getTransaction?: Maybe<Transaction>;
    groupByAttestation: Array<AttestationGroupBy>;
    groupByCategory: Array<CategoryGroupBy>;
    groupByCondition: Array<ConditionGroupBy>;
    groupByMarket: Array<MarketGroupBy>;
    groupByMarketGroup: Array<MarketGroupGroupBy>;
    groupByMarketPrice: Array<MarketPriceGroupBy>;
    groupByPosition: Array<PositionGroupBy>;
    groupByResource: Array<ResourceGroupBy>;
    groupByResourcePrice: Array<ResourcePriceGroupBy>;
    groupByTransaction: Array<TransactionGroupBy>;
    indexCandles: CandleAndTimestampType;
    indexPriceAtTime?: Maybe<CandleType>;
    legacyMarketCandles: Array<CandleType>;
    market?: Maybe<Market>;
    marketCandles: CandleAndTimestampType;
    marketGroup?: Maybe<MarketGroup>;
    marketGroups: Array<MarketGroup>;
    marketPrice?: Maybe<MarketPrice>;
    marketPrices: Array<MarketPrice>;
    markets: Array<Market>;
    position?: Maybe<Position>;
    positions: Array<Position>;
    profitRankByAddress: ProfitRankType;
    resource?: Maybe<Resource>;
    resourceCandles: CandleAndTimestampType;
    resourcePrice?: Maybe<ResourcePrice>;
    resourcePrices: Array<ResourcePrice>;
    resourceTrailingAverageCandles: CandleAndTimestampType;
    resources: Array<Resource>;
    topForecasters: Array<ForecasterScoreType>;
    totalVolumeByMarket: Scalars['Float']['output'];
    transaction?: Maybe<Transaction>;
    transactions: Array<Transaction>;
    userParlays: Array<ParlayType>;
};
type Resource = {
    __typename?: 'Resource';
    _count?: Maybe<ResourceCount>;
    category?: Maybe<Category>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    marketGroups: Array<MarketGroup>;
    name: Scalars['String']['output'];
    resourcePrices: Array<ResourcePrice>;
    slug: Scalars['String']['output'];
};
type ResourceAvgAggregate = {
    __typename?: 'ResourceAvgAggregate';
    categoryId?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
};
type ResourceCount = {
    __typename?: 'ResourceCount';
    market_group: Scalars['Int']['output'];
    resource_price: Scalars['Int']['output'];
};
type ResourceCountAggregate = {
    __typename?: 'ResourceCountAggregate';
    _all: Scalars['Int']['output'];
    categoryId: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    name: Scalars['Int']['output'];
    slug: Scalars['Int']['output'];
};
type ResourceGroupBy = {
    __typename?: 'ResourceGroupBy';
    _avg?: Maybe<ResourceAvgAggregate>;
    _count?: Maybe<ResourceCountAggregate>;
    _max?: Maybe<ResourceMaxAggregate>;
    _min?: Maybe<ResourceMinAggregate>;
    _sum?: Maybe<ResourceSumAggregate>;
    categoryId?: Maybe<Scalars['Int']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    id: Scalars['Int']['output'];
    name: Scalars['String']['output'];
    slug: Scalars['String']['output'];
};
type ResourceMaxAggregate = {
    __typename?: 'ResourceMaxAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    slug?: Maybe<Scalars['String']['output']>;
};
type ResourceMinAggregate = {
    __typename?: 'ResourceMinAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    slug?: Maybe<Scalars['String']['output']>;
};
type ResourcePrice = {
    __typename?: 'ResourcePrice';
    blockNumber: Scalars['Int']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    feePaid: Scalars['String']['output'];
    id: Scalars['Int']['output'];
    resource?: Maybe<Resource>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    timestamp: Scalars['Int']['output'];
    used: Scalars['String']['output'];
    value: Scalars['String']['output'];
};
type ResourcePriceAvgAggregate = {
    __typename?: 'ResourcePriceAvgAggregate';
    blockNumber?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    resourceId?: Maybe<Scalars['Float']['output']>;
    timestamp?: Maybe<Scalars['Float']['output']>;
};
type ResourcePriceCountAggregate = {
    __typename?: 'ResourcePriceCountAggregate';
    _all: Scalars['Int']['output'];
    blockNumber: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    feePaid: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    resourceId: Scalars['Int']['output'];
    timestamp: Scalars['Int']['output'];
    used: Scalars['Int']['output'];
    value: Scalars['Int']['output'];
};
type ResourcePriceGroupBy = {
    __typename?: 'ResourcePriceGroupBy';
    _avg?: Maybe<ResourcePriceAvgAggregate>;
    _count?: Maybe<ResourcePriceCountAggregate>;
    _max?: Maybe<ResourcePriceMaxAggregate>;
    _min?: Maybe<ResourcePriceMinAggregate>;
    _sum?: Maybe<ResourcePriceSumAggregate>;
    blockNumber: Scalars['Int']['output'];
    createdAt: Scalars['DateTimeISO']['output'];
    feePaid: Scalars['String']['output'];
    id: Scalars['Int']['output'];
    resourceId?: Maybe<Scalars['Int']['output']>;
    timestamp: Scalars['Int']['output'];
    used: Scalars['String']['output'];
    value: Scalars['String']['output'];
};
type ResourcePriceMaxAggregate = {
    __typename?: 'ResourcePriceMaxAggregate';
    blockNumber?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    feePaid?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['Int']['output']>;
    used?: Maybe<Scalars['String']['output']>;
    value?: Maybe<Scalars['String']['output']>;
};
type ResourcePriceMinAggregate = {
    __typename?: 'ResourcePriceMinAggregate';
    blockNumber?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    feePaid?: Maybe<Scalars['String']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['Int']['output']>;
    used?: Maybe<Scalars['String']['output']>;
    value?: Maybe<Scalars['String']['output']>;
};
type ResourcePriceSumAggregate = {
    __typename?: 'ResourcePriceSumAggregate';
    blockNumber?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    resourceId?: Maybe<Scalars['Int']['output']>;
    timestamp?: Maybe<Scalars['Int']['output']>;
};
type ResourceSumAggregate = {
    __typename?: 'ResourceSumAggregate';
    categoryId?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
};
type Transaction = {
    __typename?: 'Transaction';
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral: Scalars['String']['output'];
    collateralTransfer?: Maybe<CollateralTransfer>;
    collateralTransferId?: Maybe<Scalars['Int']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    event?: Maybe<Event>;
    eventId?: Maybe<Scalars['Int']['output']>;
    id: Scalars['Int']['output'];
    lpBaseDeltaToken?: Maybe<Scalars['String']['output']>;
    lpQuoteDeltaToken?: Maybe<Scalars['String']['output']>;
    marketPrice?: Maybe<MarketPrice>;
    marketPriceId?: Maybe<Scalars['Int']['output']>;
    position?: Maybe<Position>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
    tradeRatioD18?: Maybe<Scalars['String']['output']>;
    type: Transaction_Type_Enum;
};
type TransactionAvgAggregate = {
    __typename?: 'TransactionAvgAggregate';
    collateralTransferId?: Maybe<Scalars['Float']['output']>;
    eventId?: Maybe<Scalars['Float']['output']>;
    id?: Maybe<Scalars['Float']['output']>;
    marketPriceId?: Maybe<Scalars['Float']['output']>;
    positionId?: Maybe<Scalars['Float']['output']>;
};
type TransactionCountAggregate = {
    __typename?: 'TransactionCountAggregate';
    _all: Scalars['Int']['output'];
    baseToken: Scalars['Int']['output'];
    borrowedBaseToken: Scalars['Int']['output'];
    borrowedQuoteToken: Scalars['Int']['output'];
    collateral: Scalars['Int']['output'];
    collateralTransferId: Scalars['Int']['output'];
    createdAt: Scalars['Int']['output'];
    eventId: Scalars['Int']['output'];
    id: Scalars['Int']['output'];
    lpBaseDeltaToken: Scalars['Int']['output'];
    lpQuoteDeltaToken: Scalars['Int']['output'];
    marketPriceId: Scalars['Int']['output'];
    positionId: Scalars['Int']['output'];
    quoteToken: Scalars['Int']['output'];
    tradeRatioD18: Scalars['Int']['output'];
    type: Scalars['Int']['output'];
};
type TransactionGroupBy = {
    __typename?: 'TransactionGroupBy';
    _avg?: Maybe<TransactionAvgAggregate>;
    _count?: Maybe<TransactionCountAggregate>;
    _max?: Maybe<TransactionMaxAggregate>;
    _min?: Maybe<TransactionMinAggregate>;
    _sum?: Maybe<TransactionSumAggregate>;
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral: Scalars['String']['output'];
    collateralTransferId?: Maybe<Scalars['Int']['output']>;
    createdAt: Scalars['DateTimeISO']['output'];
    eventId?: Maybe<Scalars['Int']['output']>;
    id: Scalars['Int']['output'];
    lpBaseDeltaToken?: Maybe<Scalars['String']['output']>;
    lpQuoteDeltaToken?: Maybe<Scalars['String']['output']>;
    marketPriceId?: Maybe<Scalars['Int']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
    tradeRatioD18?: Maybe<Scalars['String']['output']>;
    type: Transaction_Type_Enum;
};
type TransactionMaxAggregate = {
    __typename?: 'TransactionMaxAggregate';
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral?: Maybe<Scalars['String']['output']>;
    collateralTransferId?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    eventId?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    lpBaseDeltaToken?: Maybe<Scalars['String']['output']>;
    lpQuoteDeltaToken?: Maybe<Scalars['String']['output']>;
    marketPriceId?: Maybe<Scalars['Int']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
    tradeRatioD18?: Maybe<Scalars['String']['output']>;
    type?: Maybe<Transaction_Type_Enum>;
};
type TransactionMinAggregate = {
    __typename?: 'TransactionMinAggregate';
    baseToken?: Maybe<Scalars['String']['output']>;
    borrowedBaseToken?: Maybe<Scalars['String']['output']>;
    borrowedQuoteToken?: Maybe<Scalars['String']['output']>;
    collateral?: Maybe<Scalars['String']['output']>;
    collateralTransferId?: Maybe<Scalars['Int']['output']>;
    createdAt?: Maybe<Scalars['DateTimeISO']['output']>;
    eventId?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    lpBaseDeltaToken?: Maybe<Scalars['String']['output']>;
    lpQuoteDeltaToken?: Maybe<Scalars['String']['output']>;
    marketPriceId?: Maybe<Scalars['Int']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
    quoteToken?: Maybe<Scalars['String']['output']>;
    tradeRatioD18?: Maybe<Scalars['String']['output']>;
    type?: Maybe<Transaction_Type_Enum>;
};
type TransactionSumAggregate = {
    __typename?: 'TransactionSumAggregate';
    collateralTransferId?: Maybe<Scalars['Int']['output']>;
    eventId?: Maybe<Scalars['Int']['output']>;
    id?: Maybe<Scalars['Int']['output']>;
    marketPriceId?: Maybe<Scalars['Int']['output']>;
    positionId?: Maybe<Scalars['Int']['output']>;
};
type Transaction_Type_Enum = 'addLiquidity' | 'burnParlayNFTs' | 'long' | 'mintParlayNFTs' | 'removeLiquidity' | 'settledPosition' | 'short';

export type { Category as C, Market as M, Position as P, Query as Q, Resource as R, Transaction as T, MarketGroup as a, ResourcePrice as b, CandleType as c };
