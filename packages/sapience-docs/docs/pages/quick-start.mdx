# Quick Start

This guide walks you through a tiny TypeScript bot that:

* Connects to the Sapience GraphQL API and finds the latest market.
* Uses ChatGPT to research the question and pick an answer.
* Retrieves a quote to open a $1 position with this answer.
* Opens a position in the market onchain (if an Ethereum private key is provided).

### Ideas for next steps

* Deploy it somewhere to run on a recurring basis. (Cursor agents can help you find a good hosting solution based on your needs, as well as set up instructions.)
* Have the bot share information about its research and predictions with a messaging/social media integration.
* Make the research logic, prompts, and tools more creative and sophisticated.

We recommend using [Cursor](https://www.cursor.com/) and [adding the Sapience docs](/api/mcp) for this project. You can also skip the steps below by cloning this repo in Cursor: ``

## 1. Initialize a TypeScript project

Open a terminal and initialize the project in a new folder.

```bash
mkdir sapience-bot && cd sapience-bot
pnpm init
pnpm add viem graphql-request dotenv node-fetch
pnpm add -D typescript ts-node @types/node
pnpm exec tsc --init --strict --module esnext --moduleResolution node --outDir dist
```

Update`tsconfig.json` (if necessary) so TypeScript understands ESM:

```json title="tsconfig.json"{5}
{
  "compilerOptions": {
    // ... existing options ...
    "module": "esnext",
    "target": "es2020",
    "resolveJsonModule": true,
  }
}
```

## 2. Get the latest Foil ABI

This file gives your code all the information it needs to interact with the Sapience markets onchain.

Download the artifact straight from GitHub:

```bash
curl -L https://raw.githubusercontent.com/foilxyz/foil/main/packages/protocol/deployments/Foil.json -o Foil.json
```

## 3. Configure environment variables

Create a `.env` file. **Make sure this file is in your `.gitignore` file if you use this with git or GitHub.**

This will store your private key for the Open AI API. It submits the trades onchain using the account for the Ethereum private key if provided.

```ini
OPENAI_API_KEY=xxx # Retrieve from https://platform.openai.com/api-keys
PRIVATE_KEY=0xETHEREUM_PRIVATE_KEY_HERE # OPTIONAL: For a wallet with some sUSDS and ETH on Base.
```

## 4. Write the Bot

Create an `index.ts` with the minimal logic.

```typescript title="index.ts"{5}
import 'dotenv/config'
import { createWalletClient, type Address, erc20Abi, encodeFunctionData, parseEther, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts';
import { base } from 'viem/chains';
import Foil from './Foil.json' assert { type: 'json' }
import { request, gql } from 'graphql-request'
import fetch from 'node-fetch'

const SUSDS_ADDRESS: Address = "0x5875eee11cf8398102fdad704c9e96607675467a";
const WAGER_AMOUNT = parseEther("1"); // 1 sUSDS
const PRIVATE_KEY = process.env.PRIVATE_KEY;

async function fetchNextClosingMarket(): Promise<Market> {
  const query = gql`
    query GetMarkets($collateralAsset: String!, $chainId: Int!, $currentTime: String!) {
      marketGroups(
        collateralAsset: $collateralAsset,
        chainId: $chainId
      ) {
        markets(
          filter: { 
            endTimestamp_gt: $currentTime, # Market ends in the future
          },
          orderBy: { field: "endTimestamp", direction: ASC } # Order by end time, soonest first
        ) {
          question
          marketId
          endTimestamp
        }
      }
    }
  `

  const data: JSON = await request("https://api.foil.xyz/graphql", query, {
    chainId: base.id,
    collateralAsset: SUSDS_ADDRESS,
    currentTime: Math.floor(Date.now() / 1000).toString(),
  })

  return data.markets[0]
}

// Ask ChatGPT what the answer is
async function getPrediction(question: string): Promise<bigint> {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are a helpful research assistant that answers questions. Provide your reasoning and, regardless of your confidence, reply with just "Yes", "No", or a specific number on the final line.'
        },
        {
          role: 'user',
          content: question
        }
      ],
      temperature: 0.7
    })
  });
  
  const data = await response.json();
  const answer = data.choices[0].message.content.trim().toLowerCase();

  console.log(`ChatGPT response:\n${answer}`);
  
  // If the answer is "yes", return 1e18
  if (answer.includes('yes')) {
    return parseEther("1");
  }

  // If the answer is "no", return 0
  else if (answer.includes('no')) {
    return 0n;
  }

  // Try to parse as a number
  else {
    let lastMatch: RegExpMatchArray | null = null;
    for (const match of answer.matchAll(/\d+(\.\d+)?/g)) {
      lastMatch = match;
    }

    if (lastMatch) {
      const num = parseFloat(lastMatch[0]);
      return BigInt(Math.floor(num * 10**18));
    }
    return 0n; // Default to 0 if no number found
  }
}

// Get the position size given the answer for a $1 wager
async function getQuote(marketAddress: Address, marketId: bigint, prediction: bigint) {
  const quoterUrl = `https://api.foil.xyz/quoter/${base.id}/${marketAddress}/${marketId}?collateralAvailable=${WAGER_AMOUNT}&expectedPrice=${Number(prediction)}`
  
  const response = await fetch(quoterUrl)
  const quote = await response.json()

  const requiredCollateral = BigInt(quote.collateralAvailable)

  // The API might return a different position size than expected, so we use the one from the quote
  const actualPositionSize = BigInt(quote.positionSize) 
  
  return { positionSize: actualPositionSize, requiredCollateral };
}

// Quote, approve and trade
async function trade(marketAddress: Address, marketId: bigint, positionSize: bigint) {

  const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`);

  const walletClient = createWalletClient({
    account,
    chain: base,
    transport: http(),
  });

  // Encode data for the approve call
  const approveData = encodeFunctionData({
    abi: erc20Abi,
    functionName: 'approve',
    args: [marketAddress, WAGER_AMOUNT],
  });

  // Define deadline for createTraderPosition (1 hour from now)
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 60 * 60);

  // Encode data for the createTraderPosition call
  const createPositionData = encodeFunctionData({
    abi: Foil.abi,
    functionName: 'createTraderPosition',
    args: [marketId, positionSize, WAGER_AMOUNT, deadline],
  });

  // Send transactions
  await walletClient.sendCalls({
    account: account,
    calls: [
      {
        to: SUSDS_ADDRESS,
        data: approveData,
      },
      {
        to: marketAddress,
        data: createPositionData,
      },
    ],
  });
  
  console.log(`Submitted trade onchain.`)
}

(async () => {
  const market = await fetchNextClosingMarket()

  console.log(`Found an active market for ${market.question}.`);

  console.log(`Querying ChatGPT for an answer...`);
  const prediction = await getPrediction(market.question)

  console.log('Retrieving a quote for a $1 wager...');
  const { positionSize } = await getQuote(market.marketGroup.address, market.marketId, prediction)

  if(PRIVATE_KEY){
    console.log(`Submitting trade...`);
    await trade(market.marketGroup.address,market.marketId, positionSize);
  } else {
    console.log('Add a private key to the .env file to create a position onchain.');
  }
})().catch(console.error)
```

## 5. Run it

```bash
node --loader ts-node/esm index.ts
```

From here, you can add error handling, position modification logic, liquidity provisioning strategies, and scaling of position size based on confidence.

Join the Sapience Discord server to chat with other bot builders.