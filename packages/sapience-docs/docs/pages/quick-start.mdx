# Quick Start

This guide walks you through a tiny TypeScript bot that:

* Connects to the Sapience GraphQL API and finds the latest market.
* Uses ChatGPT to research the question and pick an answer.
* Retrieves a quote to open a $1 position with this answer.
* Opens a position in the market onchain (if an Ethereum private key is provided).

### Ideas for next steps

* Deploy it somewhere to run on a recurring basis. (Cursor agents can help you find a good hosting solution based on your needs, as well as set up instructions.)
* Have the bot share information about its research and predictions with a messaging/social media integration.
* Make the research logic, prompts, and tools more creative and sophisticated.

We recommend using [Cursor](https://www.cursor.com/) and [adding the Sapience docs](/api/mcp) for this project. You can also skip the steps below by cloning this repo in Cursor: ``

## 1. Initialize a TypeScript project

Open a terminal and initialize the project in a new folder.

```bash
mkdir sapience-bot && cd sapience-bot
pnpm init
pnpm add viem graphql-request dotenv node-fetch
pnpm add -D typescript tsx @types/node
pnpm exec tsc --init --strict --module esnext --moduleResolution node --outDir dist
```

Update`tsconfig.json` (if necessary) so TypeScript understands ESM:

```json title="tsconfig.json"{5}
{
  "compilerOptions": {
    // ... existing options ...
    "target": "es2020",
    "resolveJsonModule": true,
  }
}
```

## 2. Get the latest Foil ABI

This file gives your code all the information it needs to interact with the Sapience markets onchain.

Download the file from GitHub:

```bash
curl -L https://raw.githubusercontent.com/foilxyz/foil/main/packages/protocol/deployments/Foil.json -o Foil.json
```

## 3. Get the latest GraphQL Type

This file gives your code information about the type of information you can retrieve from the [GraphQL API](/api/graphql).

Download the file from GitHub:

```bash
curl -L https://raw.githubusercontent.com/foilxyz/foil/refs/heads/main/packages/ui/types/graphql.ts -o graphql.ts
```

## 4. Configure environment variables

Create a `.env` file. **Make sure this file is in your `.gitignore` file if you use this with git or GitHub.**

This will store your private key for the Open AI API. It submits the trades onchain using the account for the Ethereum private key if provided.

```ini
OPENAI_API_KEY=xxx # Retrieve from https://platform.openai.com/api-keys
ETHEREUM_PRIVATE_KEY=0x... # OPTIONAL: For a wallet with some sUSDS and ETH on Base.
```

## 5. Write the Bot

Create an `index.ts` with the minimal logic.

```typescript title="index.ts"{5}
import 'dotenv/config'
import { createWalletClient, type Address, erc20Abi, encodeFunctionData, parseEther, http, formatUnits } from 'viem'
import { privateKeyToAccount } from 'viem/accounts';
import { base } from 'viem/chains';
import Foil from './Foil.json' assert { type: 'json' }
import { request, gql } from 'graphql-request'
import { type MarketGroupType, type MarketType, type Maybe } from './graphql'
import fetch from 'node-fetch'

const SUSDS_ADDRESS: Address = "0x5875eEE11Cf8398102FdAd704C9E96607675467a";
const WAGER_AMOUNT = parseEther("1"); // 1 sUSDS
const ETHEREUM_PRIVATE_KEY = process.env.ETHEREUM_PRIVATE_KEY;

async function fetchNextClosingMarket(): Promise<MarketType> {
  const query = gql`
    query GetNextMarkets($collateralAsset: String!, $chainId: Int!, $currentTime: String!) {
      marketGroups(
        chainId: $chainId,
        collateralAsset: $collateralAsset
      ) {
        markets(
          filter: { 
            endTimestamp_gt: $currentTime, # Market ends in the future
          },
          orderBy: { field: "endTimestamp", direction: "ASC" } # Order by end time, soonest first
        ) {
          question
          marketId
          endTimestamp
          marketGroup {
            address
          }
        }
      }
    }
  `

  const responseData = await request<{ marketGroups: Array<MarketGroupType>; }>( "https://api.foil.xyz/graphql", query, {
    chainId: base.id,
    collateralAsset: SUSDS_ADDRESS,
    currentTime: Math.floor(Date.now() / 1000).toString(),
  })

  if (responseData && responseData.marketGroups) {
    for (const group of responseData.marketGroups) {
      if (group && group.markets && group.markets.length > 0) {
        return group.markets[0];
      }
    }
  }
  throw new Error("No suitable market found in any market group or market data is incomplete.");
}

// Ask ChatGPT what the answer is
async function getPrediction(question: string): Promise<bigint> {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are a helpful research assistant that answers questions. Provide your reasoning and, regardless of your confidence, reply with just "Yes", "No", or a specific number on the final line.'
        },
        {
          role: 'user',
          content: question
        }
      ],
      temperature: 0.7
    })
  });
  
  const data = await response.json() as {
    choices: Array<{
      message: {
        content: string;
      };
    }>;
  };

  const content = data?.choices?.[0]?.message?.content;
  if (typeof content !== 'string') {
    console.error("Invalid response structure from OpenAI API:", data);
    throw new Error("Failed to get a valid response from OpenAI API.");
  }
  const answer = content.trim().toLowerCase();

  console.log(`ChatGPT response:\n${answer}`);
  
  // If the answer is "yes", return 1e18
  if (answer.includes('yes')) {
    return parseEther("1");
  }

  // If the answer is "no", return 0
  else if (answer.includes('no')) {
    return 0n;
  }

  // Try to parse as a number
  else {
    let lastMatch: RegExpMatchArray | null = null;
    for (const match of answer.matchAll(/\d+(\.\d+)?/g)) {
      lastMatch = match;
    }

    if (lastMatch) {
      const num = parseFloat(lastMatch[0]);
      return BigInt(Math.floor(num * 10**18));
    }
    return 0n; // Default to 0 if no number found
  }
}

// Get the desired position size given the answer for a $1 wager
async function getQuote(marketAddress: Address, marketId: bigint, prediction: bigint): Promise<{ positionSize: bigint }> {
  let expectedPriceDecimalString: string;
  if (prediction === 0n) {
    expectedPriceDecimalString = "0.0000009"; // API expects expectedPrice > 0. Use a very small number for "No" (e.g., similar to frontend's 0.0000009).
  } else {
    expectedPriceDecimalString = formatUnits(prediction, 18); // Convert prediction (scaled by 1e18) to a decimal string (e.g., 10n**18n -> "1.0")
  }

  const quoterUrl = `https://api.foil.xyz/quoter/${base.id}/${marketAddress}/${marketId}?collateralAvailable=${WAGER_AMOUNT.toString()}&expectedPrice=${expectedPriceDecimalString}`;
  
  const response = await fetch(quoterUrl);
  if (!response.ok) {
    const errorBody = await response.text();
    console.error(`Quoter API request failed with status ${response.status}: ${errorBody}`);
    throw new Error(`Quoter API request failed with status ${response.status}: ${errorBody}`);
  }
  
  const quote = await response.json() as { maxSize: string; };

  const positionSize = BigInt(quote.maxSize); 
  
  return { positionSize };
}

// Approve token transfer and trade
async function trade(marketAddress: Address, marketId: bigint, positionSize: bigint) {

  if (!ETHEREUM_PRIVATE_KEY) {
    throw new Error("Ethereum private key is not set in environment variables.");
  }
  const account = privateKeyToAccount(ETHEREUM_PRIVATE_KEY as `0x${string}`);

  const walletClient = createWalletClient({
    account,
    chain: base,
    transport: http(),
  });

  // Encode data for the approve call
  const approveData = encodeFunctionData({
    abi: erc20Abi,
    functionName: 'approve',
    args: [marketAddress, WAGER_AMOUNT],
  });

  // Define deadline for createTraderPosition (1 hour from now)
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 60 * 60);

  // Encode data for the createTraderPosition call
  const createPositionData = encodeFunctionData({
    abi: Foil.abi,
    functionName: 'createTraderPosition',
    args: [marketId, positionSize, WAGER_AMOUNT, deadline],
  });

  // Send transactions
  await walletClient.sendCalls({
    account: account,
    calls: [
      {
        to: SUSDS_ADDRESS,
        data: approveData,
      },
      {
        to: marketAddress,
        data: createPositionData,
      },
    ],
  });
  
  console.log(`Submitted trade onchain.`)
}

(async () => {
  const market = await fetchNextClosingMarket()

  // market.question is now guaranteed to be a string due to checks in fetchNextClosingMarket
  console.log(`Found an active market for ${market.question}.`);

  console.log(`Querying ChatGPT for an answer...`);
  const prediction = await getPrediction(market.question!) // Non-null assertion as it's checked

  console.log('Retrieving a quote for a $1 wager...');
  // market.marketGroup.address is now guaranteed by fetchNextClosingMarket
  // market.marketId is expected to be a number from GraphQL, getQuote expects bigint
  const marketIdBigInt = BigInt(market.marketId);
  const marketGroupAddress = market.marketGroup!.address! as Address; // Non-null assertions

  const { positionSize } = await getQuote(marketGroupAddress, marketIdBigInt, prediction)

  if(ETHEREUM_PRIVATE_KEY){
    console.log(`Submitting trade...`);
    await trade(marketGroupAddress, marketIdBigInt, positionSize);
  } else {
    console.log('Add a private key to the .env file to create a position onchain.');
  }
})().catch(console.error)
```

## 6. Run it

```bash
pnpm tsx index.ts
```

From here, you can add automated position settlement, better error handling, liquidity provisioning strategies, position modification logic, and scaling of position size based on confidence.

Join the Sapience Discord server to chat with other bot builders.