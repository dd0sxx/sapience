# Technical Reference

Sapience markets use the open source Foil protocol, which can run on any Ethereum (EVM) blockchain. It has no offchain dependencies outside of the settlement process, so all functions can be called by other smart contracts. You can use [Remix](https://remix.ethereum.org/) or [any other Ethereum developer tools](https://github.com/foundry-rs/foundry) to build your own smart contracts that connect to Sapience.

When users open a position as a trader or liquidity provider, they receive a transferrable NFT which represents this position. NFT IDs increment sequentially on the market group but are unique to a market.

Users deposit collateral (an ERC-20 compatible token) to "borrow" base and quote tokens to trade in a Uniswap pool. Though the mutable/write functions controlled by the Foil protocol, the view functions on a market's pool address can be useful.

Going long (which typically means "predicting yes"), involves borrowing quote tokens and trading them for base tokens. Shorting is the opposite. Providing liquidity involves borrowing some of both for the Uniswap pool and earning trading fees. These processes are all handled by functions like `createTraderPosition`.

After the end time, the market price is ignored and instead a settlement price (via UMA) is used to determine the value of the base and quote tokens when users return to redeem their collateral, after profits or losses.

The latest deployment information can be found [on Cannon](https://usecannon.com/packages/foil/latest/8453-factory). The latest smart contract ABI (needed for offchain integrations) is also available [on GitHub](https://github.com/foilxyz/foil/blob/main/packages/protocol/deployments/Foil.json).

When writing an offchain integration, you'll need an [RPC endpoint](https://chainlist.org/) (where you can read and write to the blockchain), and a private key for an Ethereum account with some gas tokens (typically ETH) and collateral you wish to have it trade.

## Use TypeScript

When building integrations using TypeScript, like prediction market trading bots, we recommend you use [viem](https://viem.sh/) and [ABITypes](https://abitype.dev/).

```typescript
import { createWalletClient, http, type Address, erc20Abi } from 'viem'
import { base } from 'viem/chains'
import { parseAbi } from 'abitype'
import FoilABI from './Foil.json'
import { privateKeyToAccount } from 'viem/accounts'

const PRIVATE_KEY = process.env.PRIVATE_KEY
const RPC_ENDPOINT = process.env.RPC_ENDPOINT

if (!PRIVATE_KEY || !RPC_ENDPOINT) {
  throw new Error('Missing required environment variables: PRIVATE_KEY and RPC_ENDPOINT')
}

const MARKET_GROUP_CHAIN_ID = "8453"
const MARKET_GROUP_ADDRESS = "0x..." as Address
const WAGER_SIZE = 1000000n

const account = privateKeyToAccount(PRIVATE_KEY as `0x${string}`)
const client = createWalletClient({
  account,
  chain: base,
  transport: http(RPC_ENDPOINT)
})

const abi = parseAbi(FoilABI)

const contractConfig = {
  chainId: MARKET_GROUP_CHAIN_ID,
  address: MARKET_GROUP_ADDRESS,
  abi
}

// Get the address of the token used as collateral
const { collateralAsset } = await client.readContract({
  ...contractConfig,
  functionName: 'getMarket',
  args: []
})

// Watch for new positions created by this address
const unwatch = client.watchContractEvent({
  ...contractConfig,
  eventName: 'TraderPositionCreated',
  args: {
    sender: account.address
  },
  onLogs: (logs) => {
    logs.forEach(log => {
      console.log(`New position created:
        Position ID: ${log.args.positionId}
        Market ID: ${log.args.epochId}
        Required Collateral: ${log.args.requiredCollateral}
        Initial Price: ${log.args.initialPrice}
        Final Price: ${log.args.finalPrice}
        Trade Ratio: ${log.args.tradeRatio}
      `)
    })
  }
})

// First approve the collateral token
const approveHash = await client.writeContract({
  address: collateralAsset as Address,
  abi: erc20Abi,
  functionName: 'approve',
  args: [contractConfig.address, WAGER_SIZE]
})

// Wait for approval to be confirmed
await client.waitForTransactionReceipt({ hash: approveHash })

// Then create the position
const positionHash = await client.writeContract({
  ...contractConfig,
  functionName: 'createTraderPosition',
  args: [
    1n, // marketId (i.e. epochId)
    WAGER_SIZE, // Size (positive for long/"yes", negative for short/"no")
    WAGER_SIZE / 100n, // 1% slippage tolerance (delta collateral limit)
    Math.floor(Date.now() / 1000) + 3600 // Order deadline (1 hour from now)
  ]
})

// Wait for position creation to be confirmed
await client.waitForTransactionReceipt({ hash: positionHash })
```

## Use Python

See [web3.py](https://github.com/ethereum/web3.py).