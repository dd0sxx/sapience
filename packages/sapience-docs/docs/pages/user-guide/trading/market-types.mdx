---
title: "Market Types"
description: "Binary, numeric, and conditional (parlay) market formats."
---

### Market Types

Sapience supports a variety of prediction market formats so traders and builders can choose the design best suited to their question:

- **Binary Markets** – The simplest format: Yes/No outcomes. Example: “Will Candidate X win the election?” A “Yes” share pays $1 if correct, $0 otherwise.
- **Numeric Markets** – Used when the outcome is a number or range, such as “What will ETH’s price be on December 31?” Traders can position across bands or continuous outcomes.
- **Conditional Markets (Parlays)** – Bundle multiple outcomes together into one position. Example: “Will Team A win and turnout exceed 60%?” All conditions must resolve correctly for payout. Parlays enable creative, higher-reward forecasts.



## Order Book Markets (CLOB-like)

- Onchain order book; effectively CLOB-like with concentrated liquidity (similar to Uniswap v3's concentrated liquidity model)
- Continuous matching; no native onchain resting limit orders
- Maker/taker model; capital efficient via price ranges
- Great for intraday trading and tight spreads
- Limit-like behavior via bot-managed quotes/cancels
- Data surfaces: on-chain events; order book snapshots (app layer); GraphQL

## Batch Auction Markets (RFQ-like)

- Batch auction / RFQ / intents-driven matching
- Quotes are explicit price-constrained intents submitted off-chain to the relayer/auction
- Discrete clearing events with netting; efficient for episodic flow
- Components: Relayer, Quoter, contracts (market group, settlement adapters), indexer
- Lifecycle: open → quote → cross → submit → settle
- Data surfaces: WebSocket topics (quotes, provisional crosses, prints); GraphQL entities
- See also: API → Batch Auction Relayer (topics, quote formats); API → Quoter (programmatic pricing/sizing); API → GraphQL (indexed data)

## Comparison

| Dimension | Order Book Markets (CLOB-like) | Batch Auction Markets (RFQ-like) |
| --- | --- | --- |
| Price representation | YES price in [0,1] | clearing/quote price per batch/intention |
| Liquidity model | maker/taker + concentrated liquidity | commit/reveal, batch clearing, or RFQ matching |
| Matching | continuous matching; limit-like via bot-enforced price discipline | discrete batch/intent settlement with explicit limit quotes |
| Capital efficiency | high via concentration | high via netting and batch clearing |
| Slippage dynamics | function of book depth | function of batch/quote quality |
| Fees/incentives | maker/taker, rebates possible | auction/relayer fees, quote incentives |
| Composability | onchain positions, tradable | intent-style settlement, programmable quotes |
| Settlement interface | Order Book settlement adapter (CLOB-like) | Auction/Intent settlement adapter |

## Why Not Conditional Tokens?

Conditional tokens are a powerful primitive, but they introduce UX and capital-efficiency constraints for our target use cases.

### Limitations
- **Liquidity fragmentation** – Splitting collateral into multiple outcome tokens spreads liquidity thin and creates friction.  
- **Complex settlement and redemption** – Users face multi-step flows (split, merge, redeem) that add UX overhead.  
- **Workflow mismatch** – Conditional tokens are less natural for intent-driven, RFQ, or batch auction designs without significant extra abstraction.  
- **Collateral inefficiency** – In a binary market, $100 collateral becomes $100 “Yes” and $100 “No” tokens. If only one side trades, half the capital sits idle. This inefficiency grows worse as the number of outcomes increases.  

## Sapience Approach

Instead of relying directly on conditional tokens, Sapience builds on more expressive and efficient market mechanisms:

- **Concentrated-Liquidity AMMs (Uniswap v3-style, orderbook-like)**  
  Virtual tokens (e.g. vGAS/vGWEI) are only tradable inside their designated pool. LPs provide capital in ranges, so liquidity is concentrated where it matters — giving an *order book feel* without requiring a full CLOB.  
- **Unified collateral pool**  
  Collateral never fragments into idle Yes/No tokens. In binary markets this yields roughly **2× higher capital efficiency** versus conditional tokens, and in multi-outcome or continuous markets the gains can be even greater.  
- **Batch Auctions for RFQ / Intents**  
  Netting orders in discrete batches allows efficient clearing and fits naturally with intent-driven workflows.  
- **Unified APIs and Pluggable Settlement Adapters**  
  Abstracting away the settlement layer allows flexible integrations (conditional tokens if desired, or alternative primitives) without fragmenting liquidity or UX.  

## Key Entities

### Market Groups (Order Book Markets)

- Definition: The onchain contract instance that anchors a set of YES/NO markets sharing the same question and parameters.
- Role: Holds market parameters, mints/burns positions, and is the contract you interact with for deploy and settle actions.
- Structure: A market group may host multiple market instances (e.g., rolling epochs) for the same question over time.
- Naming note: In smart contracts you may see groups referred to as “markets” and individual instances as “epochs”. In the app and docs we use “market group” for the contract and “market” for an individual trading instance.
- Where it shows up:
  - UI: Lists are grouped by `market group`; details pages are scoped to a group.
  - API/GraphQL: `marketGroups` queries and `market.marketGroup` relations.
  - Admin: Created via Market Group forms or imports; deployed from a factory.

### Conditions (Batch Auction Markets)

- Definition: A discrete statement to be resolved (claim + end time) that batch auctions and RFQ quotes reference. Quotes are submitted against a `conditionId`.
- Role: Binds intents, quotes, and settlement. Clearing events and prints are scoped to a condition, and oracle resolution finalizes it.
- Key fields: `claimStatement`, `endTime`, optional categorization/metadata; status progresses from open → closed → resolved.
- Composability: Conditions power single-name auctions and parlays by allowing multiple conditions to be combined.
- Where it shows up:
  - UI: Parlay mode and auction lists display public conditions.
  - API/GraphQL: `conditions` queries; quotes and prints reference `conditionId`.
  - Admin: CSV import and CRUD for creating/editing conditions.

