
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model cache_candle
 * 
 */
export type cache_candle = $Result.DefaultSelection<Prisma.$cache_candlePayload>
/**
 * Model cache_param
 * 
 */
export type cache_param = $Result.DefaultSelection<Prisma.$cache_paramPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model collateral_transfer
 * 
 */
export type collateral_transfer = $Result.DefaultSelection<Prisma.$collateral_transferPayload>
/**
 * Model crypto_prices
 * 
 */
export type crypto_prices = $Result.DefaultSelection<Prisma.$crypto_pricesPayload>
/**
 * Model event
 * 
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>
/**
 * Model market
 * 
 */
export type market = $Result.DefaultSelection<Prisma.$marketPayload>
/**
 * Model market_group
 * 
 */
export type market_group = $Result.DefaultSelection<Prisma.$market_groupPayload>
/**
 * Model market_price
 * 
 */
export type market_price = $Result.DefaultSelection<Prisma.$market_pricePayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model position
 * 
 */
export type position = $Result.DefaultSelection<Prisma.$positionPayload>
/**
 * Model render_job
 * 
 */
export type render_job = $Result.DefaultSelection<Prisma.$render_jobPayload>
/**
 * Model resource
 * 
 */
export type resource = $Result.DefaultSelection<Prisma.$resourcePayload>
/**
 * Model resource_price
 * 
 */
export type resource_price = $Result.DefaultSelection<Prisma.$resource_pricePayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const transaction_type_enum: {
  addLiquidity: 'addLiquidity',
  removeLiquidity: 'removeLiquidity',
  long: 'long',
  short: 'short',
  settledPosition: 'settledPosition'
};

export type transaction_type_enum = (typeof transaction_type_enum)[keyof typeof transaction_type_enum]

}

export type transaction_type_enum = $Enums.transaction_type_enum

export const transaction_type_enum: typeof $Enums.transaction_type_enum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cache_candles
 * const cache_candles = await prisma.cache_candle.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cache_candles
   * const cache_candles = await prisma.cache_candle.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cache_candle`: Exposes CRUD operations for the **cache_candle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cache_candles
    * const cache_candles = await prisma.cache_candle.findMany()
    * ```
    */
  get cache_candle(): Prisma.cache_candleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache_param`: Exposes CRUD operations for the **cache_param** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cache_params
    * const cache_params = await prisma.cache_param.findMany()
    * ```
    */
  get cache_param(): Prisma.cache_paramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collateral_transfer`: Exposes CRUD operations for the **collateral_transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collateral_transfers
    * const collateral_transfers = await prisma.collateral_transfer.findMany()
    * ```
    */
  get collateral_transfer(): Prisma.collateral_transferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crypto_prices`: Exposes CRUD operations for the **crypto_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crypto_prices
    * const crypto_prices = await prisma.crypto_prices.findMany()
    * ```
    */
  get crypto_prices(): Prisma.crypto_pricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.market`: Exposes CRUD operations for the **market** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Markets
    * const markets = await prisma.market.findMany()
    * ```
    */
  get market(): Prisma.marketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.market_group`: Exposes CRUD operations for the **market_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Market_groups
    * const market_groups = await prisma.market_group.findMany()
    * ```
    */
  get market_group(): Prisma.market_groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.market_price`: Exposes CRUD operations for the **market_price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Market_prices
    * const market_prices = await prisma.market_price.findMany()
    * ```
    */
  get market_price(): Prisma.market_priceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.positionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.render_job`: Exposes CRUD operations for the **render_job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Render_jobs
    * const render_jobs = await prisma.render_job.findMany()
    * ```
    */
  get render_job(): Prisma.render_jobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.resourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource_price`: Exposes CRUD operations for the **resource_price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resource_prices
    * const resource_prices = await prisma.resource_price.findMany()
    * ```
    */
  get resource_price(): Prisma.resource_priceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    cache_candle: 'cache_candle',
    cache_param: 'cache_param',
    category: 'category',
    collateral_transfer: 'collateral_transfer',
    crypto_prices: 'crypto_prices',
    event: 'event',
    market: 'market',
    market_group: 'market_group',
    market_price: 'market_price',
    migrations: 'migrations',
    position: 'position',
    render_job: 'render_job',
    resource: 'resource',
    resource_price: 'resource_price',
    transaction: 'transaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cache_candle" | "cache_param" | "category" | "collateral_transfer" | "crypto_prices" | "event" | "market" | "market_group" | "market_price" | "migrations" | "position" | "render_job" | "resource" | "resource_price" | "transaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      cache_candle: {
        payload: Prisma.$cache_candlePayload<ExtArgs>
        fields: Prisma.cache_candleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cache_candleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cache_candleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          findFirst: {
            args: Prisma.cache_candleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cache_candleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          findMany: {
            args: Prisma.cache_candleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>[]
          }
          create: {
            args: Prisma.cache_candleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          createMany: {
            args: Prisma.cache_candleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cache_candleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>[]
          }
          delete: {
            args: Prisma.cache_candleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          update: {
            args: Prisma.cache_candleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          deleteMany: {
            args: Prisma.cache_candleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cache_candleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cache_candleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>[]
          }
          upsert: {
            args: Prisma.cache_candleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_candlePayload>
          }
          aggregate: {
            args: Prisma.Cache_candleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache_candle>
          }
          groupBy: {
            args: Prisma.cache_candleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cache_candleGroupByOutputType>[]
          }
          count: {
            args: Prisma.cache_candleCountArgs<ExtArgs>
            result: $Utils.Optional<Cache_candleCountAggregateOutputType> | number
          }
        }
      }
      cache_param: {
        payload: Prisma.$cache_paramPayload<ExtArgs>
        fields: Prisma.cache_paramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cache_paramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cache_paramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          findFirst: {
            args: Prisma.cache_paramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cache_paramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          findMany: {
            args: Prisma.cache_paramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>[]
          }
          create: {
            args: Prisma.cache_paramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          createMany: {
            args: Prisma.cache_paramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cache_paramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>[]
          }
          delete: {
            args: Prisma.cache_paramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          update: {
            args: Prisma.cache_paramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          deleteMany: {
            args: Prisma.cache_paramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cache_paramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cache_paramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>[]
          }
          upsert: {
            args: Prisma.cache_paramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_paramPayload>
          }
          aggregate: {
            args: Prisma.Cache_paramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache_param>
          }
          groupBy: {
            args: Prisma.cache_paramGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cache_paramGroupByOutputType>[]
          }
          count: {
            args: Prisma.cache_paramCountArgs<ExtArgs>
            result: $Utils.Optional<Cache_paramCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      collateral_transfer: {
        payload: Prisma.$collateral_transferPayload<ExtArgs>
        fields: Prisma.collateral_transferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collateral_transferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collateral_transferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          findFirst: {
            args: Prisma.collateral_transferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collateral_transferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          findMany: {
            args: Prisma.collateral_transferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>[]
          }
          create: {
            args: Prisma.collateral_transferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          createMany: {
            args: Prisma.collateral_transferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collateral_transferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>[]
          }
          delete: {
            args: Prisma.collateral_transferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          update: {
            args: Prisma.collateral_transferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          deleteMany: {
            args: Prisma.collateral_transferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collateral_transferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collateral_transferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>[]
          }
          upsert: {
            args: Prisma.collateral_transferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_transferPayload>
          }
          aggregate: {
            args: Prisma.Collateral_transferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollateral_transfer>
          }
          groupBy: {
            args: Prisma.collateral_transferGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collateral_transferGroupByOutputType>[]
          }
          count: {
            args: Prisma.collateral_transferCountArgs<ExtArgs>
            result: $Utils.Optional<Collateral_transferCountAggregateOutputType> | number
          }
        }
      }
      crypto_prices: {
        payload: Prisma.$crypto_pricesPayload<ExtArgs>
        fields: Prisma.crypto_pricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crypto_pricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crypto_pricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          findFirst: {
            args: Prisma.crypto_pricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crypto_pricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          findMany: {
            args: Prisma.crypto_pricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>[]
          }
          create: {
            args: Prisma.crypto_pricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          createMany: {
            args: Prisma.crypto_pricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.crypto_pricesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>[]
          }
          delete: {
            args: Prisma.crypto_pricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          update: {
            args: Prisma.crypto_pricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          deleteMany: {
            args: Prisma.crypto_pricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.crypto_pricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.crypto_pricesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>[]
          }
          upsert: {
            args: Prisma.crypto_pricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crypto_pricesPayload>
          }
          aggregate: {
            args: Prisma.Crypto_pricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrypto_prices>
          }
          groupBy: {
            args: Prisma.crypto_pricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Crypto_pricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.crypto_pricesCountArgs<ExtArgs>
            result: $Utils.Optional<Crypto_pricesCountAggregateOutputType> | number
          }
        }
      }
      event: {
        payload: Prisma.$eventPayload<ExtArgs>
        fields: Prisma.eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.eventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.eventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      market: {
        payload: Prisma.$marketPayload<ExtArgs>
        fields: Prisma.marketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          findFirst: {
            args: Prisma.marketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          findMany: {
            args: Prisma.marketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>[]
          }
          create: {
            args: Prisma.marketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          createMany: {
            args: Prisma.marketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.marketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>[]
          }
          delete: {
            args: Prisma.marketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          update: {
            args: Prisma.marketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          deleteMany: {
            args: Prisma.marketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.marketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>[]
          }
          upsert: {
            args: Prisma.marketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketPayload>
          }
          aggregate: {
            args: Prisma.MarketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarket>
          }
          groupBy: {
            args: Prisma.marketGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketGroupByOutputType>[]
          }
          count: {
            args: Prisma.marketCountArgs<ExtArgs>
            result: $Utils.Optional<MarketCountAggregateOutputType> | number
          }
        }
      }
      market_group: {
        payload: Prisma.$market_groupPayload<ExtArgs>
        fields: Prisma.market_groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.market_groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.market_groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          findFirst: {
            args: Prisma.market_groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.market_groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          findMany: {
            args: Prisma.market_groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>[]
          }
          create: {
            args: Prisma.market_groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          createMany: {
            args: Prisma.market_groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.market_groupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>[]
          }
          delete: {
            args: Prisma.market_groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          update: {
            args: Prisma.market_groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          deleteMany: {
            args: Prisma.market_groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.market_groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.market_groupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>[]
          }
          upsert: {
            args: Prisma.market_groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_groupPayload>
          }
          aggregate: {
            args: Prisma.Market_groupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarket_group>
          }
          groupBy: {
            args: Prisma.market_groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Market_groupGroupByOutputType>[]
          }
          count: {
            args: Prisma.market_groupCountArgs<ExtArgs>
            result: $Utils.Optional<Market_groupCountAggregateOutputType> | number
          }
        }
      }
      market_price: {
        payload: Prisma.$market_pricePayload<ExtArgs>
        fields: Prisma.market_priceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.market_priceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.market_priceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          findFirst: {
            args: Prisma.market_priceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.market_priceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          findMany: {
            args: Prisma.market_priceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>[]
          }
          create: {
            args: Prisma.market_priceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          createMany: {
            args: Prisma.market_priceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.market_priceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>[]
          }
          delete: {
            args: Prisma.market_priceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          update: {
            args: Prisma.market_priceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          deleteMany: {
            args: Prisma.market_priceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.market_priceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.market_priceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>[]
          }
          upsert: {
            args: Prisma.market_priceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_pricePayload>
          }
          aggregate: {
            args: Prisma.Market_priceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarket_price>
          }
          groupBy: {
            args: Prisma.market_priceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Market_priceGroupByOutputType>[]
          }
          count: {
            args: Prisma.market_priceCountArgs<ExtArgs>
            result: $Utils.Optional<Market_priceCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      position: {
        payload: Prisma.$positionPayload<ExtArgs>
        fields: Prisma.positionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.positionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.positionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          findFirst: {
            args: Prisma.positionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.positionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          findMany: {
            args: Prisma.positionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>[]
          }
          create: {
            args: Prisma.positionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          createMany: {
            args: Prisma.positionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.positionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>[]
          }
          delete: {
            args: Prisma.positionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          update: {
            args: Prisma.positionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          deleteMany: {
            args: Prisma.positionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.positionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.positionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>[]
          }
          upsert: {
            args: Prisma.positionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.positionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.positionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      render_job: {
        payload: Prisma.$render_jobPayload<ExtArgs>
        fields: Prisma.render_jobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.render_jobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.render_jobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          findFirst: {
            args: Prisma.render_jobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.render_jobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          findMany: {
            args: Prisma.render_jobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>[]
          }
          create: {
            args: Prisma.render_jobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          createMany: {
            args: Prisma.render_jobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.render_jobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>[]
          }
          delete: {
            args: Prisma.render_jobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          update: {
            args: Prisma.render_jobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          deleteMany: {
            args: Prisma.render_jobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.render_jobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.render_jobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>[]
          }
          upsert: {
            args: Prisma.render_jobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$render_jobPayload>
          }
          aggregate: {
            args: Prisma.Render_jobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRender_job>
          }
          groupBy: {
            args: Prisma.render_jobGroupByArgs<ExtArgs>
            result: $Utils.Optional<Render_jobGroupByOutputType>[]
          }
          count: {
            args: Prisma.render_jobCountArgs<ExtArgs>
            result: $Utils.Optional<Render_jobCountAggregateOutputType> | number
          }
        }
      }
      resource: {
        payload: Prisma.$resourcePayload<ExtArgs>
        fields: Prisma.resourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          findFirst: {
            args: Prisma.resourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          findMany: {
            args: Prisma.resourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          create: {
            args: Prisma.resourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          createMany: {
            args: Prisma.resourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          delete: {
            args: Prisma.resourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          update: {
            args: Prisma.resourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          deleteMany: {
            args: Prisma.resourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>[]
          }
          upsert: {
            args: Prisma.resourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.resourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.resourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      resource_price: {
        payload: Prisma.$resource_pricePayload<ExtArgs>
        fields: Prisma.resource_priceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resource_priceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resource_priceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          findFirst: {
            args: Prisma.resource_priceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resource_priceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          findMany: {
            args: Prisma.resource_priceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>[]
          }
          create: {
            args: Prisma.resource_priceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          createMany: {
            args: Prisma.resource_priceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.resource_priceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>[]
          }
          delete: {
            args: Prisma.resource_priceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          update: {
            args: Prisma.resource_priceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          deleteMany: {
            args: Prisma.resource_priceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resource_priceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.resource_priceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>[]
          }
          upsert: {
            args: Prisma.resource_priceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resource_pricePayload>
          }
          aggregate: {
            args: Prisma.Resource_priceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource_price>
          }
          groupBy: {
            args: Prisma.resource_priceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Resource_priceGroupByOutputType>[]
          }
          count: {
            args: Prisma.resource_priceCountArgs<ExtArgs>
            result: $Utils.Optional<Resource_priceCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cache_candle?: cache_candleOmit
    cache_param?: cache_paramOmit
    category?: categoryOmit
    collateral_transfer?: collateral_transferOmit
    crypto_prices?: crypto_pricesOmit
    event?: eventOmit
    market?: marketOmit
    market_group?: market_groupOmit
    market_price?: market_priceOmit
    migrations?: migrationsOmit
    position?: positionOmit
    render_job?: render_jobOmit
    resource?: resourceOmit
    resource_price?: resource_priceOmit
    transaction?: transactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    market_group: number
    resource: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | CategoryCountOutputTypeCountMarket_groupArgs
    resource?: boolean | CategoryCountOutputTypeCountResourceArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountMarket_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: market_groupWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceWhereInput
  }


  /**
   * Count Type MarketCountOutputType
   */

  export type MarketCountOutputType = {
    position: number
  }

  export type MarketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    position?: boolean | MarketCountOutputTypeCountPositionArgs
  }

  // Custom InputTypes
  /**
   * MarketCountOutputType without action
   */
  export type MarketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketCountOutputType
     */
    select?: MarketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketCountOutputType without action
   */
  export type MarketCountOutputTypeCountPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: positionWhereInput
  }


  /**
   * Count Type Market_groupCountOutputType
   */

  export type Market_groupCountOutputType = {
    event: number
    market: number
  }

  export type Market_groupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | Market_groupCountOutputTypeCountEventArgs
    market?: boolean | Market_groupCountOutputTypeCountMarketArgs
  }

  // Custom InputTypes
  /**
   * Market_groupCountOutputType without action
   */
  export type Market_groupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Market_groupCountOutputType
     */
    select?: Market_groupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Market_groupCountOutputType without action
   */
  export type Market_groupCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
  }

  /**
   * Market_groupCountOutputType without action
   */
  export type Market_groupCountOutputTypeCountMarketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marketWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    transaction: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PositionCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    market_group: number
    resource_price: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | ResourceCountOutputTypeCountMarket_groupArgs
    resource_price?: boolean | ResourceCountOutputTypeCountResource_priceArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountMarket_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: market_groupWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountResource_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resource_priceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model cache_candle
   */

  export type AggregateCache_candle = {
    _count: Cache_candleCountAggregateOutputType | null
    _avg: Cache_candleAvgAggregateOutputType | null
    _sum: Cache_candleSumAggregateOutputType | null
    _min: Cache_candleMinAggregateOutputType | null
    _max: Cache_candleMaxAggregateOutputType | null
  }

  export type Cache_candleAvgAggregateOutputType = {
    id: number | null
    interval: number | null
    trailingAvgTime: number | null
    marketIdx: number | null
    timestamp: number | null
    endTimestamp: number | null
    lastUpdatedTimestamp: number | null
    sumUsed: Decimal | null
    sumFeePaid: Decimal | null
    trailingStartTimestamp: number | null
    chainId: number | null
    marketId: number | null
  }

  export type Cache_candleSumAggregateOutputType = {
    id: number | null
    interval: number | null
    trailingAvgTime: number | null
    marketIdx: number | null
    timestamp: number | null
    endTimestamp: number | null
    lastUpdatedTimestamp: number | null
    sumUsed: Decimal | null
    sumFeePaid: Decimal | null
    trailingStartTimestamp: number | null
    chainId: number | null
    marketId: number | null
  }

  export type Cache_candleMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    candleType: string | null
    interval: number | null
    trailingAvgTime: number | null
    resourceSlug: string | null
    marketIdx: number | null
    timestamp: number | null
    open: string | null
    high: string | null
    low: string | null
    close: string | null
    endTimestamp: number | null
    lastUpdatedTimestamp: number | null
    sumUsed: Decimal | null
    sumFeePaid: Decimal | null
    trailingStartTimestamp: number | null
    address: string | null
    chainId: number | null
    marketId: number | null
  }

  export type Cache_candleMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    candleType: string | null
    interval: number | null
    trailingAvgTime: number | null
    resourceSlug: string | null
    marketIdx: number | null
    timestamp: number | null
    open: string | null
    high: string | null
    low: string | null
    close: string | null
    endTimestamp: number | null
    lastUpdatedTimestamp: number | null
    sumUsed: Decimal | null
    sumFeePaid: Decimal | null
    trailingStartTimestamp: number | null
    address: string | null
    chainId: number | null
    marketId: number | null
  }

  export type Cache_candleCountAggregateOutputType = {
    id: number
    createdAt: number
    candleType: number
    interval: number
    trailingAvgTime: number
    resourceSlug: number
    marketIdx: number
    timestamp: number
    open: number
    high: number
    low: number
    close: number
    endTimestamp: number
    lastUpdatedTimestamp: number
    sumUsed: number
    sumFeePaid: number
    trailingStartTimestamp: number
    address: number
    chainId: number
    marketId: number
    _all: number
  }


  export type Cache_candleAvgAggregateInputType = {
    id?: true
    interval?: true
    trailingAvgTime?: true
    marketIdx?: true
    timestamp?: true
    endTimestamp?: true
    lastUpdatedTimestamp?: true
    sumUsed?: true
    sumFeePaid?: true
    trailingStartTimestamp?: true
    chainId?: true
    marketId?: true
  }

  export type Cache_candleSumAggregateInputType = {
    id?: true
    interval?: true
    trailingAvgTime?: true
    marketIdx?: true
    timestamp?: true
    endTimestamp?: true
    lastUpdatedTimestamp?: true
    sumUsed?: true
    sumFeePaid?: true
    trailingStartTimestamp?: true
    chainId?: true
    marketId?: true
  }

  export type Cache_candleMinAggregateInputType = {
    id?: true
    createdAt?: true
    candleType?: true
    interval?: true
    trailingAvgTime?: true
    resourceSlug?: true
    marketIdx?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    endTimestamp?: true
    lastUpdatedTimestamp?: true
    sumUsed?: true
    sumFeePaid?: true
    trailingStartTimestamp?: true
    address?: true
    chainId?: true
    marketId?: true
  }

  export type Cache_candleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    candleType?: true
    interval?: true
    trailingAvgTime?: true
    resourceSlug?: true
    marketIdx?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    endTimestamp?: true
    lastUpdatedTimestamp?: true
    sumUsed?: true
    sumFeePaid?: true
    trailingStartTimestamp?: true
    address?: true
    chainId?: true
    marketId?: true
  }

  export type Cache_candleCountAggregateInputType = {
    id?: true
    createdAt?: true
    candleType?: true
    interval?: true
    trailingAvgTime?: true
    resourceSlug?: true
    marketIdx?: true
    timestamp?: true
    open?: true
    high?: true
    low?: true
    close?: true
    endTimestamp?: true
    lastUpdatedTimestamp?: true
    sumUsed?: true
    sumFeePaid?: true
    trailingStartTimestamp?: true
    address?: true
    chainId?: true
    marketId?: true
    _all?: true
  }

  export type Cache_candleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_candle to aggregate.
     */
    where?: cache_candleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_candles to fetch.
     */
    orderBy?: cache_candleOrderByWithRelationInput | cache_candleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cache_candleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cache_candles
    **/
    _count?: true | Cache_candleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cache_candleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cache_candleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cache_candleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cache_candleMaxAggregateInputType
  }

  export type GetCache_candleAggregateType<T extends Cache_candleAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_candle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache_candle[P]>
      : GetScalarType<T[P], AggregateCache_candle[P]>
  }




  export type cache_candleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cache_candleWhereInput
    orderBy?: cache_candleOrderByWithAggregationInput | cache_candleOrderByWithAggregationInput[]
    by: Cache_candleScalarFieldEnum[] | Cache_candleScalarFieldEnum
    having?: cache_candleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cache_candleCountAggregateInputType | true
    _avg?: Cache_candleAvgAggregateInputType
    _sum?: Cache_candleSumAggregateInputType
    _min?: Cache_candleMinAggregateInputType
    _max?: Cache_candleMaxAggregateInputType
  }

  export type Cache_candleGroupByOutputType = {
    id: number
    createdAt: Date
    candleType: string
    interval: number
    trailingAvgTime: number | null
    resourceSlug: string | null
    marketIdx: number | null
    timestamp: number
    open: string
    high: string
    low: string
    close: string
    endTimestamp: number
    lastUpdatedTimestamp: number
    sumUsed: Decimal | null
    sumFeePaid: Decimal | null
    trailingStartTimestamp: number | null
    address: string | null
    chainId: number | null
    marketId: number | null
    _count: Cache_candleCountAggregateOutputType | null
    _avg: Cache_candleAvgAggregateOutputType | null
    _sum: Cache_candleSumAggregateOutputType | null
    _min: Cache_candleMinAggregateOutputType | null
    _max: Cache_candleMaxAggregateOutputType | null
  }

  type GetCache_candleGroupByPayload<T extends cache_candleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cache_candleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cache_candleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cache_candleGroupByOutputType[P]>
            : GetScalarType<T[P], Cache_candleGroupByOutputType[P]>
        }
      >
    >


  export type cache_candleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    candleType?: boolean
    interval?: boolean
    trailingAvgTime?: boolean
    resourceSlug?: boolean
    marketIdx?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    endTimestamp?: boolean
    lastUpdatedTimestamp?: boolean
    sumUsed?: boolean
    sumFeePaid?: boolean
    trailingStartTimestamp?: boolean
    address?: boolean
    chainId?: boolean
    marketId?: boolean
  }, ExtArgs["result"]["cache_candle"]>

  export type cache_candleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    candleType?: boolean
    interval?: boolean
    trailingAvgTime?: boolean
    resourceSlug?: boolean
    marketIdx?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    endTimestamp?: boolean
    lastUpdatedTimestamp?: boolean
    sumUsed?: boolean
    sumFeePaid?: boolean
    trailingStartTimestamp?: boolean
    address?: boolean
    chainId?: boolean
    marketId?: boolean
  }, ExtArgs["result"]["cache_candle"]>

  export type cache_candleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    candleType?: boolean
    interval?: boolean
    trailingAvgTime?: boolean
    resourceSlug?: boolean
    marketIdx?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    endTimestamp?: boolean
    lastUpdatedTimestamp?: boolean
    sumUsed?: boolean
    sumFeePaid?: boolean
    trailingStartTimestamp?: boolean
    address?: boolean
    chainId?: boolean
    marketId?: boolean
  }, ExtArgs["result"]["cache_candle"]>

  export type cache_candleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    candleType?: boolean
    interval?: boolean
    trailingAvgTime?: boolean
    resourceSlug?: boolean
    marketIdx?: boolean
    timestamp?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    endTimestamp?: boolean
    lastUpdatedTimestamp?: boolean
    sumUsed?: boolean
    sumFeePaid?: boolean
    trailingStartTimestamp?: boolean
    address?: boolean
    chainId?: boolean
    marketId?: boolean
  }

  export type cache_candleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "candleType" | "interval" | "trailingAvgTime" | "resourceSlug" | "marketIdx" | "timestamp" | "open" | "high" | "low" | "close" | "endTimestamp" | "lastUpdatedTimestamp" | "sumUsed" | "sumFeePaid" | "trailingStartTimestamp" | "address" | "chainId" | "marketId", ExtArgs["result"]["cache_candle"]>

  export type $cache_candlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache_candle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      candleType: string
      interval: number
      trailingAvgTime: number | null
      resourceSlug: string | null
      marketIdx: number | null
      timestamp: number
      open: string
      high: string
      low: string
      close: string
      endTimestamp: number
      lastUpdatedTimestamp: number
      sumUsed: Prisma.Decimal | null
      sumFeePaid: Prisma.Decimal | null
      trailingStartTimestamp: number | null
      address: string | null
      chainId: number | null
      marketId: number | null
    }, ExtArgs["result"]["cache_candle"]>
    composites: {}
  }

  type cache_candleGetPayload<S extends boolean | null | undefined | cache_candleDefaultArgs> = $Result.GetResult<Prisma.$cache_candlePayload, S>

  type cache_candleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cache_candleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cache_candleCountAggregateInputType | true
    }

  export interface cache_candleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache_candle'], meta: { name: 'cache_candle' } }
    /**
     * Find zero or one Cache_candle that matches the filter.
     * @param {cache_candleFindUniqueArgs} args - Arguments to find a Cache_candle
     * @example
     * // Get one Cache_candle
     * const cache_candle = await prisma.cache_candle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cache_candleFindUniqueArgs>(args: SelectSubset<T, cache_candleFindUniqueArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache_candle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cache_candleFindUniqueOrThrowArgs} args - Arguments to find a Cache_candle
     * @example
     * // Get one Cache_candle
     * const cache_candle = await prisma.cache_candle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cache_candleFindUniqueOrThrowArgs>(args: SelectSubset<T, cache_candleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_candle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleFindFirstArgs} args - Arguments to find a Cache_candle
     * @example
     * // Get one Cache_candle
     * const cache_candle = await prisma.cache_candle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cache_candleFindFirstArgs>(args?: SelectSubset<T, cache_candleFindFirstArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_candle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleFindFirstOrThrowArgs} args - Arguments to find a Cache_candle
     * @example
     * // Get one Cache_candle
     * const cache_candle = await prisma.cache_candle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cache_candleFindFirstOrThrowArgs>(args?: SelectSubset<T, cache_candleFindFirstOrThrowArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cache_candles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cache_candles
     * const cache_candles = await prisma.cache_candle.findMany()
     * 
     * // Get first 10 Cache_candles
     * const cache_candles = await prisma.cache_candle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cache_candleWithIdOnly = await prisma.cache_candle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cache_candleFindManyArgs>(args?: SelectSubset<T, cache_candleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache_candle.
     * @param {cache_candleCreateArgs} args - Arguments to create a Cache_candle.
     * @example
     * // Create one Cache_candle
     * const Cache_candle = await prisma.cache_candle.create({
     *   data: {
     *     // ... data to create a Cache_candle
     *   }
     * })
     * 
     */
    create<T extends cache_candleCreateArgs>(args: SelectSubset<T, cache_candleCreateArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cache_candles.
     * @param {cache_candleCreateManyArgs} args - Arguments to create many Cache_candles.
     * @example
     * // Create many Cache_candles
     * const cache_candle = await prisma.cache_candle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cache_candleCreateManyArgs>(args?: SelectSubset<T, cache_candleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cache_candles and returns the data saved in the database.
     * @param {cache_candleCreateManyAndReturnArgs} args - Arguments to create many Cache_candles.
     * @example
     * // Create many Cache_candles
     * const cache_candle = await prisma.cache_candle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cache_candles and only return the `id`
     * const cache_candleWithIdOnly = await prisma.cache_candle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cache_candleCreateManyAndReturnArgs>(args?: SelectSubset<T, cache_candleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache_candle.
     * @param {cache_candleDeleteArgs} args - Arguments to delete one Cache_candle.
     * @example
     * // Delete one Cache_candle
     * const Cache_candle = await prisma.cache_candle.delete({
     *   where: {
     *     // ... filter to delete one Cache_candle
     *   }
     * })
     * 
     */
    delete<T extends cache_candleDeleteArgs>(args: SelectSubset<T, cache_candleDeleteArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache_candle.
     * @param {cache_candleUpdateArgs} args - Arguments to update one Cache_candle.
     * @example
     * // Update one Cache_candle
     * const cache_candle = await prisma.cache_candle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cache_candleUpdateArgs>(args: SelectSubset<T, cache_candleUpdateArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cache_candles.
     * @param {cache_candleDeleteManyArgs} args - Arguments to filter Cache_candles to delete.
     * @example
     * // Delete a few Cache_candles
     * const { count } = await prisma.cache_candle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cache_candleDeleteManyArgs>(args?: SelectSubset<T, cache_candleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cache_candles
     * const cache_candle = await prisma.cache_candle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cache_candleUpdateManyArgs>(args: SelectSubset<T, cache_candleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_candles and returns the data updated in the database.
     * @param {cache_candleUpdateManyAndReturnArgs} args - Arguments to update many Cache_candles.
     * @example
     * // Update many Cache_candles
     * const cache_candle = await prisma.cache_candle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cache_candles and only return the `id`
     * const cache_candleWithIdOnly = await prisma.cache_candle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cache_candleUpdateManyAndReturnArgs>(args: SelectSubset<T, cache_candleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache_candle.
     * @param {cache_candleUpsertArgs} args - Arguments to update or create a Cache_candle.
     * @example
     * // Update or create a Cache_candle
     * const cache_candle = await prisma.cache_candle.upsert({
     *   create: {
     *     // ... data to create a Cache_candle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache_candle we want to update
     *   }
     * })
     */
    upsert<T extends cache_candleUpsertArgs>(args: SelectSubset<T, cache_candleUpsertArgs<ExtArgs>>): Prisma__cache_candleClient<$Result.GetResult<Prisma.$cache_candlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cache_candles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleCountArgs} args - Arguments to filter Cache_candles to count.
     * @example
     * // Count the number of Cache_candles
     * const count = await prisma.cache_candle.count({
     *   where: {
     *     // ... the filter for the Cache_candles we want to count
     *   }
     * })
    **/
    count<T extends cache_candleCountArgs>(
      args?: Subset<T, cache_candleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cache_candleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache_candle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cache_candleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cache_candleAggregateArgs>(args: Subset<T, Cache_candleAggregateArgs>): Prisma.PrismaPromise<GetCache_candleAggregateType<T>>

    /**
     * Group by Cache_candle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_candleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cache_candleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cache_candleGroupByArgs['orderBy'] }
        : { orderBy?: cache_candleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cache_candleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCache_candleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache_candle model
   */
  readonly fields: cache_candleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache_candle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cache_candleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache_candle model
   */
  interface cache_candleFieldRefs {
    readonly id: FieldRef<"cache_candle", 'Int'>
    readonly createdAt: FieldRef<"cache_candle", 'DateTime'>
    readonly candleType: FieldRef<"cache_candle", 'String'>
    readonly interval: FieldRef<"cache_candle", 'Int'>
    readonly trailingAvgTime: FieldRef<"cache_candle", 'Int'>
    readonly resourceSlug: FieldRef<"cache_candle", 'String'>
    readonly marketIdx: FieldRef<"cache_candle", 'Int'>
    readonly timestamp: FieldRef<"cache_candle", 'Int'>
    readonly open: FieldRef<"cache_candle", 'String'>
    readonly high: FieldRef<"cache_candle", 'String'>
    readonly low: FieldRef<"cache_candle", 'String'>
    readonly close: FieldRef<"cache_candle", 'String'>
    readonly endTimestamp: FieldRef<"cache_candle", 'Int'>
    readonly lastUpdatedTimestamp: FieldRef<"cache_candle", 'Int'>
    readonly sumUsed: FieldRef<"cache_candle", 'Decimal'>
    readonly sumFeePaid: FieldRef<"cache_candle", 'Decimal'>
    readonly trailingStartTimestamp: FieldRef<"cache_candle", 'Int'>
    readonly address: FieldRef<"cache_candle", 'String'>
    readonly chainId: FieldRef<"cache_candle", 'Int'>
    readonly marketId: FieldRef<"cache_candle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache_candle findUnique
   */
  export type cache_candleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter, which cache_candle to fetch.
     */
    where: cache_candleWhereUniqueInput
  }

  /**
   * cache_candle findUniqueOrThrow
   */
  export type cache_candleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter, which cache_candle to fetch.
     */
    where: cache_candleWhereUniqueInput
  }

  /**
   * cache_candle findFirst
   */
  export type cache_candleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter, which cache_candle to fetch.
     */
    where?: cache_candleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_candles to fetch.
     */
    orderBy?: cache_candleOrderByWithRelationInput | cache_candleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_candles.
     */
    cursor?: cache_candleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_candles.
     */
    distinct?: Cache_candleScalarFieldEnum | Cache_candleScalarFieldEnum[]
  }

  /**
   * cache_candle findFirstOrThrow
   */
  export type cache_candleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter, which cache_candle to fetch.
     */
    where?: cache_candleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_candles to fetch.
     */
    orderBy?: cache_candleOrderByWithRelationInput | cache_candleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_candles.
     */
    cursor?: cache_candleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_candles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_candles.
     */
    distinct?: Cache_candleScalarFieldEnum | Cache_candleScalarFieldEnum[]
  }

  /**
   * cache_candle findMany
   */
  export type cache_candleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter, which cache_candles to fetch.
     */
    where?: cache_candleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_candles to fetch.
     */
    orderBy?: cache_candleOrderByWithRelationInput | cache_candleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cache_candles.
     */
    cursor?: cache_candleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_candles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_candles.
     */
    skip?: number
    distinct?: Cache_candleScalarFieldEnum | Cache_candleScalarFieldEnum[]
  }

  /**
   * cache_candle create
   */
  export type cache_candleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * The data needed to create a cache_candle.
     */
    data: XOR<cache_candleCreateInput, cache_candleUncheckedCreateInput>
  }

  /**
   * cache_candle createMany
   */
  export type cache_candleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cache_candles.
     */
    data: cache_candleCreateManyInput | cache_candleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_candle createManyAndReturn
   */
  export type cache_candleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * The data used to create many cache_candles.
     */
    data: cache_candleCreateManyInput | cache_candleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_candle update
   */
  export type cache_candleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * The data needed to update a cache_candle.
     */
    data: XOR<cache_candleUpdateInput, cache_candleUncheckedUpdateInput>
    /**
     * Choose, which cache_candle to update.
     */
    where: cache_candleWhereUniqueInput
  }

  /**
   * cache_candle updateMany
   */
  export type cache_candleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cache_candles.
     */
    data: XOR<cache_candleUpdateManyMutationInput, cache_candleUncheckedUpdateManyInput>
    /**
     * Filter which cache_candles to update
     */
    where?: cache_candleWhereInput
    /**
     * Limit how many cache_candles to update.
     */
    limit?: number
  }

  /**
   * cache_candle updateManyAndReturn
   */
  export type cache_candleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * The data used to update cache_candles.
     */
    data: XOR<cache_candleUpdateManyMutationInput, cache_candleUncheckedUpdateManyInput>
    /**
     * Filter which cache_candles to update
     */
    where?: cache_candleWhereInput
    /**
     * Limit how many cache_candles to update.
     */
    limit?: number
  }

  /**
   * cache_candle upsert
   */
  export type cache_candleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * The filter to search for the cache_candle to update in case it exists.
     */
    where: cache_candleWhereUniqueInput
    /**
     * In case the cache_candle found by the `where` argument doesn't exist, create a new cache_candle with this data.
     */
    create: XOR<cache_candleCreateInput, cache_candleUncheckedCreateInput>
    /**
     * In case the cache_candle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cache_candleUpdateInput, cache_candleUncheckedUpdateInput>
  }

  /**
   * cache_candle delete
   */
  export type cache_candleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
    /**
     * Filter which cache_candle to delete.
     */
    where: cache_candleWhereUniqueInput
  }

  /**
   * cache_candle deleteMany
   */
  export type cache_candleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_candles to delete
     */
    where?: cache_candleWhereInput
    /**
     * Limit how many cache_candles to delete.
     */
    limit?: number
  }

  /**
   * cache_candle without action
   */
  export type cache_candleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_candle
     */
    select?: cache_candleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_candle
     */
    omit?: cache_candleOmit<ExtArgs> | null
  }


  /**
   * Model cache_param
   */

  export type AggregateCache_param = {
    _count: Cache_paramCountAggregateOutputType | null
    _avg: Cache_paramAvgAggregateOutputType | null
    _sum: Cache_paramSumAggregateOutputType | null
    _min: Cache_paramMinAggregateOutputType | null
    _max: Cache_paramMaxAggregateOutputType | null
  }

  export type Cache_paramAvgAggregateOutputType = {
    id: number | null
    paramValueNumber: Decimal | null
  }

  export type Cache_paramSumAggregateOutputType = {
    id: number | null
    paramValueNumber: Decimal | null
  }

  export type Cache_paramMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    paramName: string | null
    paramValueNumber: Decimal | null
    paramValueString: string | null
  }

  export type Cache_paramMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    paramName: string | null
    paramValueNumber: Decimal | null
    paramValueString: string | null
  }

  export type Cache_paramCountAggregateOutputType = {
    id: number
    createdAt: number
    paramName: number
    paramValueNumber: number
    paramValueString: number
    _all: number
  }


  export type Cache_paramAvgAggregateInputType = {
    id?: true
    paramValueNumber?: true
  }

  export type Cache_paramSumAggregateInputType = {
    id?: true
    paramValueNumber?: true
  }

  export type Cache_paramMinAggregateInputType = {
    id?: true
    createdAt?: true
    paramName?: true
    paramValueNumber?: true
    paramValueString?: true
  }

  export type Cache_paramMaxAggregateInputType = {
    id?: true
    createdAt?: true
    paramName?: true
    paramValueNumber?: true
    paramValueString?: true
  }

  export type Cache_paramCountAggregateInputType = {
    id?: true
    createdAt?: true
    paramName?: true
    paramValueNumber?: true
    paramValueString?: true
    _all?: true
  }

  export type Cache_paramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_param to aggregate.
     */
    where?: cache_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_params to fetch.
     */
    orderBy?: cache_paramOrderByWithRelationInput | cache_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cache_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cache_params
    **/
    _count?: true | Cache_paramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cache_paramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cache_paramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cache_paramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cache_paramMaxAggregateInputType
  }

  export type GetCache_paramAggregateType<T extends Cache_paramAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_param]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache_param[P]>
      : GetScalarType<T[P], AggregateCache_param[P]>
  }




  export type cache_paramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cache_paramWhereInput
    orderBy?: cache_paramOrderByWithAggregationInput | cache_paramOrderByWithAggregationInput[]
    by: Cache_paramScalarFieldEnum[] | Cache_paramScalarFieldEnum
    having?: cache_paramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cache_paramCountAggregateInputType | true
    _avg?: Cache_paramAvgAggregateInputType
    _sum?: Cache_paramSumAggregateInputType
    _min?: Cache_paramMinAggregateInputType
    _max?: Cache_paramMaxAggregateInputType
  }

  export type Cache_paramGroupByOutputType = {
    id: number
    createdAt: Date
    paramName: string
    paramValueNumber: Decimal
    paramValueString: string | null
    _count: Cache_paramCountAggregateOutputType | null
    _avg: Cache_paramAvgAggregateOutputType | null
    _sum: Cache_paramSumAggregateOutputType | null
    _min: Cache_paramMinAggregateOutputType | null
    _max: Cache_paramMaxAggregateOutputType | null
  }

  type GetCache_paramGroupByPayload<T extends cache_paramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cache_paramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cache_paramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cache_paramGroupByOutputType[P]>
            : GetScalarType<T[P], Cache_paramGroupByOutputType[P]>
        }
      >
    >


  export type cache_paramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    paramName?: boolean
    paramValueNumber?: boolean
    paramValueString?: boolean
  }, ExtArgs["result"]["cache_param"]>

  export type cache_paramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    paramName?: boolean
    paramValueNumber?: boolean
    paramValueString?: boolean
  }, ExtArgs["result"]["cache_param"]>

  export type cache_paramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    paramName?: boolean
    paramValueNumber?: boolean
    paramValueString?: boolean
  }, ExtArgs["result"]["cache_param"]>

  export type cache_paramSelectScalar = {
    id?: boolean
    createdAt?: boolean
    paramName?: boolean
    paramValueNumber?: boolean
    paramValueString?: boolean
  }

  export type cache_paramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "paramName" | "paramValueNumber" | "paramValueString", ExtArgs["result"]["cache_param"]>

  export type $cache_paramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache_param"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      paramName: string
      paramValueNumber: Prisma.Decimal
      paramValueString: string | null
    }, ExtArgs["result"]["cache_param"]>
    composites: {}
  }

  type cache_paramGetPayload<S extends boolean | null | undefined | cache_paramDefaultArgs> = $Result.GetResult<Prisma.$cache_paramPayload, S>

  type cache_paramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cache_paramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cache_paramCountAggregateInputType | true
    }

  export interface cache_paramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache_param'], meta: { name: 'cache_param' } }
    /**
     * Find zero or one Cache_param that matches the filter.
     * @param {cache_paramFindUniqueArgs} args - Arguments to find a Cache_param
     * @example
     * // Get one Cache_param
     * const cache_param = await prisma.cache_param.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cache_paramFindUniqueArgs>(args: SelectSubset<T, cache_paramFindUniqueArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache_param that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cache_paramFindUniqueOrThrowArgs} args - Arguments to find a Cache_param
     * @example
     * // Get one Cache_param
     * const cache_param = await prisma.cache_param.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cache_paramFindUniqueOrThrowArgs>(args: SelectSubset<T, cache_paramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_param that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramFindFirstArgs} args - Arguments to find a Cache_param
     * @example
     * // Get one Cache_param
     * const cache_param = await prisma.cache_param.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cache_paramFindFirstArgs>(args?: SelectSubset<T, cache_paramFindFirstArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_param that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramFindFirstOrThrowArgs} args - Arguments to find a Cache_param
     * @example
     * // Get one Cache_param
     * const cache_param = await prisma.cache_param.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cache_paramFindFirstOrThrowArgs>(args?: SelectSubset<T, cache_paramFindFirstOrThrowArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cache_params that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cache_params
     * const cache_params = await prisma.cache_param.findMany()
     * 
     * // Get first 10 Cache_params
     * const cache_params = await prisma.cache_param.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cache_paramWithIdOnly = await prisma.cache_param.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cache_paramFindManyArgs>(args?: SelectSubset<T, cache_paramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache_param.
     * @param {cache_paramCreateArgs} args - Arguments to create a Cache_param.
     * @example
     * // Create one Cache_param
     * const Cache_param = await prisma.cache_param.create({
     *   data: {
     *     // ... data to create a Cache_param
     *   }
     * })
     * 
     */
    create<T extends cache_paramCreateArgs>(args: SelectSubset<T, cache_paramCreateArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cache_params.
     * @param {cache_paramCreateManyArgs} args - Arguments to create many Cache_params.
     * @example
     * // Create many Cache_params
     * const cache_param = await prisma.cache_param.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cache_paramCreateManyArgs>(args?: SelectSubset<T, cache_paramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cache_params and returns the data saved in the database.
     * @param {cache_paramCreateManyAndReturnArgs} args - Arguments to create many Cache_params.
     * @example
     * // Create many Cache_params
     * const cache_param = await prisma.cache_param.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cache_params and only return the `id`
     * const cache_paramWithIdOnly = await prisma.cache_param.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cache_paramCreateManyAndReturnArgs>(args?: SelectSubset<T, cache_paramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache_param.
     * @param {cache_paramDeleteArgs} args - Arguments to delete one Cache_param.
     * @example
     * // Delete one Cache_param
     * const Cache_param = await prisma.cache_param.delete({
     *   where: {
     *     // ... filter to delete one Cache_param
     *   }
     * })
     * 
     */
    delete<T extends cache_paramDeleteArgs>(args: SelectSubset<T, cache_paramDeleteArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache_param.
     * @param {cache_paramUpdateArgs} args - Arguments to update one Cache_param.
     * @example
     * // Update one Cache_param
     * const cache_param = await prisma.cache_param.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cache_paramUpdateArgs>(args: SelectSubset<T, cache_paramUpdateArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cache_params.
     * @param {cache_paramDeleteManyArgs} args - Arguments to filter Cache_params to delete.
     * @example
     * // Delete a few Cache_params
     * const { count } = await prisma.cache_param.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cache_paramDeleteManyArgs>(args?: SelectSubset<T, cache_paramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cache_params
     * const cache_param = await prisma.cache_param.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cache_paramUpdateManyArgs>(args: SelectSubset<T, cache_paramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_params and returns the data updated in the database.
     * @param {cache_paramUpdateManyAndReturnArgs} args - Arguments to update many Cache_params.
     * @example
     * // Update many Cache_params
     * const cache_param = await prisma.cache_param.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cache_params and only return the `id`
     * const cache_paramWithIdOnly = await prisma.cache_param.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cache_paramUpdateManyAndReturnArgs>(args: SelectSubset<T, cache_paramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache_param.
     * @param {cache_paramUpsertArgs} args - Arguments to update or create a Cache_param.
     * @example
     * // Update or create a Cache_param
     * const cache_param = await prisma.cache_param.upsert({
     *   create: {
     *     // ... data to create a Cache_param
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache_param we want to update
     *   }
     * })
     */
    upsert<T extends cache_paramUpsertArgs>(args: SelectSubset<T, cache_paramUpsertArgs<ExtArgs>>): Prisma__cache_paramClient<$Result.GetResult<Prisma.$cache_paramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cache_params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramCountArgs} args - Arguments to filter Cache_params to count.
     * @example
     * // Count the number of Cache_params
     * const count = await prisma.cache_param.count({
     *   where: {
     *     // ... the filter for the Cache_params we want to count
     *   }
     * })
    **/
    count<T extends cache_paramCountArgs>(
      args?: Subset<T, cache_paramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cache_paramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache_param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cache_paramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cache_paramAggregateArgs>(args: Subset<T, Cache_paramAggregateArgs>): Prisma.PrismaPromise<GetCache_paramAggregateType<T>>

    /**
     * Group by Cache_param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_paramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cache_paramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cache_paramGroupByArgs['orderBy'] }
        : { orderBy?: cache_paramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cache_paramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCache_paramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache_param model
   */
  readonly fields: cache_paramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache_param.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cache_paramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache_param model
   */
  interface cache_paramFieldRefs {
    readonly id: FieldRef<"cache_param", 'Int'>
    readonly createdAt: FieldRef<"cache_param", 'DateTime'>
    readonly paramName: FieldRef<"cache_param", 'String'>
    readonly paramValueNumber: FieldRef<"cache_param", 'Decimal'>
    readonly paramValueString: FieldRef<"cache_param", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cache_param findUnique
   */
  export type cache_paramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter, which cache_param to fetch.
     */
    where: cache_paramWhereUniqueInput
  }

  /**
   * cache_param findUniqueOrThrow
   */
  export type cache_paramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter, which cache_param to fetch.
     */
    where: cache_paramWhereUniqueInput
  }

  /**
   * cache_param findFirst
   */
  export type cache_paramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter, which cache_param to fetch.
     */
    where?: cache_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_params to fetch.
     */
    orderBy?: cache_paramOrderByWithRelationInput | cache_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_params.
     */
    cursor?: cache_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_params.
     */
    distinct?: Cache_paramScalarFieldEnum | Cache_paramScalarFieldEnum[]
  }

  /**
   * cache_param findFirstOrThrow
   */
  export type cache_paramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter, which cache_param to fetch.
     */
    where?: cache_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_params to fetch.
     */
    orderBy?: cache_paramOrderByWithRelationInput | cache_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_params.
     */
    cursor?: cache_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_params.
     */
    distinct?: Cache_paramScalarFieldEnum | Cache_paramScalarFieldEnum[]
  }

  /**
   * cache_param findMany
   */
  export type cache_paramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter, which cache_params to fetch.
     */
    where?: cache_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_params to fetch.
     */
    orderBy?: cache_paramOrderByWithRelationInput | cache_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cache_params.
     */
    cursor?: cache_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_params.
     */
    skip?: number
    distinct?: Cache_paramScalarFieldEnum | Cache_paramScalarFieldEnum[]
  }

  /**
   * cache_param create
   */
  export type cache_paramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * The data needed to create a cache_param.
     */
    data: XOR<cache_paramCreateInput, cache_paramUncheckedCreateInput>
  }

  /**
   * cache_param createMany
   */
  export type cache_paramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cache_params.
     */
    data: cache_paramCreateManyInput | cache_paramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_param createManyAndReturn
   */
  export type cache_paramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * The data used to create many cache_params.
     */
    data: cache_paramCreateManyInput | cache_paramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_param update
   */
  export type cache_paramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * The data needed to update a cache_param.
     */
    data: XOR<cache_paramUpdateInput, cache_paramUncheckedUpdateInput>
    /**
     * Choose, which cache_param to update.
     */
    where: cache_paramWhereUniqueInput
  }

  /**
   * cache_param updateMany
   */
  export type cache_paramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cache_params.
     */
    data: XOR<cache_paramUpdateManyMutationInput, cache_paramUncheckedUpdateManyInput>
    /**
     * Filter which cache_params to update
     */
    where?: cache_paramWhereInput
    /**
     * Limit how many cache_params to update.
     */
    limit?: number
  }

  /**
   * cache_param updateManyAndReturn
   */
  export type cache_paramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * The data used to update cache_params.
     */
    data: XOR<cache_paramUpdateManyMutationInput, cache_paramUncheckedUpdateManyInput>
    /**
     * Filter which cache_params to update
     */
    where?: cache_paramWhereInput
    /**
     * Limit how many cache_params to update.
     */
    limit?: number
  }

  /**
   * cache_param upsert
   */
  export type cache_paramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * The filter to search for the cache_param to update in case it exists.
     */
    where: cache_paramWhereUniqueInput
    /**
     * In case the cache_param found by the `where` argument doesn't exist, create a new cache_param with this data.
     */
    create: XOR<cache_paramCreateInput, cache_paramUncheckedCreateInput>
    /**
     * In case the cache_param was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cache_paramUpdateInput, cache_paramUncheckedUpdateInput>
  }

  /**
   * cache_param delete
   */
  export type cache_paramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
    /**
     * Filter which cache_param to delete.
     */
    where: cache_paramWhereUniqueInput
  }

  /**
   * cache_param deleteMany
   */
  export type cache_paramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_params to delete
     */
    where?: cache_paramWhereInput
    /**
     * Limit how many cache_params to delete.
     */
    limit?: number
  }

  /**
   * cache_param without action
   */
  export type cache_paramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_param
     */
    select?: cache_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_param
     */
    omit?: cache_paramOmit<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    slug: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    slug: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    slug: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    slug: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    market_group?: boolean | category$market_groupArgs<ExtArgs>
    resource?: boolean | category$resourceArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["category"]>

  export type categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "slug", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | category$market_groupArgs<ExtArgs>
    resource?: boolean | category$resourceArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      market_group: Prisma.$market_groupPayload<ExtArgs>[]
      resource: Prisma.$resourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      slug: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market_group<T extends category$market_groupArgs<ExtArgs> = {}>(args?: Subset<T, category$market_groupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resource<T extends category$resourceArgs<ExtArgs> = {}>(args?: Subset<T, category$resourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly createdAt: FieldRef<"category", 'DateTime'>
    readonly name: FieldRef<"category", 'String'>
    readonly slug: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category createManyAndReturn
   */
  export type categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category updateManyAndReturn
   */
  export type categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.market_group
   */
  export type category$market_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    where?: market_groupWhereInput
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    cursor?: market_groupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Market_groupScalarFieldEnum | Market_groupScalarFieldEnum[]
  }

  /**
   * category.resource
   */
  export type category$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    where?: resourceWhereInput
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    cursor?: resourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model collateral_transfer
   */

  export type AggregateCollateral_transfer = {
    _count: Collateral_transferCountAggregateOutputType | null
    _avg: Collateral_transferAvgAggregateOutputType | null
    _sum: Collateral_transferSumAggregateOutputType | null
    _min: Collateral_transferMinAggregateOutputType | null
    _max: Collateral_transferMaxAggregateOutputType | null
  }

  export type Collateral_transferAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
    collateral: Decimal | null
  }

  export type Collateral_transferSumAggregateOutputType = {
    id: number | null
    timestamp: number | null
    collateral: Decimal | null
  }

  export type Collateral_transferMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    transactionHash: string | null
    timestamp: number | null
    owner: string | null
    collateral: Decimal | null
  }

  export type Collateral_transferMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    transactionHash: string | null
    timestamp: number | null
    owner: string | null
    collateral: Decimal | null
  }

  export type Collateral_transferCountAggregateOutputType = {
    id: number
    createdAt: number
    transactionHash: number
    timestamp: number
    owner: number
    collateral: number
    _all: number
  }


  export type Collateral_transferAvgAggregateInputType = {
    id?: true
    timestamp?: true
    collateral?: true
  }

  export type Collateral_transferSumAggregateInputType = {
    id?: true
    timestamp?: true
    collateral?: true
  }

  export type Collateral_transferMinAggregateInputType = {
    id?: true
    createdAt?: true
    transactionHash?: true
    timestamp?: true
    owner?: true
    collateral?: true
  }

  export type Collateral_transferMaxAggregateInputType = {
    id?: true
    createdAt?: true
    transactionHash?: true
    timestamp?: true
    owner?: true
    collateral?: true
  }

  export type Collateral_transferCountAggregateInputType = {
    id?: true
    createdAt?: true
    transactionHash?: true
    timestamp?: true
    owner?: true
    collateral?: true
    _all?: true
  }

  export type Collateral_transferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_transfer to aggregate.
     */
    where?: collateral_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_transfers to fetch.
     */
    orderBy?: collateral_transferOrderByWithRelationInput | collateral_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collateral_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collateral_transfers
    **/
    _count?: true | Collateral_transferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collateral_transferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collateral_transferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collateral_transferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collateral_transferMaxAggregateInputType
  }

  export type GetCollateral_transferAggregateType<T extends Collateral_transferAggregateArgs> = {
        [P in keyof T & keyof AggregateCollateral_transfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollateral_transfer[P]>
      : GetScalarType<T[P], AggregateCollateral_transfer[P]>
  }




  export type collateral_transferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collateral_transferWhereInput
    orderBy?: collateral_transferOrderByWithAggregationInput | collateral_transferOrderByWithAggregationInput[]
    by: Collateral_transferScalarFieldEnum[] | Collateral_transferScalarFieldEnum
    having?: collateral_transferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collateral_transferCountAggregateInputType | true
    _avg?: Collateral_transferAvgAggregateInputType
    _sum?: Collateral_transferSumAggregateInputType
    _min?: Collateral_transferMinAggregateInputType
    _max?: Collateral_transferMaxAggregateInputType
  }

  export type Collateral_transferGroupByOutputType = {
    id: number
    createdAt: Date
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal
    _count: Collateral_transferCountAggregateOutputType | null
    _avg: Collateral_transferAvgAggregateOutputType | null
    _sum: Collateral_transferSumAggregateOutputType | null
    _min: Collateral_transferMinAggregateOutputType | null
    _max: Collateral_transferMaxAggregateOutputType | null
  }

  type GetCollateral_transferGroupByPayload<T extends collateral_transferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collateral_transferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collateral_transferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collateral_transferGroupByOutputType[P]>
            : GetScalarType<T[P], Collateral_transferGroupByOutputType[P]>
        }
      >
    >


  export type collateral_transferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    owner?: boolean
    collateral?: boolean
    transaction?: boolean | collateral_transfer$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["collateral_transfer"]>

  export type collateral_transferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    owner?: boolean
    collateral?: boolean
  }, ExtArgs["result"]["collateral_transfer"]>

  export type collateral_transferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    owner?: boolean
    collateral?: boolean
  }, ExtArgs["result"]["collateral_transfer"]>

  export type collateral_transferSelectScalar = {
    id?: boolean
    createdAt?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    owner?: boolean
    collateral?: boolean
  }

  export type collateral_transferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "transactionHash" | "timestamp" | "owner" | "collateral", ExtArgs["result"]["collateral_transfer"]>
  export type collateral_transferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | collateral_transfer$transactionArgs<ExtArgs>
  }
  export type collateral_transferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type collateral_transferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $collateral_transferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collateral_transfer"
    objects: {
      transaction: Prisma.$transactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      transactionHash: string
      timestamp: number
      owner: string
      collateral: Prisma.Decimal
    }, ExtArgs["result"]["collateral_transfer"]>
    composites: {}
  }

  type collateral_transferGetPayload<S extends boolean | null | undefined | collateral_transferDefaultArgs> = $Result.GetResult<Prisma.$collateral_transferPayload, S>

  type collateral_transferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collateral_transferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Collateral_transferCountAggregateInputType | true
    }

  export interface collateral_transferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collateral_transfer'], meta: { name: 'collateral_transfer' } }
    /**
     * Find zero or one Collateral_transfer that matches the filter.
     * @param {collateral_transferFindUniqueArgs} args - Arguments to find a Collateral_transfer
     * @example
     * // Get one Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collateral_transferFindUniqueArgs>(args: SelectSubset<T, collateral_transferFindUniqueArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collateral_transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collateral_transferFindUniqueOrThrowArgs} args - Arguments to find a Collateral_transfer
     * @example
     * // Get one Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collateral_transferFindUniqueOrThrowArgs>(args: SelectSubset<T, collateral_transferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collateral_transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferFindFirstArgs} args - Arguments to find a Collateral_transfer
     * @example
     * // Get one Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collateral_transferFindFirstArgs>(args?: SelectSubset<T, collateral_transferFindFirstArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collateral_transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferFindFirstOrThrowArgs} args - Arguments to find a Collateral_transfer
     * @example
     * // Get one Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collateral_transferFindFirstOrThrowArgs>(args?: SelectSubset<T, collateral_transferFindFirstOrThrowArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collateral_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collateral_transfers
     * const collateral_transfers = await prisma.collateral_transfer.findMany()
     * 
     * // Get first 10 Collateral_transfers
     * const collateral_transfers = await prisma.collateral_transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collateral_transferWithIdOnly = await prisma.collateral_transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collateral_transferFindManyArgs>(args?: SelectSubset<T, collateral_transferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collateral_transfer.
     * @param {collateral_transferCreateArgs} args - Arguments to create a Collateral_transfer.
     * @example
     * // Create one Collateral_transfer
     * const Collateral_transfer = await prisma.collateral_transfer.create({
     *   data: {
     *     // ... data to create a Collateral_transfer
     *   }
     * })
     * 
     */
    create<T extends collateral_transferCreateArgs>(args: SelectSubset<T, collateral_transferCreateArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collateral_transfers.
     * @param {collateral_transferCreateManyArgs} args - Arguments to create many Collateral_transfers.
     * @example
     * // Create many Collateral_transfers
     * const collateral_transfer = await prisma.collateral_transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collateral_transferCreateManyArgs>(args?: SelectSubset<T, collateral_transferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collateral_transfers and returns the data saved in the database.
     * @param {collateral_transferCreateManyAndReturnArgs} args - Arguments to create many Collateral_transfers.
     * @example
     * // Create many Collateral_transfers
     * const collateral_transfer = await prisma.collateral_transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collateral_transfers and only return the `id`
     * const collateral_transferWithIdOnly = await prisma.collateral_transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collateral_transferCreateManyAndReturnArgs>(args?: SelectSubset<T, collateral_transferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collateral_transfer.
     * @param {collateral_transferDeleteArgs} args - Arguments to delete one Collateral_transfer.
     * @example
     * // Delete one Collateral_transfer
     * const Collateral_transfer = await prisma.collateral_transfer.delete({
     *   where: {
     *     // ... filter to delete one Collateral_transfer
     *   }
     * })
     * 
     */
    delete<T extends collateral_transferDeleteArgs>(args: SelectSubset<T, collateral_transferDeleteArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collateral_transfer.
     * @param {collateral_transferUpdateArgs} args - Arguments to update one Collateral_transfer.
     * @example
     * // Update one Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collateral_transferUpdateArgs>(args: SelectSubset<T, collateral_transferUpdateArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collateral_transfers.
     * @param {collateral_transferDeleteManyArgs} args - Arguments to filter Collateral_transfers to delete.
     * @example
     * // Delete a few Collateral_transfers
     * const { count } = await prisma.collateral_transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collateral_transferDeleteManyArgs>(args?: SelectSubset<T, collateral_transferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collateral_transfers
     * const collateral_transfer = await prisma.collateral_transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collateral_transferUpdateManyArgs>(args: SelectSubset<T, collateral_transferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_transfers and returns the data updated in the database.
     * @param {collateral_transferUpdateManyAndReturnArgs} args - Arguments to update many Collateral_transfers.
     * @example
     * // Update many Collateral_transfers
     * const collateral_transfer = await prisma.collateral_transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collateral_transfers and only return the `id`
     * const collateral_transferWithIdOnly = await prisma.collateral_transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collateral_transferUpdateManyAndReturnArgs>(args: SelectSubset<T, collateral_transferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collateral_transfer.
     * @param {collateral_transferUpsertArgs} args - Arguments to update or create a Collateral_transfer.
     * @example
     * // Update or create a Collateral_transfer
     * const collateral_transfer = await prisma.collateral_transfer.upsert({
     *   create: {
     *     // ... data to create a Collateral_transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collateral_transfer we want to update
     *   }
     * })
     */
    upsert<T extends collateral_transferUpsertArgs>(args: SelectSubset<T, collateral_transferUpsertArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collateral_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferCountArgs} args - Arguments to filter Collateral_transfers to count.
     * @example
     * // Count the number of Collateral_transfers
     * const count = await prisma.collateral_transfer.count({
     *   where: {
     *     // ... the filter for the Collateral_transfers we want to count
     *   }
     * })
    **/
    count<T extends collateral_transferCountArgs>(
      args?: Subset<T, collateral_transferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collateral_transferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collateral_transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collateral_transferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collateral_transferAggregateArgs>(args: Subset<T, Collateral_transferAggregateArgs>): Prisma.PrismaPromise<GetCollateral_transferAggregateType<T>>

    /**
     * Group by Collateral_transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_transferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collateral_transferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collateral_transferGroupByArgs['orderBy'] }
        : { orderBy?: collateral_transferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collateral_transferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollateral_transferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collateral_transfer model
   */
  readonly fields: collateral_transferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collateral_transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collateral_transferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends collateral_transfer$transactionArgs<ExtArgs> = {}>(args?: Subset<T, collateral_transfer$transactionArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collateral_transfer model
   */
  interface collateral_transferFieldRefs {
    readonly id: FieldRef<"collateral_transfer", 'Int'>
    readonly createdAt: FieldRef<"collateral_transfer", 'DateTime'>
    readonly transactionHash: FieldRef<"collateral_transfer", 'String'>
    readonly timestamp: FieldRef<"collateral_transfer", 'Int'>
    readonly owner: FieldRef<"collateral_transfer", 'String'>
    readonly collateral: FieldRef<"collateral_transfer", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * collateral_transfer findUnique
   */
  export type collateral_transferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter, which collateral_transfer to fetch.
     */
    where: collateral_transferWhereUniqueInput
  }

  /**
   * collateral_transfer findUniqueOrThrow
   */
  export type collateral_transferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter, which collateral_transfer to fetch.
     */
    where: collateral_transferWhereUniqueInput
  }

  /**
   * collateral_transfer findFirst
   */
  export type collateral_transferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter, which collateral_transfer to fetch.
     */
    where?: collateral_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_transfers to fetch.
     */
    orderBy?: collateral_transferOrderByWithRelationInput | collateral_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_transfers.
     */
    cursor?: collateral_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_transfers.
     */
    distinct?: Collateral_transferScalarFieldEnum | Collateral_transferScalarFieldEnum[]
  }

  /**
   * collateral_transfer findFirstOrThrow
   */
  export type collateral_transferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter, which collateral_transfer to fetch.
     */
    where?: collateral_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_transfers to fetch.
     */
    orderBy?: collateral_transferOrderByWithRelationInput | collateral_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_transfers.
     */
    cursor?: collateral_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_transfers.
     */
    distinct?: Collateral_transferScalarFieldEnum | Collateral_transferScalarFieldEnum[]
  }

  /**
   * collateral_transfer findMany
   */
  export type collateral_transferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter, which collateral_transfers to fetch.
     */
    where?: collateral_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_transfers to fetch.
     */
    orderBy?: collateral_transferOrderByWithRelationInput | collateral_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collateral_transfers.
     */
    cursor?: collateral_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_transfers.
     */
    skip?: number
    distinct?: Collateral_transferScalarFieldEnum | Collateral_transferScalarFieldEnum[]
  }

  /**
   * collateral_transfer create
   */
  export type collateral_transferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * The data needed to create a collateral_transfer.
     */
    data: XOR<collateral_transferCreateInput, collateral_transferUncheckedCreateInput>
  }

  /**
   * collateral_transfer createMany
   */
  export type collateral_transferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collateral_transfers.
     */
    data: collateral_transferCreateManyInput | collateral_transferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_transfer createManyAndReturn
   */
  export type collateral_transferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * The data used to create many collateral_transfers.
     */
    data: collateral_transferCreateManyInput | collateral_transferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_transfer update
   */
  export type collateral_transferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * The data needed to update a collateral_transfer.
     */
    data: XOR<collateral_transferUpdateInput, collateral_transferUncheckedUpdateInput>
    /**
     * Choose, which collateral_transfer to update.
     */
    where: collateral_transferWhereUniqueInput
  }

  /**
   * collateral_transfer updateMany
   */
  export type collateral_transferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collateral_transfers.
     */
    data: XOR<collateral_transferUpdateManyMutationInput, collateral_transferUncheckedUpdateManyInput>
    /**
     * Filter which collateral_transfers to update
     */
    where?: collateral_transferWhereInput
    /**
     * Limit how many collateral_transfers to update.
     */
    limit?: number
  }

  /**
   * collateral_transfer updateManyAndReturn
   */
  export type collateral_transferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * The data used to update collateral_transfers.
     */
    data: XOR<collateral_transferUpdateManyMutationInput, collateral_transferUncheckedUpdateManyInput>
    /**
     * Filter which collateral_transfers to update
     */
    where?: collateral_transferWhereInput
    /**
     * Limit how many collateral_transfers to update.
     */
    limit?: number
  }

  /**
   * collateral_transfer upsert
   */
  export type collateral_transferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * The filter to search for the collateral_transfer to update in case it exists.
     */
    where: collateral_transferWhereUniqueInput
    /**
     * In case the collateral_transfer found by the `where` argument doesn't exist, create a new collateral_transfer with this data.
     */
    create: XOR<collateral_transferCreateInput, collateral_transferUncheckedCreateInput>
    /**
     * In case the collateral_transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collateral_transferUpdateInput, collateral_transferUncheckedUpdateInput>
  }

  /**
   * collateral_transfer delete
   */
  export type collateral_transferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    /**
     * Filter which collateral_transfer to delete.
     */
    where: collateral_transferWhereUniqueInput
  }

  /**
   * collateral_transfer deleteMany
   */
  export type collateral_transferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_transfers to delete
     */
    where?: collateral_transferWhereInput
    /**
     * Limit how many collateral_transfers to delete.
     */
    limit?: number
  }

  /**
   * collateral_transfer.transaction
   */
  export type collateral_transfer$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
  }

  /**
   * collateral_transfer without action
   */
  export type collateral_transferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
  }


  /**
   * Model crypto_prices
   */

  export type AggregateCrypto_prices = {
    _count: Crypto_pricesCountAggregateOutputType | null
    _avg: Crypto_pricesAvgAggregateOutputType | null
    _sum: Crypto_pricesSumAggregateOutputType | null
    _min: Crypto_pricesMinAggregateOutputType | null
    _max: Crypto_pricesMaxAggregateOutputType | null
  }

  export type Crypto_pricesAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type Crypto_pricesSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type Crypto_pricesMinAggregateOutputType = {
    id: number | null
    ticker: string | null
    price: number | null
    timestamp: Date | null
  }

  export type Crypto_pricesMaxAggregateOutputType = {
    id: number | null
    ticker: string | null
    price: number | null
    timestamp: Date | null
  }

  export type Crypto_pricesCountAggregateOutputType = {
    id: number
    ticker: number
    price: number
    timestamp: number
    _all: number
  }


  export type Crypto_pricesAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type Crypto_pricesSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type Crypto_pricesMinAggregateInputType = {
    id?: true
    ticker?: true
    price?: true
    timestamp?: true
  }

  export type Crypto_pricesMaxAggregateInputType = {
    id?: true
    ticker?: true
    price?: true
    timestamp?: true
  }

  export type Crypto_pricesCountAggregateInputType = {
    id?: true
    ticker?: true
    price?: true
    timestamp?: true
    _all?: true
  }

  export type Crypto_pricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crypto_prices to aggregate.
     */
    where?: crypto_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_prices to fetch.
     */
    orderBy?: crypto_pricesOrderByWithRelationInput | crypto_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crypto_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crypto_prices
    **/
    _count?: true | Crypto_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Crypto_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Crypto_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Crypto_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Crypto_pricesMaxAggregateInputType
  }

  export type GetCrypto_pricesAggregateType<T extends Crypto_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateCrypto_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrypto_prices[P]>
      : GetScalarType<T[P], AggregateCrypto_prices[P]>
  }




  export type crypto_pricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crypto_pricesWhereInput
    orderBy?: crypto_pricesOrderByWithAggregationInput | crypto_pricesOrderByWithAggregationInput[]
    by: Crypto_pricesScalarFieldEnum[] | Crypto_pricesScalarFieldEnum
    having?: crypto_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Crypto_pricesCountAggregateInputType | true
    _avg?: Crypto_pricesAvgAggregateInputType
    _sum?: Crypto_pricesSumAggregateInputType
    _min?: Crypto_pricesMinAggregateInputType
    _max?: Crypto_pricesMaxAggregateInputType
  }

  export type Crypto_pricesGroupByOutputType = {
    id: number
    ticker: string | null
    price: number
    timestamp: Date
    _count: Crypto_pricesCountAggregateOutputType | null
    _avg: Crypto_pricesAvgAggregateOutputType | null
    _sum: Crypto_pricesSumAggregateOutputType | null
    _min: Crypto_pricesMinAggregateOutputType | null
    _max: Crypto_pricesMaxAggregateOutputType | null
  }

  type GetCrypto_pricesGroupByPayload<T extends crypto_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Crypto_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Crypto_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Crypto_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Crypto_pricesGroupByOutputType[P]>
        }
      >
    >


  export type crypto_pricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    price?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["crypto_prices"]>

  export type crypto_pricesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    price?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["crypto_prices"]>

  export type crypto_pricesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    price?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["crypto_prices"]>

  export type crypto_pricesSelectScalar = {
    id?: boolean
    ticker?: boolean
    price?: boolean
    timestamp?: boolean
  }

  export type crypto_pricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticker" | "price" | "timestamp", ExtArgs["result"]["crypto_prices"]>

  export type $crypto_pricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "crypto_prices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticker: string | null
      price: number
      timestamp: Date
    }, ExtArgs["result"]["crypto_prices"]>
    composites: {}
  }

  type crypto_pricesGetPayload<S extends boolean | null | undefined | crypto_pricesDefaultArgs> = $Result.GetResult<Prisma.$crypto_pricesPayload, S>

  type crypto_pricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<crypto_pricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Crypto_pricesCountAggregateInputType | true
    }

  export interface crypto_pricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crypto_prices'], meta: { name: 'crypto_prices' } }
    /**
     * Find zero or one Crypto_prices that matches the filter.
     * @param {crypto_pricesFindUniqueArgs} args - Arguments to find a Crypto_prices
     * @example
     * // Get one Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends crypto_pricesFindUniqueArgs>(args: SelectSubset<T, crypto_pricesFindUniqueArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crypto_prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {crypto_pricesFindUniqueOrThrowArgs} args - Arguments to find a Crypto_prices
     * @example
     * // Get one Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends crypto_pricesFindUniqueOrThrowArgs>(args: SelectSubset<T, crypto_pricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crypto_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesFindFirstArgs} args - Arguments to find a Crypto_prices
     * @example
     * // Get one Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends crypto_pricesFindFirstArgs>(args?: SelectSubset<T, crypto_pricesFindFirstArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crypto_prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesFindFirstOrThrowArgs} args - Arguments to find a Crypto_prices
     * @example
     * // Get one Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends crypto_pricesFindFirstOrThrowArgs>(args?: SelectSubset<T, crypto_pricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crypto_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findMany()
     * 
     * // Get first 10 Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crypto_pricesWithIdOnly = await prisma.crypto_prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends crypto_pricesFindManyArgs>(args?: SelectSubset<T, crypto_pricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crypto_prices.
     * @param {crypto_pricesCreateArgs} args - Arguments to create a Crypto_prices.
     * @example
     * // Create one Crypto_prices
     * const Crypto_prices = await prisma.crypto_prices.create({
     *   data: {
     *     // ... data to create a Crypto_prices
     *   }
     * })
     * 
     */
    create<T extends crypto_pricesCreateArgs>(args: SelectSubset<T, crypto_pricesCreateArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crypto_prices.
     * @param {crypto_pricesCreateManyArgs} args - Arguments to create many Crypto_prices.
     * @example
     * // Create many Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends crypto_pricesCreateManyArgs>(args?: SelectSubset<T, crypto_pricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crypto_prices and returns the data saved in the database.
     * @param {crypto_pricesCreateManyAndReturnArgs} args - Arguments to create many Crypto_prices.
     * @example
     * // Create many Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crypto_prices and only return the `id`
     * const crypto_pricesWithIdOnly = await prisma.crypto_prices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends crypto_pricesCreateManyAndReturnArgs>(args?: SelectSubset<T, crypto_pricesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crypto_prices.
     * @param {crypto_pricesDeleteArgs} args - Arguments to delete one Crypto_prices.
     * @example
     * // Delete one Crypto_prices
     * const Crypto_prices = await prisma.crypto_prices.delete({
     *   where: {
     *     // ... filter to delete one Crypto_prices
     *   }
     * })
     * 
     */
    delete<T extends crypto_pricesDeleteArgs>(args: SelectSubset<T, crypto_pricesDeleteArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crypto_prices.
     * @param {crypto_pricesUpdateArgs} args - Arguments to update one Crypto_prices.
     * @example
     * // Update one Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends crypto_pricesUpdateArgs>(args: SelectSubset<T, crypto_pricesUpdateArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crypto_prices.
     * @param {crypto_pricesDeleteManyArgs} args - Arguments to filter Crypto_prices to delete.
     * @example
     * // Delete a few Crypto_prices
     * const { count } = await prisma.crypto_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends crypto_pricesDeleteManyArgs>(args?: SelectSubset<T, crypto_pricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crypto_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends crypto_pricesUpdateManyArgs>(args: SelectSubset<T, crypto_pricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crypto_prices and returns the data updated in the database.
     * @param {crypto_pricesUpdateManyAndReturnArgs} args - Arguments to update many Crypto_prices.
     * @example
     * // Update many Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crypto_prices and only return the `id`
     * const crypto_pricesWithIdOnly = await prisma.crypto_prices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends crypto_pricesUpdateManyAndReturnArgs>(args: SelectSubset<T, crypto_pricesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crypto_prices.
     * @param {crypto_pricesUpsertArgs} args - Arguments to update or create a Crypto_prices.
     * @example
     * // Update or create a Crypto_prices
     * const crypto_prices = await prisma.crypto_prices.upsert({
     *   create: {
     *     // ... data to create a Crypto_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crypto_prices we want to update
     *   }
     * })
     */
    upsert<T extends crypto_pricesUpsertArgs>(args: SelectSubset<T, crypto_pricesUpsertArgs<ExtArgs>>): Prisma__crypto_pricesClient<$Result.GetResult<Prisma.$crypto_pricesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crypto_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesCountArgs} args - Arguments to filter Crypto_prices to count.
     * @example
     * // Count the number of Crypto_prices
     * const count = await prisma.crypto_prices.count({
     *   where: {
     *     // ... the filter for the Crypto_prices we want to count
     *   }
     * })
    **/
    count<T extends crypto_pricesCountArgs>(
      args?: Subset<T, crypto_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Crypto_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crypto_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Crypto_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Crypto_pricesAggregateArgs>(args: Subset<T, Crypto_pricesAggregateArgs>): Prisma.PrismaPromise<GetCrypto_pricesAggregateType<T>>

    /**
     * Group by Crypto_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crypto_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crypto_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crypto_pricesGroupByArgs['orderBy'] }
        : { orderBy?: crypto_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crypto_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrypto_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crypto_prices model
   */
  readonly fields: crypto_pricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crypto_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crypto_pricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the crypto_prices model
   */
  interface crypto_pricesFieldRefs {
    readonly id: FieldRef<"crypto_prices", 'Int'>
    readonly ticker: FieldRef<"crypto_prices", 'String'>
    readonly price: FieldRef<"crypto_prices", 'Float'>
    readonly timestamp: FieldRef<"crypto_prices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * crypto_prices findUnique
   */
  export type crypto_pricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter, which crypto_prices to fetch.
     */
    where: crypto_pricesWhereUniqueInput
  }

  /**
   * crypto_prices findUniqueOrThrow
   */
  export type crypto_pricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter, which crypto_prices to fetch.
     */
    where: crypto_pricesWhereUniqueInput
  }

  /**
   * crypto_prices findFirst
   */
  export type crypto_pricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter, which crypto_prices to fetch.
     */
    where?: crypto_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_prices to fetch.
     */
    orderBy?: crypto_pricesOrderByWithRelationInput | crypto_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crypto_prices.
     */
    cursor?: crypto_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crypto_prices.
     */
    distinct?: Crypto_pricesScalarFieldEnum | Crypto_pricesScalarFieldEnum[]
  }

  /**
   * crypto_prices findFirstOrThrow
   */
  export type crypto_pricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter, which crypto_prices to fetch.
     */
    where?: crypto_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_prices to fetch.
     */
    orderBy?: crypto_pricesOrderByWithRelationInput | crypto_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crypto_prices.
     */
    cursor?: crypto_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crypto_prices.
     */
    distinct?: Crypto_pricesScalarFieldEnum | Crypto_pricesScalarFieldEnum[]
  }

  /**
   * crypto_prices findMany
   */
  export type crypto_pricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter, which crypto_prices to fetch.
     */
    where?: crypto_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crypto_prices to fetch.
     */
    orderBy?: crypto_pricesOrderByWithRelationInput | crypto_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crypto_prices.
     */
    cursor?: crypto_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crypto_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crypto_prices.
     */
    skip?: number
    distinct?: Crypto_pricesScalarFieldEnum | Crypto_pricesScalarFieldEnum[]
  }

  /**
   * crypto_prices create
   */
  export type crypto_pricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * The data needed to create a crypto_prices.
     */
    data: XOR<crypto_pricesCreateInput, crypto_pricesUncheckedCreateInput>
  }

  /**
   * crypto_prices createMany
   */
  export type crypto_pricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crypto_prices.
     */
    data: crypto_pricesCreateManyInput | crypto_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crypto_prices createManyAndReturn
   */
  export type crypto_pricesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * The data used to create many crypto_prices.
     */
    data: crypto_pricesCreateManyInput | crypto_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crypto_prices update
   */
  export type crypto_pricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * The data needed to update a crypto_prices.
     */
    data: XOR<crypto_pricesUpdateInput, crypto_pricesUncheckedUpdateInput>
    /**
     * Choose, which crypto_prices to update.
     */
    where: crypto_pricesWhereUniqueInput
  }

  /**
   * crypto_prices updateMany
   */
  export type crypto_pricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crypto_prices.
     */
    data: XOR<crypto_pricesUpdateManyMutationInput, crypto_pricesUncheckedUpdateManyInput>
    /**
     * Filter which crypto_prices to update
     */
    where?: crypto_pricesWhereInput
    /**
     * Limit how many crypto_prices to update.
     */
    limit?: number
  }

  /**
   * crypto_prices updateManyAndReturn
   */
  export type crypto_pricesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * The data used to update crypto_prices.
     */
    data: XOR<crypto_pricesUpdateManyMutationInput, crypto_pricesUncheckedUpdateManyInput>
    /**
     * Filter which crypto_prices to update
     */
    where?: crypto_pricesWhereInput
    /**
     * Limit how many crypto_prices to update.
     */
    limit?: number
  }

  /**
   * crypto_prices upsert
   */
  export type crypto_pricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * The filter to search for the crypto_prices to update in case it exists.
     */
    where: crypto_pricesWhereUniqueInput
    /**
     * In case the crypto_prices found by the `where` argument doesn't exist, create a new crypto_prices with this data.
     */
    create: XOR<crypto_pricesCreateInput, crypto_pricesUncheckedCreateInput>
    /**
     * In case the crypto_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crypto_pricesUpdateInput, crypto_pricesUncheckedUpdateInput>
  }

  /**
   * crypto_prices delete
   */
  export type crypto_pricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
    /**
     * Filter which crypto_prices to delete.
     */
    where: crypto_pricesWhereUniqueInput
  }

  /**
   * crypto_prices deleteMany
   */
  export type crypto_pricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crypto_prices to delete
     */
    where?: crypto_pricesWhereInput
    /**
     * Limit how many crypto_prices to delete.
     */
    limit?: number
  }

  /**
   * crypto_prices without action
   */
  export type crypto_pricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crypto_prices
     */
    select?: crypto_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crypto_prices
     */
    omit?: crypto_pricesOmit<ExtArgs> | null
  }


  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    blockNumber: number | null
    timestamp: number | null
    logIndex: number | null
    marketGroupId: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    blockNumber: number | null
    timestamp: bigint | null
    logIndex: number | null
    marketGroupId: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockNumber: number | null
    transactionHash: string | null
    timestamp: bigint | null
    logIndex: number | null
    marketGroupId: number | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockNumber: number | null
    transactionHash: string | null
    timestamp: bigint | null
    logIndex: number | null
    marketGroupId: number | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    createdAt: number
    blockNumber: number
    transactionHash: number
    timestamp: number
    logIndex: number
    logData: number
    marketGroupId: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    blockNumber?: true
    timestamp?: true
    logIndex?: true
    marketGroupId?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    blockNumber?: true
    timestamp?: true
    logIndex?: true
    marketGroupId?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    transactionHash?: true
    timestamp?: true
    logIndex?: true
    marketGroupId?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    transactionHash?: true
    timestamp?: true
    logIndex?: true
    marketGroupId?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    transactionHash?: true
    timestamp?: true
    logIndex?: true
    logData?: true
    marketGroupId?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
    orderBy?: eventOrderByWithAggregationInput | eventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    createdAt: Date
    blockNumber: number
    transactionHash: string
    timestamp: bigint
    logIndex: number
    logData: JsonValue
    marketGroupId: number | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    logIndex?: boolean
    logData?: boolean
    marketGroupId?: boolean
    market_group?: boolean | event$market_groupArgs<ExtArgs>
    transaction?: boolean | event$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    logIndex?: boolean
    logData?: boolean
    marketGroupId?: boolean
    market_group?: boolean | event$market_groupArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    logIndex?: boolean
    logData?: boolean
    marketGroupId?: boolean
    market_group?: boolean | event$market_groupArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectScalar = {
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    transactionHash?: boolean
    timestamp?: boolean
    logIndex?: boolean
    logData?: boolean
    marketGroupId?: boolean
  }

  export type eventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "blockNumber" | "transactionHash" | "timestamp" | "logIndex" | "logData" | "marketGroupId", ExtArgs["result"]["event"]>
  export type eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | event$market_groupArgs<ExtArgs>
    transaction?: boolean | event$transactionArgs<ExtArgs>
  }
  export type eventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | event$market_groupArgs<ExtArgs>
  }
  export type eventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | event$market_groupArgs<ExtArgs>
  }

  export type $eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event"
    objects: {
      market_group: Prisma.$market_groupPayload<ExtArgs> | null
      transaction: Prisma.$transactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      blockNumber: number
      transactionHash: string
      timestamp: bigint
      logIndex: number
      logData: Prisma.JsonValue
      marketGroupId: number | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type eventGetPayload<S extends boolean | null | undefined | eventDefaultArgs> = $Result.GetResult<Prisma.$eventPayload, S>

  type eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<eventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event'], meta: { name: 'event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventFindUniqueArgs>(args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs>(args: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventFindFirstArgs>(args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs>(args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventFindManyArgs>(args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends eventCreateArgs>(args: SelectSubset<T, eventCreateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {eventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventCreateManyArgs>(args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {eventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends eventCreateManyAndReturnArgs>(args?: SelectSubset<T, eventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends eventDeleteArgs>(args: SelectSubset<T, eventDeleteArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventUpdateArgs>(args: SelectSubset<T, eventUpdateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventDeleteManyArgs>(args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventUpdateManyArgs>(args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {eventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends eventUpdateManyAndReturnArgs>(args: SelectSubset<T, eventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends eventUpsertArgs>(args: SelectSubset<T, eventUpsertArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs['orderBy'] }
        : { orderBy?: eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event model
   */
  readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market_group<T extends event$market_groupArgs<ExtArgs> = {}>(args?: Subset<T, event$market_groupArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends event$transactionArgs<ExtArgs> = {}>(args?: Subset<T, event$transactionArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event model
   */
  interface eventFieldRefs {
    readonly id: FieldRef<"event", 'Int'>
    readonly createdAt: FieldRef<"event", 'DateTime'>
    readonly blockNumber: FieldRef<"event", 'Int'>
    readonly transactionHash: FieldRef<"event", 'String'>
    readonly timestamp: FieldRef<"event", 'BigInt'>
    readonly logIndex: FieldRef<"event", 'Int'>
    readonly logData: FieldRef<"event", 'Json'>
    readonly marketGroupId: FieldRef<"event", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findFirst
   */
  export type eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findMany
   */
  export type eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event create
   */
  export type eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>
  }

  /**
   * event createMany
   */
  export type eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event createManyAndReturn
   */
  export type eventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * event update
   */
  export type eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
    /**
     * Limit how many events to update.
     */
    limit?: number
  }

  /**
   * event updateManyAndReturn
   */
  export type eventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
    /**
     * Limit how many events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * event upsert
   */
  export type eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>
  }

  /**
   * event delete
   */
  export type eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput
    /**
     * Limit how many events to delete.
     */
    limit?: number
  }

  /**
   * event.market_group
   */
  export type event$market_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    where?: market_groupWhereInput
  }

  /**
   * event.transaction
   */
  export type event$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
  }

  /**
   * event without action
   */
  export type eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
  }


  /**
   * Model market
   */

  export type AggregateMarket = {
    _count: MarketCountAggregateOutputType | null
    _avg: MarketAvgAggregateOutputType | null
    _sum: MarketSumAggregateOutputType | null
    _min: MarketMinAggregateOutputType | null
    _max: MarketMaxAggregateOutputType | null
  }

  export type MarketAvgAggregateOutputType = {
    id: number | null
    marketId: number | null
    startTimestamp: number | null
    endTimestamp: number | null
    startingSqrtPriceX96: Decimal | null
    settlementPriceD18: Decimal | null
    baseAssetMinPriceTick: number | null
    baseAssetMaxPriceTick: number | null
    minPriceD18: Decimal | null
    maxPriceD18: Decimal | null
    marketGroupId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondamount: Decimal | null
  }

  export type MarketSumAggregateOutputType = {
    id: number | null
    marketId: number | null
    startTimestamp: number | null
    endTimestamp: number | null
    startingSqrtPriceX96: Decimal | null
    settlementPriceD18: Decimal | null
    baseAssetMinPriceTick: number | null
    baseAssetMaxPriceTick: number | null
    minPriceD18: Decimal | null
    maxPriceD18: Decimal | null
    marketGroupId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondamount: Decimal | null
  }

  export type MarketMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    marketId: number | null
    startTimestamp: number | null
    endTimestamp: number | null
    startingSqrtPriceX96: Decimal | null
    settlementPriceD18: Decimal | null
    settled: boolean | null
    baseAssetMinPriceTick: number | null
    baseAssetMaxPriceTick: number | null
    minPriceD18: Decimal | null
    maxPriceD18: Decimal | null
    marketGroupId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    public: boolean | null
    question: string | null
    poolAddress: string | null
    optionName: string | null
    rules: string | null
  }

  export type MarketMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    marketId: number | null
    startTimestamp: number | null
    endTimestamp: number | null
    startingSqrtPriceX96: Decimal | null
    settlementPriceD18: Decimal | null
    settled: boolean | null
    baseAssetMinPriceTick: number | null
    baseAssetMaxPriceTick: number | null
    minPriceD18: Decimal | null
    maxPriceD18: Decimal | null
    marketGroupId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    public: boolean | null
    question: string | null
    poolAddress: string | null
    optionName: string | null
    rules: string | null
  }

  export type MarketCountAggregateOutputType = {
    id: number
    createdAt: number
    marketId: number
    startTimestamp: number
    endTimestamp: number
    startingSqrtPriceX96: number
    settlementPriceD18: number
    settled: number
    baseAssetMinPriceTick: number
    baseAssetMaxPriceTick: number
    minPriceD18: number
    maxPriceD18: number
    marketGroupId: number
    marketParamsFeerate: number
    marketParamsAssertionliveness: number
    marketParamsBondcurrency: number
    marketParamsBondamount: number
    marketParamsClaimstatement: number
    marketParamsUniswappositionmanager: number
    marketParamsUniswapswaprouter: number
    marketParamsUniswapquoter: number
    marketParamsOptimisticoraclev3: number
    public: number
    question: number
    poolAddress: number
    optionName: number
    rules: number
    _all: number
  }


  export type MarketAvgAggregateInputType = {
    id?: true
    marketId?: true
    startTimestamp?: true
    endTimestamp?: true
    startingSqrtPriceX96?: true
    settlementPriceD18?: true
    baseAssetMinPriceTick?: true
    baseAssetMaxPriceTick?: true
    minPriceD18?: true
    maxPriceD18?: true
    marketGroupId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondamount?: true
  }

  export type MarketSumAggregateInputType = {
    id?: true
    marketId?: true
    startTimestamp?: true
    endTimestamp?: true
    startingSqrtPriceX96?: true
    settlementPriceD18?: true
    baseAssetMinPriceTick?: true
    baseAssetMaxPriceTick?: true
    minPriceD18?: true
    maxPriceD18?: true
    marketGroupId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondamount?: true
  }

  export type MarketMinAggregateInputType = {
    id?: true
    createdAt?: true
    marketId?: true
    startTimestamp?: true
    endTimestamp?: true
    startingSqrtPriceX96?: true
    settlementPriceD18?: true
    settled?: true
    baseAssetMinPriceTick?: true
    baseAssetMaxPriceTick?: true
    minPriceD18?: true
    maxPriceD18?: true
    marketGroupId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    public?: true
    question?: true
    poolAddress?: true
    optionName?: true
    rules?: true
  }

  export type MarketMaxAggregateInputType = {
    id?: true
    createdAt?: true
    marketId?: true
    startTimestamp?: true
    endTimestamp?: true
    startingSqrtPriceX96?: true
    settlementPriceD18?: true
    settled?: true
    baseAssetMinPriceTick?: true
    baseAssetMaxPriceTick?: true
    minPriceD18?: true
    maxPriceD18?: true
    marketGroupId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    public?: true
    question?: true
    poolAddress?: true
    optionName?: true
    rules?: true
  }

  export type MarketCountAggregateInputType = {
    id?: true
    createdAt?: true
    marketId?: true
    startTimestamp?: true
    endTimestamp?: true
    startingSqrtPriceX96?: true
    settlementPriceD18?: true
    settled?: true
    baseAssetMinPriceTick?: true
    baseAssetMaxPriceTick?: true
    minPriceD18?: true
    maxPriceD18?: true
    marketGroupId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    public?: true
    question?: true
    poolAddress?: true
    optionName?: true
    rules?: true
    _all?: true
  }

  export type MarketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market to aggregate.
     */
    where?: marketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of markets to fetch.
     */
    orderBy?: marketOrderByWithRelationInput | marketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned markets
    **/
    _count?: true | MarketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketMaxAggregateInputType
  }

  export type GetMarketAggregateType<T extends MarketAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket[P]>
      : GetScalarType<T[P], AggregateMarket[P]>
  }




  export type marketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marketWhereInput
    orderBy?: marketOrderByWithAggregationInput | marketOrderByWithAggregationInput[]
    by: MarketScalarFieldEnum[] | MarketScalarFieldEnum
    having?: marketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketCountAggregateInputType | true
    _avg?: MarketAvgAggregateInputType
    _sum?: MarketSumAggregateInputType
    _min?: MarketMinAggregateInputType
    _max?: MarketMaxAggregateInputType
  }

  export type MarketGroupByOutputType = {
    id: number
    createdAt: Date
    marketId: number
    startTimestamp: number | null
    endTimestamp: number | null
    startingSqrtPriceX96: Decimal | null
    settlementPriceD18: Decimal | null
    settled: boolean | null
    baseAssetMinPriceTick: number | null
    baseAssetMaxPriceTick: number | null
    minPriceD18: Decimal | null
    maxPriceD18: Decimal | null
    marketGroupId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    public: boolean
    question: string | null
    poolAddress: string | null
    optionName: string | null
    rules: string | null
    _count: MarketCountAggregateOutputType | null
    _avg: MarketAvgAggregateOutputType | null
    _sum: MarketSumAggregateOutputType | null
    _min: MarketMinAggregateOutputType | null
    _max: MarketMaxAggregateOutputType | null
  }

  type GetMarketGroupByPayload<T extends marketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketGroupByOutputType[P]>
            : GetScalarType<T[P], MarketGroupByOutputType[P]>
        }
      >
    >


  export type marketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    marketId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    startingSqrtPriceX96?: boolean
    settlementPriceD18?: boolean
    settled?: boolean
    baseAssetMinPriceTick?: boolean
    baseAssetMaxPriceTick?: boolean
    minPriceD18?: boolean
    maxPriceD18?: boolean
    marketGroupId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    public?: boolean
    question?: boolean
    poolAddress?: boolean
    optionName?: boolean
    rules?: boolean
    market_group?: boolean | market$market_groupArgs<ExtArgs>
    position?: boolean | market$positionArgs<ExtArgs>
    _count?: boolean | MarketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["market"]>

  export type marketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    marketId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    startingSqrtPriceX96?: boolean
    settlementPriceD18?: boolean
    settled?: boolean
    baseAssetMinPriceTick?: boolean
    baseAssetMaxPriceTick?: boolean
    minPriceD18?: boolean
    maxPriceD18?: boolean
    marketGroupId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    public?: boolean
    question?: boolean
    poolAddress?: boolean
    optionName?: boolean
    rules?: boolean
    market_group?: boolean | market$market_groupArgs<ExtArgs>
  }, ExtArgs["result"]["market"]>

  export type marketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    marketId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    startingSqrtPriceX96?: boolean
    settlementPriceD18?: boolean
    settled?: boolean
    baseAssetMinPriceTick?: boolean
    baseAssetMaxPriceTick?: boolean
    minPriceD18?: boolean
    maxPriceD18?: boolean
    marketGroupId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    public?: boolean
    question?: boolean
    poolAddress?: boolean
    optionName?: boolean
    rules?: boolean
    market_group?: boolean | market$market_groupArgs<ExtArgs>
  }, ExtArgs["result"]["market"]>

  export type marketSelectScalar = {
    id?: boolean
    createdAt?: boolean
    marketId?: boolean
    startTimestamp?: boolean
    endTimestamp?: boolean
    startingSqrtPriceX96?: boolean
    settlementPriceD18?: boolean
    settled?: boolean
    baseAssetMinPriceTick?: boolean
    baseAssetMaxPriceTick?: boolean
    minPriceD18?: boolean
    maxPriceD18?: boolean
    marketGroupId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    public?: boolean
    question?: boolean
    poolAddress?: boolean
    optionName?: boolean
    rules?: boolean
  }

  export type marketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "marketId" | "startTimestamp" | "endTimestamp" | "startingSqrtPriceX96" | "settlementPriceD18" | "settled" | "baseAssetMinPriceTick" | "baseAssetMaxPriceTick" | "minPriceD18" | "maxPriceD18" | "marketGroupId" | "marketParamsFeerate" | "marketParamsAssertionliveness" | "marketParamsBondcurrency" | "marketParamsBondamount" | "marketParamsClaimstatement" | "marketParamsUniswappositionmanager" | "marketParamsUniswapswaprouter" | "marketParamsUniswapquoter" | "marketParamsOptimisticoraclev3" | "public" | "question" | "poolAddress" | "optionName" | "rules", ExtArgs["result"]["market"]>
  export type marketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | market$market_groupArgs<ExtArgs>
    position?: boolean | market$positionArgs<ExtArgs>
    _count?: boolean | MarketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type marketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | market$market_groupArgs<ExtArgs>
  }
  export type marketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | market$market_groupArgs<ExtArgs>
  }

  export type $marketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "market"
    objects: {
      market_group: Prisma.$market_groupPayload<ExtArgs> | null
      position: Prisma.$positionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      marketId: number
      startTimestamp: number | null
      endTimestamp: number | null
      startingSqrtPriceX96: Prisma.Decimal | null
      settlementPriceD18: Prisma.Decimal | null
      settled: boolean | null
      baseAssetMinPriceTick: number | null
      baseAssetMaxPriceTick: number | null
      minPriceD18: Prisma.Decimal | null
      maxPriceD18: Prisma.Decimal | null
      marketGroupId: number | null
      marketParamsFeerate: number | null
      marketParamsAssertionliveness: Prisma.Decimal | null
      marketParamsBondcurrency: string | null
      marketParamsBondamount: Prisma.Decimal | null
      marketParamsClaimstatement: string | null
      marketParamsUniswappositionmanager: string | null
      marketParamsUniswapswaprouter: string | null
      marketParamsUniswapquoter: string | null
      marketParamsOptimisticoraclev3: string | null
      public: boolean
      question: string | null
      poolAddress: string | null
      optionName: string | null
      rules: string | null
    }, ExtArgs["result"]["market"]>
    composites: {}
  }

  type marketGetPayload<S extends boolean | null | undefined | marketDefaultArgs> = $Result.GetResult<Prisma.$marketPayload, S>

  type marketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<marketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketCountAggregateInputType | true
    }

  export interface marketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market'], meta: { name: 'market' } }
    /**
     * Find zero or one Market that matches the filter.
     * @param {marketFindUniqueArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marketFindUniqueArgs>(args: SelectSubset<T, marketFindUniqueArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Market that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {marketFindUniqueOrThrowArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marketFindUniqueOrThrowArgs>(args: SelectSubset<T, marketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketFindFirstArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marketFindFirstArgs>(args?: SelectSubset<T, marketFindFirstArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketFindFirstOrThrowArgs} args - Arguments to find a Market
     * @example
     * // Get one Market
     * const market = await prisma.market.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marketFindFirstOrThrowArgs>(args?: SelectSubset<T, marketFindFirstOrThrowArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Markets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Markets
     * const markets = await prisma.market.findMany()
     * 
     * // Get first 10 Markets
     * const markets = await prisma.market.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketWithIdOnly = await prisma.market.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends marketFindManyArgs>(args?: SelectSubset<T, marketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Market.
     * @param {marketCreateArgs} args - Arguments to create a Market.
     * @example
     * // Create one Market
     * const Market = await prisma.market.create({
     *   data: {
     *     // ... data to create a Market
     *   }
     * })
     * 
     */
    create<T extends marketCreateArgs>(args: SelectSubset<T, marketCreateArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Markets.
     * @param {marketCreateManyArgs} args - Arguments to create many Markets.
     * @example
     * // Create many Markets
     * const market = await prisma.market.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marketCreateManyArgs>(args?: SelectSubset<T, marketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Markets and returns the data saved in the database.
     * @param {marketCreateManyAndReturnArgs} args - Arguments to create many Markets.
     * @example
     * // Create many Markets
     * const market = await prisma.market.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Markets and only return the `id`
     * const marketWithIdOnly = await prisma.market.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends marketCreateManyAndReturnArgs>(args?: SelectSubset<T, marketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Market.
     * @param {marketDeleteArgs} args - Arguments to delete one Market.
     * @example
     * // Delete one Market
     * const Market = await prisma.market.delete({
     *   where: {
     *     // ... filter to delete one Market
     *   }
     * })
     * 
     */
    delete<T extends marketDeleteArgs>(args: SelectSubset<T, marketDeleteArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Market.
     * @param {marketUpdateArgs} args - Arguments to update one Market.
     * @example
     * // Update one Market
     * const market = await prisma.market.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marketUpdateArgs>(args: SelectSubset<T, marketUpdateArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Markets.
     * @param {marketDeleteManyArgs} args - Arguments to filter Markets to delete.
     * @example
     * // Delete a few Markets
     * const { count } = await prisma.market.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marketDeleteManyArgs>(args?: SelectSubset<T, marketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Markets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Markets
     * const market = await prisma.market.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marketUpdateManyArgs>(args: SelectSubset<T, marketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Markets and returns the data updated in the database.
     * @param {marketUpdateManyAndReturnArgs} args - Arguments to update many Markets.
     * @example
     * // Update many Markets
     * const market = await prisma.market.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Markets and only return the `id`
     * const marketWithIdOnly = await prisma.market.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends marketUpdateManyAndReturnArgs>(args: SelectSubset<T, marketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Market.
     * @param {marketUpsertArgs} args - Arguments to update or create a Market.
     * @example
     * // Update or create a Market
     * const market = await prisma.market.upsert({
     *   create: {
     *     // ... data to create a Market
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market we want to update
     *   }
     * })
     */
    upsert<T extends marketUpsertArgs>(args: SelectSubset<T, marketUpsertArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Markets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketCountArgs} args - Arguments to filter Markets to count.
     * @example
     * // Count the number of Markets
     * const count = await prisma.market.count({
     *   where: {
     *     // ... the filter for the Markets we want to count
     *   }
     * })
    **/
    count<T extends marketCountArgs>(
      args?: Subset<T, marketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketAggregateArgs>(args: Subset<T, MarketAggregateArgs>): Prisma.PrismaPromise<GetMarketAggregateType<T>>

    /**
     * Group by Market.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marketGroupByArgs['orderBy'] }
        : { orderBy?: marketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the market model
   */
  readonly fields: marketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for market.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market_group<T extends market$market_groupArgs<ExtArgs> = {}>(args?: Subset<T, market$market_groupArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends market$positionArgs<ExtArgs> = {}>(args?: Subset<T, market$positionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the market model
   */
  interface marketFieldRefs {
    readonly id: FieldRef<"market", 'Int'>
    readonly createdAt: FieldRef<"market", 'DateTime'>
    readonly marketId: FieldRef<"market", 'Int'>
    readonly startTimestamp: FieldRef<"market", 'Int'>
    readonly endTimestamp: FieldRef<"market", 'Int'>
    readonly startingSqrtPriceX96: FieldRef<"market", 'Decimal'>
    readonly settlementPriceD18: FieldRef<"market", 'Decimal'>
    readonly settled: FieldRef<"market", 'Boolean'>
    readonly baseAssetMinPriceTick: FieldRef<"market", 'Int'>
    readonly baseAssetMaxPriceTick: FieldRef<"market", 'Int'>
    readonly minPriceD18: FieldRef<"market", 'Decimal'>
    readonly maxPriceD18: FieldRef<"market", 'Decimal'>
    readonly marketGroupId: FieldRef<"market", 'Int'>
    readonly marketParamsFeerate: FieldRef<"market", 'Int'>
    readonly marketParamsAssertionliveness: FieldRef<"market", 'Decimal'>
    readonly marketParamsBondcurrency: FieldRef<"market", 'String'>
    readonly marketParamsBondamount: FieldRef<"market", 'Decimal'>
    readonly marketParamsClaimstatement: FieldRef<"market", 'String'>
    readonly marketParamsUniswappositionmanager: FieldRef<"market", 'String'>
    readonly marketParamsUniswapswaprouter: FieldRef<"market", 'String'>
    readonly marketParamsUniswapquoter: FieldRef<"market", 'String'>
    readonly marketParamsOptimisticoraclev3: FieldRef<"market", 'String'>
    readonly public: FieldRef<"market", 'Boolean'>
    readonly question: FieldRef<"market", 'String'>
    readonly poolAddress: FieldRef<"market", 'String'>
    readonly optionName: FieldRef<"market", 'String'>
    readonly rules: FieldRef<"market", 'String'>
  }
    

  // Custom InputTypes
  /**
   * market findUnique
   */
  export type marketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter, which market to fetch.
     */
    where: marketWhereUniqueInput
  }

  /**
   * market findUniqueOrThrow
   */
  export type marketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter, which market to fetch.
     */
    where: marketWhereUniqueInput
  }

  /**
   * market findFirst
   */
  export type marketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter, which market to fetch.
     */
    where?: marketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of markets to fetch.
     */
    orderBy?: marketOrderByWithRelationInput | marketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for markets.
     */
    cursor?: marketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of markets.
     */
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * market findFirstOrThrow
   */
  export type marketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter, which market to fetch.
     */
    where?: marketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of markets to fetch.
     */
    orderBy?: marketOrderByWithRelationInput | marketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for markets.
     */
    cursor?: marketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` markets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of markets.
     */
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * market findMany
   */
  export type marketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter, which markets to fetch.
     */
    where?: marketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of markets to fetch.
     */
    orderBy?: marketOrderByWithRelationInput | marketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing markets.
     */
    cursor?: marketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` markets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` markets.
     */
    skip?: number
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * market create
   */
  export type marketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * The data needed to create a market.
     */
    data: XOR<marketCreateInput, marketUncheckedCreateInput>
  }

  /**
   * market createMany
   */
  export type marketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many markets.
     */
    data: marketCreateManyInput | marketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market createManyAndReturn
   */
  export type marketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * The data used to create many markets.
     */
    data: marketCreateManyInput | marketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * market update
   */
  export type marketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * The data needed to update a market.
     */
    data: XOR<marketUpdateInput, marketUncheckedUpdateInput>
    /**
     * Choose, which market to update.
     */
    where: marketWhereUniqueInput
  }

  /**
   * market updateMany
   */
  export type marketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update markets.
     */
    data: XOR<marketUpdateManyMutationInput, marketUncheckedUpdateManyInput>
    /**
     * Filter which markets to update
     */
    where?: marketWhereInput
    /**
     * Limit how many markets to update.
     */
    limit?: number
  }

  /**
   * market updateManyAndReturn
   */
  export type marketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * The data used to update markets.
     */
    data: XOR<marketUpdateManyMutationInput, marketUncheckedUpdateManyInput>
    /**
     * Filter which markets to update
     */
    where?: marketWhereInput
    /**
     * Limit how many markets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * market upsert
   */
  export type marketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * The filter to search for the market to update in case it exists.
     */
    where: marketWhereUniqueInput
    /**
     * In case the market found by the `where` argument doesn't exist, create a new market with this data.
     */
    create: XOR<marketCreateInput, marketUncheckedCreateInput>
    /**
     * In case the market was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marketUpdateInput, marketUncheckedUpdateInput>
  }

  /**
   * market delete
   */
  export type marketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    /**
     * Filter which market to delete.
     */
    where: marketWhereUniqueInput
  }

  /**
   * market deleteMany
   */
  export type marketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which markets to delete
     */
    where?: marketWhereInput
    /**
     * Limit how many markets to delete.
     */
    limit?: number
  }

  /**
   * market.market_group
   */
  export type market$market_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    where?: market_groupWhereInput
  }

  /**
   * market.position
   */
  export type market$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    where?: positionWhereInput
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    cursor?: positionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * market without action
   */
  export type marketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
  }


  /**
   * Model market_group
   */

  export type AggregateMarket_group = {
    _count: Market_groupCountAggregateOutputType | null
    _avg: Market_groupAvgAggregateOutputType | null
    _sum: Market_groupSumAggregateOutputType | null
    _min: Market_groupMinAggregateOutputType | null
    _max: Market_groupMaxAggregateOutputType | null
  }

  export type Market_groupAvgAggregateOutputType = {
    id: number | null
    chainId: number | null
    deployTimestamp: number | null
    deployTxnBlockNumber: number | null
    resourceId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondamount: Decimal | null
    categoryId: number | null
    collateralDecimals: number | null
    minTradeSize: Decimal | null
  }

  export type Market_groupSumAggregateOutputType = {
    id: number | null
    chainId: number | null
    deployTimestamp: number | null
    deployTxnBlockNumber: number | null
    resourceId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondamount: Decimal | null
    categoryId: number | null
    collateralDecimals: number | null
    minTradeSize: Decimal | null
  }

  export type Market_groupMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    address: string | null
    vaultAddress: string | null
    isYin: boolean | null
    chainId: number | null
    deployTimestamp: number | null
    deployTxnBlockNumber: number | null
    owner: string | null
    collateralAsset: string | null
    resourceId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    isCumulative: boolean | null
    categoryId: number | null
    question: string | null
    baseTokenName: string | null
    quoteTokenName: string | null
    collateralDecimals: number | null
    collateralSymbol: string | null
    initializationNonce: string | null
    factoryAddress: string | null
    minTradeSize: Decimal | null
  }

  export type Market_groupMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    address: string | null
    vaultAddress: string | null
    isYin: boolean | null
    chainId: number | null
    deployTimestamp: number | null
    deployTxnBlockNumber: number | null
    owner: string | null
    collateralAsset: string | null
    resourceId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    isCumulative: boolean | null
    categoryId: number | null
    question: string | null
    baseTokenName: string | null
    quoteTokenName: string | null
    collateralDecimals: number | null
    collateralSymbol: string | null
    initializationNonce: string | null
    factoryAddress: string | null
    minTradeSize: Decimal | null
  }

  export type Market_groupCountAggregateOutputType = {
    id: number
    createdAt: number
    address: number
    vaultAddress: number
    isYin: number
    chainId: number
    deployTimestamp: number
    deployTxnBlockNumber: number
    owner: number
    collateralAsset: number
    resourceId: number
    marketParamsFeerate: number
    marketParamsAssertionliveness: number
    marketParamsBondcurrency: number
    marketParamsBondamount: number
    marketParamsClaimstatement: number
    marketParamsUniswappositionmanager: number
    marketParamsUniswapswaprouter: number
    marketParamsUniswapquoter: number
    marketParamsOptimisticoraclev3: number
    isCumulative: number
    categoryId: number
    question: number
    baseTokenName: number
    quoteTokenName: number
    collateralDecimals: number
    collateralSymbol: number
    initializationNonce: number
    factoryAddress: number
    minTradeSize: number
    _all: number
  }


  export type Market_groupAvgAggregateInputType = {
    id?: true
    chainId?: true
    deployTimestamp?: true
    deployTxnBlockNumber?: true
    resourceId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondamount?: true
    categoryId?: true
    collateralDecimals?: true
    minTradeSize?: true
  }

  export type Market_groupSumAggregateInputType = {
    id?: true
    chainId?: true
    deployTimestamp?: true
    deployTxnBlockNumber?: true
    resourceId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondamount?: true
    categoryId?: true
    collateralDecimals?: true
    minTradeSize?: true
  }

  export type Market_groupMinAggregateInputType = {
    id?: true
    createdAt?: true
    address?: true
    vaultAddress?: true
    isYin?: true
    chainId?: true
    deployTimestamp?: true
    deployTxnBlockNumber?: true
    owner?: true
    collateralAsset?: true
    resourceId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    isCumulative?: true
    categoryId?: true
    question?: true
    baseTokenName?: true
    quoteTokenName?: true
    collateralDecimals?: true
    collateralSymbol?: true
    initializationNonce?: true
    factoryAddress?: true
    minTradeSize?: true
  }

  export type Market_groupMaxAggregateInputType = {
    id?: true
    createdAt?: true
    address?: true
    vaultAddress?: true
    isYin?: true
    chainId?: true
    deployTimestamp?: true
    deployTxnBlockNumber?: true
    owner?: true
    collateralAsset?: true
    resourceId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    isCumulative?: true
    categoryId?: true
    question?: true
    baseTokenName?: true
    quoteTokenName?: true
    collateralDecimals?: true
    collateralSymbol?: true
    initializationNonce?: true
    factoryAddress?: true
    minTradeSize?: true
  }

  export type Market_groupCountAggregateInputType = {
    id?: true
    createdAt?: true
    address?: true
    vaultAddress?: true
    isYin?: true
    chainId?: true
    deployTimestamp?: true
    deployTxnBlockNumber?: true
    owner?: true
    collateralAsset?: true
    resourceId?: true
    marketParamsFeerate?: true
    marketParamsAssertionliveness?: true
    marketParamsBondcurrency?: true
    marketParamsBondamount?: true
    marketParamsClaimstatement?: true
    marketParamsUniswappositionmanager?: true
    marketParamsUniswapswaprouter?: true
    marketParamsUniswapquoter?: true
    marketParamsOptimisticoraclev3?: true
    isCumulative?: true
    categoryId?: true
    question?: true
    baseTokenName?: true
    quoteTokenName?: true
    collateralDecimals?: true
    collateralSymbol?: true
    initializationNonce?: true
    factoryAddress?: true
    minTradeSize?: true
    _all?: true
  }

  export type Market_groupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_group to aggregate.
     */
    where?: market_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_groups to fetch.
     */
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: market_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned market_groups
    **/
    _count?: true | Market_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Market_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Market_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Market_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Market_groupMaxAggregateInputType
  }

  export type GetMarket_groupAggregateType<T extends Market_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_group[P]>
      : GetScalarType<T[P], AggregateMarket_group[P]>
  }




  export type market_groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: market_groupWhereInput
    orderBy?: market_groupOrderByWithAggregationInput | market_groupOrderByWithAggregationInput[]
    by: Market_groupScalarFieldEnum[] | Market_groupScalarFieldEnum
    having?: market_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Market_groupCountAggregateInputType | true
    _avg?: Market_groupAvgAggregateInputType
    _sum?: Market_groupSumAggregateInputType
    _min?: Market_groupMinAggregateInputType
    _max?: Market_groupMaxAggregateInputType
  }

  export type Market_groupGroupByOutputType = {
    id: number
    createdAt: Date
    address: string | null
    vaultAddress: string | null
    isYin: boolean
    chainId: number
    deployTimestamp: number | null
    deployTxnBlockNumber: number | null
    owner: string | null
    collateralAsset: string | null
    resourceId: number | null
    marketParamsFeerate: number | null
    marketParamsAssertionliveness: Decimal | null
    marketParamsBondcurrency: string | null
    marketParamsBondamount: Decimal | null
    marketParamsClaimstatement: string | null
    marketParamsUniswappositionmanager: string | null
    marketParamsUniswapswaprouter: string | null
    marketParamsUniswapquoter: string | null
    marketParamsOptimisticoraclev3: string | null
    isCumulative: boolean
    categoryId: number | null
    question: string | null
    baseTokenName: string | null
    quoteTokenName: string | null
    collateralDecimals: number | null
    collateralSymbol: string | null
    initializationNonce: string | null
    factoryAddress: string | null
    minTradeSize: Decimal | null
    _count: Market_groupCountAggregateOutputType | null
    _avg: Market_groupAvgAggregateOutputType | null
    _sum: Market_groupSumAggregateOutputType | null
    _min: Market_groupMinAggregateOutputType | null
    _max: Market_groupMaxAggregateOutputType | null
  }

  type GetMarket_groupGroupByPayload<T extends market_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Market_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Market_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Market_groupGroupByOutputType[P]>
        }
      >
    >


  export type market_groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    address?: boolean
    vaultAddress?: boolean
    isYin?: boolean
    chainId?: boolean
    deployTimestamp?: boolean
    deployTxnBlockNumber?: boolean
    owner?: boolean
    collateralAsset?: boolean
    resourceId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    isCumulative?: boolean
    categoryId?: boolean
    question?: boolean
    baseTokenName?: boolean
    quoteTokenName?: boolean
    collateralDecimals?: boolean
    collateralSymbol?: boolean
    initializationNonce?: boolean
    factoryAddress?: boolean
    minTradeSize?: boolean
    event?: boolean | market_group$eventArgs<ExtArgs>
    market?: boolean | market_group$marketArgs<ExtArgs>
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
    _count?: boolean | Market_groupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["market_group"]>

  export type market_groupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    address?: boolean
    vaultAddress?: boolean
    isYin?: boolean
    chainId?: boolean
    deployTimestamp?: boolean
    deployTxnBlockNumber?: boolean
    owner?: boolean
    collateralAsset?: boolean
    resourceId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    isCumulative?: boolean
    categoryId?: boolean
    question?: boolean
    baseTokenName?: boolean
    quoteTokenName?: boolean
    collateralDecimals?: boolean
    collateralSymbol?: boolean
    initializationNonce?: boolean
    factoryAddress?: boolean
    minTradeSize?: boolean
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["market_group"]>

  export type market_groupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    address?: boolean
    vaultAddress?: boolean
    isYin?: boolean
    chainId?: boolean
    deployTimestamp?: boolean
    deployTxnBlockNumber?: boolean
    owner?: boolean
    collateralAsset?: boolean
    resourceId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    isCumulative?: boolean
    categoryId?: boolean
    question?: boolean
    baseTokenName?: boolean
    quoteTokenName?: boolean
    collateralDecimals?: boolean
    collateralSymbol?: boolean
    initializationNonce?: boolean
    factoryAddress?: boolean
    minTradeSize?: boolean
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["market_group"]>

  export type market_groupSelectScalar = {
    id?: boolean
    createdAt?: boolean
    address?: boolean
    vaultAddress?: boolean
    isYin?: boolean
    chainId?: boolean
    deployTimestamp?: boolean
    deployTxnBlockNumber?: boolean
    owner?: boolean
    collateralAsset?: boolean
    resourceId?: boolean
    marketParamsFeerate?: boolean
    marketParamsAssertionliveness?: boolean
    marketParamsBondcurrency?: boolean
    marketParamsBondamount?: boolean
    marketParamsClaimstatement?: boolean
    marketParamsUniswappositionmanager?: boolean
    marketParamsUniswapswaprouter?: boolean
    marketParamsUniswapquoter?: boolean
    marketParamsOptimisticoraclev3?: boolean
    isCumulative?: boolean
    categoryId?: boolean
    question?: boolean
    baseTokenName?: boolean
    quoteTokenName?: boolean
    collateralDecimals?: boolean
    collateralSymbol?: boolean
    initializationNonce?: boolean
    factoryAddress?: boolean
    minTradeSize?: boolean
  }

  export type market_groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "address" | "vaultAddress" | "isYin" | "chainId" | "deployTimestamp" | "deployTxnBlockNumber" | "owner" | "collateralAsset" | "resourceId" | "marketParamsFeerate" | "marketParamsAssertionliveness" | "marketParamsBondcurrency" | "marketParamsBondamount" | "marketParamsClaimstatement" | "marketParamsUniswappositionmanager" | "marketParamsUniswapswaprouter" | "marketParamsUniswapquoter" | "marketParamsOptimisticoraclev3" | "isCumulative" | "categoryId" | "question" | "baseTokenName" | "quoteTokenName" | "collateralDecimals" | "collateralSymbol" | "initializationNonce" | "factoryAddress" | "minTradeSize", ExtArgs["result"]["market_group"]>
  export type market_groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | market_group$eventArgs<ExtArgs>
    market?: boolean | market_group$marketArgs<ExtArgs>
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
    _count?: boolean | Market_groupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type market_groupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
  }
  export type market_groupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | market_group$resourceArgs<ExtArgs>
    category?: boolean | market_group$categoryArgs<ExtArgs>
  }

  export type $market_groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "market_group"
    objects: {
      event: Prisma.$eventPayload<ExtArgs>[]
      market: Prisma.$marketPayload<ExtArgs>[]
      resource: Prisma.$resourcePayload<ExtArgs> | null
      category: Prisma.$categoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      address: string | null
      vaultAddress: string | null
      isYin: boolean
      chainId: number
      deployTimestamp: number | null
      deployTxnBlockNumber: number | null
      owner: string | null
      collateralAsset: string | null
      resourceId: number | null
      marketParamsFeerate: number | null
      marketParamsAssertionliveness: Prisma.Decimal | null
      marketParamsBondcurrency: string | null
      marketParamsBondamount: Prisma.Decimal | null
      marketParamsClaimstatement: string | null
      marketParamsUniswappositionmanager: string | null
      marketParamsUniswapswaprouter: string | null
      marketParamsUniswapquoter: string | null
      marketParamsOptimisticoraclev3: string | null
      isCumulative: boolean
      categoryId: number | null
      question: string | null
      baseTokenName: string | null
      quoteTokenName: string | null
      collateralDecimals: number | null
      collateralSymbol: string | null
      initializationNonce: string | null
      factoryAddress: string | null
      minTradeSize: Prisma.Decimal | null
    }, ExtArgs["result"]["market_group"]>
    composites: {}
  }

  type market_groupGetPayload<S extends boolean | null | undefined | market_groupDefaultArgs> = $Result.GetResult<Prisma.$market_groupPayload, S>

  type market_groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<market_groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Market_groupCountAggregateInputType | true
    }

  export interface market_groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market_group'], meta: { name: 'market_group' } }
    /**
     * Find zero or one Market_group that matches the filter.
     * @param {market_groupFindUniqueArgs} args - Arguments to find a Market_group
     * @example
     * // Get one Market_group
     * const market_group = await prisma.market_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends market_groupFindUniqueArgs>(args: SelectSubset<T, market_groupFindUniqueArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Market_group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {market_groupFindUniqueOrThrowArgs} args - Arguments to find a Market_group
     * @example
     * // Get one Market_group
     * const market_group = await prisma.market_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends market_groupFindUniqueOrThrowArgs>(args: SelectSubset<T, market_groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupFindFirstArgs} args - Arguments to find a Market_group
     * @example
     * // Get one Market_group
     * const market_group = await prisma.market_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends market_groupFindFirstArgs>(args?: SelectSubset<T, market_groupFindFirstArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupFindFirstOrThrowArgs} args - Arguments to find a Market_group
     * @example
     * // Get one Market_group
     * const market_group = await prisma.market_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends market_groupFindFirstOrThrowArgs>(args?: SelectSubset<T, market_groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Market_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_groups
     * const market_groups = await prisma.market_group.findMany()
     * 
     * // Get first 10 Market_groups
     * const market_groups = await prisma.market_group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const market_groupWithIdOnly = await prisma.market_group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends market_groupFindManyArgs>(args?: SelectSubset<T, market_groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Market_group.
     * @param {market_groupCreateArgs} args - Arguments to create a Market_group.
     * @example
     * // Create one Market_group
     * const Market_group = await prisma.market_group.create({
     *   data: {
     *     // ... data to create a Market_group
     *   }
     * })
     * 
     */
    create<T extends market_groupCreateArgs>(args: SelectSubset<T, market_groupCreateArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Market_groups.
     * @param {market_groupCreateManyArgs} args - Arguments to create many Market_groups.
     * @example
     * // Create many Market_groups
     * const market_group = await prisma.market_group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends market_groupCreateManyArgs>(args?: SelectSubset<T, market_groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Market_groups and returns the data saved in the database.
     * @param {market_groupCreateManyAndReturnArgs} args - Arguments to create many Market_groups.
     * @example
     * // Create many Market_groups
     * const market_group = await prisma.market_group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Market_groups and only return the `id`
     * const market_groupWithIdOnly = await prisma.market_group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends market_groupCreateManyAndReturnArgs>(args?: SelectSubset<T, market_groupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Market_group.
     * @param {market_groupDeleteArgs} args - Arguments to delete one Market_group.
     * @example
     * // Delete one Market_group
     * const Market_group = await prisma.market_group.delete({
     *   where: {
     *     // ... filter to delete one Market_group
     *   }
     * })
     * 
     */
    delete<T extends market_groupDeleteArgs>(args: SelectSubset<T, market_groupDeleteArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Market_group.
     * @param {market_groupUpdateArgs} args - Arguments to update one Market_group.
     * @example
     * // Update one Market_group
     * const market_group = await prisma.market_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends market_groupUpdateArgs>(args: SelectSubset<T, market_groupUpdateArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Market_groups.
     * @param {market_groupDeleteManyArgs} args - Arguments to filter Market_groups to delete.
     * @example
     * // Delete a few Market_groups
     * const { count } = await prisma.market_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends market_groupDeleteManyArgs>(args?: SelectSubset<T, market_groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_groups
     * const market_group = await prisma.market_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends market_groupUpdateManyArgs>(args: SelectSubset<T, market_groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_groups and returns the data updated in the database.
     * @param {market_groupUpdateManyAndReturnArgs} args - Arguments to update many Market_groups.
     * @example
     * // Update many Market_groups
     * const market_group = await prisma.market_group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Market_groups and only return the `id`
     * const market_groupWithIdOnly = await prisma.market_group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends market_groupUpdateManyAndReturnArgs>(args: SelectSubset<T, market_groupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Market_group.
     * @param {market_groupUpsertArgs} args - Arguments to update or create a Market_group.
     * @example
     * // Update or create a Market_group
     * const market_group = await prisma.market_group.upsert({
     *   create: {
     *     // ... data to create a Market_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_group we want to update
     *   }
     * })
     */
    upsert<T extends market_groupUpsertArgs>(args: SelectSubset<T, market_groupUpsertArgs<ExtArgs>>): Prisma__market_groupClient<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Market_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupCountArgs} args - Arguments to filter Market_groups to count.
     * @example
     * // Count the number of Market_groups
     * const count = await prisma.market_group.count({
     *   where: {
     *     // ... the filter for the Market_groups we want to count
     *   }
     * })
    **/
    count<T extends market_groupCountArgs>(
      args?: Subset<T, market_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Market_groupAggregateArgs>(args: Subset<T, Market_groupAggregateArgs>): Prisma.PrismaPromise<GetMarket_groupAggregateType<T>>

    /**
     * Group by Market_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends market_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: market_groupGroupByArgs['orderBy'] }
        : { orderBy?: market_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, market_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarket_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the market_group model
   */
  readonly fields: market_groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for market_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__market_groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends market_group$eventArgs<ExtArgs> = {}>(args?: Subset<T, market_group$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    market<T extends market_group$marketArgs<ExtArgs> = {}>(args?: Subset<T, market_group$marketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resource<T extends market_group$resourceArgs<ExtArgs> = {}>(args?: Subset<T, market_group$resourceArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends market_group$categoryArgs<ExtArgs> = {}>(args?: Subset<T, market_group$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the market_group model
   */
  interface market_groupFieldRefs {
    readonly id: FieldRef<"market_group", 'Int'>
    readonly createdAt: FieldRef<"market_group", 'DateTime'>
    readonly address: FieldRef<"market_group", 'String'>
    readonly vaultAddress: FieldRef<"market_group", 'String'>
    readonly isYin: FieldRef<"market_group", 'Boolean'>
    readonly chainId: FieldRef<"market_group", 'Int'>
    readonly deployTimestamp: FieldRef<"market_group", 'Int'>
    readonly deployTxnBlockNumber: FieldRef<"market_group", 'Int'>
    readonly owner: FieldRef<"market_group", 'String'>
    readonly collateralAsset: FieldRef<"market_group", 'String'>
    readonly resourceId: FieldRef<"market_group", 'Int'>
    readonly marketParamsFeerate: FieldRef<"market_group", 'Int'>
    readonly marketParamsAssertionliveness: FieldRef<"market_group", 'Decimal'>
    readonly marketParamsBondcurrency: FieldRef<"market_group", 'String'>
    readonly marketParamsBondamount: FieldRef<"market_group", 'Decimal'>
    readonly marketParamsClaimstatement: FieldRef<"market_group", 'String'>
    readonly marketParamsUniswappositionmanager: FieldRef<"market_group", 'String'>
    readonly marketParamsUniswapswaprouter: FieldRef<"market_group", 'String'>
    readonly marketParamsUniswapquoter: FieldRef<"market_group", 'String'>
    readonly marketParamsOptimisticoraclev3: FieldRef<"market_group", 'String'>
    readonly isCumulative: FieldRef<"market_group", 'Boolean'>
    readonly categoryId: FieldRef<"market_group", 'Int'>
    readonly question: FieldRef<"market_group", 'String'>
    readonly baseTokenName: FieldRef<"market_group", 'String'>
    readonly quoteTokenName: FieldRef<"market_group", 'String'>
    readonly collateralDecimals: FieldRef<"market_group", 'Int'>
    readonly collateralSymbol: FieldRef<"market_group", 'String'>
    readonly initializationNonce: FieldRef<"market_group", 'String'>
    readonly factoryAddress: FieldRef<"market_group", 'String'>
    readonly minTradeSize: FieldRef<"market_group", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * market_group findUnique
   */
  export type market_groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter, which market_group to fetch.
     */
    where: market_groupWhereUniqueInput
  }

  /**
   * market_group findUniqueOrThrow
   */
  export type market_groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter, which market_group to fetch.
     */
    where: market_groupWhereUniqueInput
  }

  /**
   * market_group findFirst
   */
  export type market_groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter, which market_group to fetch.
     */
    where?: market_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_groups to fetch.
     */
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_groups.
     */
    cursor?: market_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_groups.
     */
    distinct?: Market_groupScalarFieldEnum | Market_groupScalarFieldEnum[]
  }

  /**
   * market_group findFirstOrThrow
   */
  export type market_groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter, which market_group to fetch.
     */
    where?: market_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_groups to fetch.
     */
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_groups.
     */
    cursor?: market_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_groups.
     */
    distinct?: Market_groupScalarFieldEnum | Market_groupScalarFieldEnum[]
  }

  /**
   * market_group findMany
   */
  export type market_groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter, which market_groups to fetch.
     */
    where?: market_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_groups to fetch.
     */
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing market_groups.
     */
    cursor?: market_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_groups.
     */
    skip?: number
    distinct?: Market_groupScalarFieldEnum | Market_groupScalarFieldEnum[]
  }

  /**
   * market_group create
   */
  export type market_groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * The data needed to create a market_group.
     */
    data: XOR<market_groupCreateInput, market_groupUncheckedCreateInput>
  }

  /**
   * market_group createMany
   */
  export type market_groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many market_groups.
     */
    data: market_groupCreateManyInput | market_groupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market_group createManyAndReturn
   */
  export type market_groupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * The data used to create many market_groups.
     */
    data: market_groupCreateManyInput | market_groupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * market_group update
   */
  export type market_groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * The data needed to update a market_group.
     */
    data: XOR<market_groupUpdateInput, market_groupUncheckedUpdateInput>
    /**
     * Choose, which market_group to update.
     */
    where: market_groupWhereUniqueInput
  }

  /**
   * market_group updateMany
   */
  export type market_groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update market_groups.
     */
    data: XOR<market_groupUpdateManyMutationInput, market_groupUncheckedUpdateManyInput>
    /**
     * Filter which market_groups to update
     */
    where?: market_groupWhereInput
    /**
     * Limit how many market_groups to update.
     */
    limit?: number
  }

  /**
   * market_group updateManyAndReturn
   */
  export type market_groupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * The data used to update market_groups.
     */
    data: XOR<market_groupUpdateManyMutationInput, market_groupUncheckedUpdateManyInput>
    /**
     * Filter which market_groups to update
     */
    where?: market_groupWhereInput
    /**
     * Limit how many market_groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * market_group upsert
   */
  export type market_groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * The filter to search for the market_group to update in case it exists.
     */
    where: market_groupWhereUniqueInput
    /**
     * In case the market_group found by the `where` argument doesn't exist, create a new market_group with this data.
     */
    create: XOR<market_groupCreateInput, market_groupUncheckedCreateInput>
    /**
     * In case the market_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_groupUpdateInput, market_groupUncheckedUpdateInput>
  }

  /**
   * market_group delete
   */
  export type market_groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    /**
     * Filter which market_group to delete.
     */
    where: market_groupWhereUniqueInput
  }

  /**
   * market_group deleteMany
   */
  export type market_groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_groups to delete
     */
    where?: market_groupWhereInput
    /**
     * Limit how many market_groups to delete.
     */
    limit?: number
  }

  /**
   * market_group.event
   */
  export type market_group$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    cursor?: eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * market_group.market
   */
  export type market_group$marketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    where?: marketWhereInput
    orderBy?: marketOrderByWithRelationInput | marketOrderByWithRelationInput[]
    cursor?: marketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketScalarFieldEnum | MarketScalarFieldEnum[]
  }

  /**
   * market_group.resource
   */
  export type market_group$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    where?: resourceWhereInput
  }

  /**
   * market_group.category
   */
  export type market_group$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * market_group without action
   */
  export type market_groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
  }


  /**
   * Model market_price
   */

  export type AggregateMarket_price = {
    _count: Market_priceCountAggregateOutputType | null
    _avg: Market_priceAvgAggregateOutputType | null
    _sum: Market_priceSumAggregateOutputType | null
    _min: Market_priceMinAggregateOutputType | null
    _max: Market_priceMaxAggregateOutputType | null
  }

  export type Market_priceAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
    value: Decimal | null
  }

  export type Market_priceSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    value: Decimal | null
  }

  export type Market_priceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    timestamp: bigint | null
    value: Decimal | null
  }

  export type Market_priceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    timestamp: bigint | null
    value: Decimal | null
  }

  export type Market_priceCountAggregateOutputType = {
    id: number
    createdAt: number
    timestamp: number
    value: number
    _all: number
  }


  export type Market_priceAvgAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
  }

  export type Market_priceSumAggregateInputType = {
    id?: true
    timestamp?: true
    value?: true
  }

  export type Market_priceMinAggregateInputType = {
    id?: true
    createdAt?: true
    timestamp?: true
    value?: true
  }

  export type Market_priceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    timestamp?: true
    value?: true
  }

  export type Market_priceCountAggregateInputType = {
    id?: true
    createdAt?: true
    timestamp?: true
    value?: true
    _all?: true
  }

  export type Market_priceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_price to aggregate.
     */
    where?: market_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_prices to fetch.
     */
    orderBy?: market_priceOrderByWithRelationInput | market_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: market_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned market_prices
    **/
    _count?: true | Market_priceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Market_priceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Market_priceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Market_priceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Market_priceMaxAggregateInputType
  }

  export type GetMarket_priceAggregateType<T extends Market_priceAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket_price]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_price[P]>
      : GetScalarType<T[P], AggregateMarket_price[P]>
  }




  export type market_priceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: market_priceWhereInput
    orderBy?: market_priceOrderByWithAggregationInput | market_priceOrderByWithAggregationInput[]
    by: Market_priceScalarFieldEnum[] | Market_priceScalarFieldEnum
    having?: market_priceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Market_priceCountAggregateInputType | true
    _avg?: Market_priceAvgAggregateInputType
    _sum?: Market_priceSumAggregateInputType
    _min?: Market_priceMinAggregateInputType
    _max?: Market_priceMaxAggregateInputType
  }

  export type Market_priceGroupByOutputType = {
    id: number
    createdAt: Date
    timestamp: bigint
    value: Decimal
    _count: Market_priceCountAggregateOutputType | null
    _avg: Market_priceAvgAggregateOutputType | null
    _sum: Market_priceSumAggregateOutputType | null
    _min: Market_priceMinAggregateOutputType | null
    _max: Market_priceMaxAggregateOutputType | null
  }

  type GetMarket_priceGroupByPayload<T extends market_priceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Market_priceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Market_priceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_priceGroupByOutputType[P]>
            : GetScalarType<T[P], Market_priceGroupByOutputType[P]>
        }
      >
    >


  export type market_priceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    timestamp?: boolean
    value?: boolean
    transaction?: boolean | market_price$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["market_price"]>

  export type market_priceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    timestamp?: boolean
    value?: boolean
  }, ExtArgs["result"]["market_price"]>

  export type market_priceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    timestamp?: boolean
    value?: boolean
  }, ExtArgs["result"]["market_price"]>

  export type market_priceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    timestamp?: boolean
    value?: boolean
  }

  export type market_priceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "timestamp" | "value", ExtArgs["result"]["market_price"]>
  export type market_priceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | market_price$transactionArgs<ExtArgs>
  }
  export type market_priceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type market_priceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $market_pricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "market_price"
    objects: {
      transaction: Prisma.$transactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      timestamp: bigint
      value: Prisma.Decimal
    }, ExtArgs["result"]["market_price"]>
    composites: {}
  }

  type market_priceGetPayload<S extends boolean | null | undefined | market_priceDefaultArgs> = $Result.GetResult<Prisma.$market_pricePayload, S>

  type market_priceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<market_priceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Market_priceCountAggregateInputType | true
    }

  export interface market_priceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market_price'], meta: { name: 'market_price' } }
    /**
     * Find zero or one Market_price that matches the filter.
     * @param {market_priceFindUniqueArgs} args - Arguments to find a Market_price
     * @example
     * // Get one Market_price
     * const market_price = await prisma.market_price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends market_priceFindUniqueArgs>(args: SelectSubset<T, market_priceFindUniqueArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Market_price that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {market_priceFindUniqueOrThrowArgs} args - Arguments to find a Market_price
     * @example
     * // Get one Market_price
     * const market_price = await prisma.market_price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends market_priceFindUniqueOrThrowArgs>(args: SelectSubset<T, market_priceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceFindFirstArgs} args - Arguments to find a Market_price
     * @example
     * // Get one Market_price
     * const market_price = await prisma.market_price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends market_priceFindFirstArgs>(args?: SelectSubset<T, market_priceFindFirstArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceFindFirstOrThrowArgs} args - Arguments to find a Market_price
     * @example
     * // Get one Market_price
     * const market_price = await prisma.market_price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends market_priceFindFirstOrThrowArgs>(args?: SelectSubset<T, market_priceFindFirstOrThrowArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Market_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_prices
     * const market_prices = await prisma.market_price.findMany()
     * 
     * // Get first 10 Market_prices
     * const market_prices = await prisma.market_price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const market_priceWithIdOnly = await prisma.market_price.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends market_priceFindManyArgs>(args?: SelectSubset<T, market_priceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Market_price.
     * @param {market_priceCreateArgs} args - Arguments to create a Market_price.
     * @example
     * // Create one Market_price
     * const Market_price = await prisma.market_price.create({
     *   data: {
     *     // ... data to create a Market_price
     *   }
     * })
     * 
     */
    create<T extends market_priceCreateArgs>(args: SelectSubset<T, market_priceCreateArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Market_prices.
     * @param {market_priceCreateManyArgs} args - Arguments to create many Market_prices.
     * @example
     * // Create many Market_prices
     * const market_price = await prisma.market_price.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends market_priceCreateManyArgs>(args?: SelectSubset<T, market_priceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Market_prices and returns the data saved in the database.
     * @param {market_priceCreateManyAndReturnArgs} args - Arguments to create many Market_prices.
     * @example
     * // Create many Market_prices
     * const market_price = await prisma.market_price.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Market_prices and only return the `id`
     * const market_priceWithIdOnly = await prisma.market_price.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends market_priceCreateManyAndReturnArgs>(args?: SelectSubset<T, market_priceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Market_price.
     * @param {market_priceDeleteArgs} args - Arguments to delete one Market_price.
     * @example
     * // Delete one Market_price
     * const Market_price = await prisma.market_price.delete({
     *   where: {
     *     // ... filter to delete one Market_price
     *   }
     * })
     * 
     */
    delete<T extends market_priceDeleteArgs>(args: SelectSubset<T, market_priceDeleteArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Market_price.
     * @param {market_priceUpdateArgs} args - Arguments to update one Market_price.
     * @example
     * // Update one Market_price
     * const market_price = await prisma.market_price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends market_priceUpdateArgs>(args: SelectSubset<T, market_priceUpdateArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Market_prices.
     * @param {market_priceDeleteManyArgs} args - Arguments to filter Market_prices to delete.
     * @example
     * // Delete a few Market_prices
     * const { count } = await prisma.market_price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends market_priceDeleteManyArgs>(args?: SelectSubset<T, market_priceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_prices
     * const market_price = await prisma.market_price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends market_priceUpdateManyArgs>(args: SelectSubset<T, market_priceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_prices and returns the data updated in the database.
     * @param {market_priceUpdateManyAndReturnArgs} args - Arguments to update many Market_prices.
     * @example
     * // Update many Market_prices
     * const market_price = await prisma.market_price.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Market_prices and only return the `id`
     * const market_priceWithIdOnly = await prisma.market_price.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends market_priceUpdateManyAndReturnArgs>(args: SelectSubset<T, market_priceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Market_price.
     * @param {market_priceUpsertArgs} args - Arguments to update or create a Market_price.
     * @example
     * // Update or create a Market_price
     * const market_price = await prisma.market_price.upsert({
     *   create: {
     *     // ... data to create a Market_price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_price we want to update
     *   }
     * })
     */
    upsert<T extends market_priceUpsertArgs>(args: SelectSubset<T, market_priceUpsertArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Market_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceCountArgs} args - Arguments to filter Market_prices to count.
     * @example
     * // Count the number of Market_prices
     * const count = await prisma.market_price.count({
     *   where: {
     *     // ... the filter for the Market_prices we want to count
     *   }
     * })
    **/
    count<T extends market_priceCountArgs>(
      args?: Subset<T, market_priceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_priceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_priceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Market_priceAggregateArgs>(args: Subset<T, Market_priceAggregateArgs>): Prisma.PrismaPromise<GetMarket_priceAggregateType<T>>

    /**
     * Group by Market_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_priceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends market_priceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: market_priceGroupByArgs['orderBy'] }
        : { orderBy?: market_priceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, market_priceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarket_priceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the market_price model
   */
  readonly fields: market_priceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for market_price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__market_priceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends market_price$transactionArgs<ExtArgs> = {}>(args?: Subset<T, market_price$transactionArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the market_price model
   */
  interface market_priceFieldRefs {
    readonly id: FieldRef<"market_price", 'Int'>
    readonly createdAt: FieldRef<"market_price", 'DateTime'>
    readonly timestamp: FieldRef<"market_price", 'BigInt'>
    readonly value: FieldRef<"market_price", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * market_price findUnique
   */
  export type market_priceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter, which market_price to fetch.
     */
    where: market_priceWhereUniqueInput
  }

  /**
   * market_price findUniqueOrThrow
   */
  export type market_priceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter, which market_price to fetch.
     */
    where: market_priceWhereUniqueInput
  }

  /**
   * market_price findFirst
   */
  export type market_priceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter, which market_price to fetch.
     */
    where?: market_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_prices to fetch.
     */
    orderBy?: market_priceOrderByWithRelationInput | market_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_prices.
     */
    cursor?: market_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_prices.
     */
    distinct?: Market_priceScalarFieldEnum | Market_priceScalarFieldEnum[]
  }

  /**
   * market_price findFirstOrThrow
   */
  export type market_priceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter, which market_price to fetch.
     */
    where?: market_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_prices to fetch.
     */
    orderBy?: market_priceOrderByWithRelationInput | market_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_prices.
     */
    cursor?: market_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_prices.
     */
    distinct?: Market_priceScalarFieldEnum | Market_priceScalarFieldEnum[]
  }

  /**
   * market_price findMany
   */
  export type market_priceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter, which market_prices to fetch.
     */
    where?: market_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_prices to fetch.
     */
    orderBy?: market_priceOrderByWithRelationInput | market_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing market_prices.
     */
    cursor?: market_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_prices.
     */
    skip?: number
    distinct?: Market_priceScalarFieldEnum | Market_priceScalarFieldEnum[]
  }

  /**
   * market_price create
   */
  export type market_priceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * The data needed to create a market_price.
     */
    data: XOR<market_priceCreateInput, market_priceUncheckedCreateInput>
  }

  /**
   * market_price createMany
   */
  export type market_priceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many market_prices.
     */
    data: market_priceCreateManyInput | market_priceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market_price createManyAndReturn
   */
  export type market_priceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * The data used to create many market_prices.
     */
    data: market_priceCreateManyInput | market_priceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market_price update
   */
  export type market_priceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * The data needed to update a market_price.
     */
    data: XOR<market_priceUpdateInput, market_priceUncheckedUpdateInput>
    /**
     * Choose, which market_price to update.
     */
    where: market_priceWhereUniqueInput
  }

  /**
   * market_price updateMany
   */
  export type market_priceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update market_prices.
     */
    data: XOR<market_priceUpdateManyMutationInput, market_priceUncheckedUpdateManyInput>
    /**
     * Filter which market_prices to update
     */
    where?: market_priceWhereInput
    /**
     * Limit how many market_prices to update.
     */
    limit?: number
  }

  /**
   * market_price updateManyAndReturn
   */
  export type market_priceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * The data used to update market_prices.
     */
    data: XOR<market_priceUpdateManyMutationInput, market_priceUncheckedUpdateManyInput>
    /**
     * Filter which market_prices to update
     */
    where?: market_priceWhereInput
    /**
     * Limit how many market_prices to update.
     */
    limit?: number
  }

  /**
   * market_price upsert
   */
  export type market_priceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * The filter to search for the market_price to update in case it exists.
     */
    where: market_priceWhereUniqueInput
    /**
     * In case the market_price found by the `where` argument doesn't exist, create a new market_price with this data.
     */
    create: XOR<market_priceCreateInput, market_priceUncheckedCreateInput>
    /**
     * In case the market_price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_priceUpdateInput, market_priceUncheckedUpdateInput>
  }

  /**
   * market_price delete
   */
  export type market_priceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    /**
     * Filter which market_price to delete.
     */
    where: market_priceWhereUniqueInput
  }

  /**
   * market_price deleteMany
   */
  export type market_priceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_prices to delete
     */
    where?: market_priceWhereInput
    /**
     * Limit how many market_prices to delete.
     */
    limit?: number
  }

  /**
   * market_price.transaction
   */
  export type market_price$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
  }

  /**
   * market_price without action
   */
  export type market_priceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    timestamp: number
    name: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    timestamp: bigint
    name: string
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "name", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: bigint
      name: string
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly timestamp: FieldRef<"migrations", 'BigInt'>
    readonly name: FieldRef<"migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    id: number | null
    positionId: number | null
    highPriceTick: Decimal | null
    lowPriceTick: Decimal | null
    lpBaseToken: Decimal | null
    lpQuoteToken: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    marketId: number | null
  }

  export type PositionSumAggregateOutputType = {
    id: number | null
    positionId: number | null
    highPriceTick: Decimal | null
    lowPriceTick: Decimal | null
    lpBaseToken: Decimal | null
    lpQuoteToken: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    marketId: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    positionId: number | null
    owner: string | null
    isLP: boolean | null
    highPriceTick: Decimal | null
    lowPriceTick: Decimal | null
    isSettled: boolean | null
    lpBaseToken: Decimal | null
    lpQuoteToken: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    marketId: number | null
  }

  export type PositionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    positionId: number | null
    owner: string | null
    isLP: boolean | null
    highPriceTick: Decimal | null
    lowPriceTick: Decimal | null
    isSettled: boolean | null
    lpBaseToken: Decimal | null
    lpQuoteToken: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    marketId: number | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    createdAt: number
    positionId: number
    owner: number
    isLP: number
    highPriceTick: number
    lowPriceTick: number
    isSettled: number
    lpBaseToken: number
    lpQuoteToken: number
    baseToken: number
    quoteToken: number
    borrowedBaseToken: number
    borrowedQuoteToken: number
    collateral: number
    marketId: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    id?: true
    positionId?: true
    highPriceTick?: true
    lowPriceTick?: true
    lpBaseToken?: true
    lpQuoteToken?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    marketId?: true
  }

  export type PositionSumAggregateInputType = {
    id?: true
    positionId?: true
    highPriceTick?: true
    lowPriceTick?: true
    lpBaseToken?: true
    lpQuoteToken?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    marketId?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    createdAt?: true
    positionId?: true
    owner?: true
    isLP?: true
    highPriceTick?: true
    lowPriceTick?: true
    isSettled?: true
    lpBaseToken?: true
    lpQuoteToken?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    marketId?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    positionId?: true
    owner?: true
    isLP?: true
    highPriceTick?: true
    lowPriceTick?: true
    isSettled?: true
    lpBaseToken?: true
    lpQuoteToken?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    marketId?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    createdAt?: true
    positionId?: true
    owner?: true
    isLP?: true
    highPriceTick?: true
    lowPriceTick?: true
    isSettled?: true
    lpBaseToken?: true
    lpQuoteToken?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    marketId?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which position to aggregate.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type positionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: positionWhereInput
    orderBy?: positionOrderByWithAggregationInput | positionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: positionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: number
    createdAt: Date
    positionId: number
    owner: string | null
    isLP: boolean
    highPriceTick: Decimal | null
    lowPriceTick: Decimal | null
    isSettled: boolean | null
    lpBaseToken: Decimal | null
    lpQuoteToken: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal
    marketId: number | null
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends positionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type positionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    positionId?: boolean
    owner?: boolean
    isLP?: boolean
    highPriceTick?: boolean
    lowPriceTick?: boolean
    isSettled?: boolean
    lpBaseToken?: boolean
    lpQuoteToken?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    marketId?: boolean
    market?: boolean | position$marketArgs<ExtArgs>
    transaction?: boolean | position$transactionArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type positionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    positionId?: boolean
    owner?: boolean
    isLP?: boolean
    highPriceTick?: boolean
    lowPriceTick?: boolean
    isSettled?: boolean
    lpBaseToken?: boolean
    lpQuoteToken?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    marketId?: boolean
    market?: boolean | position$marketArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type positionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    positionId?: boolean
    owner?: boolean
    isLP?: boolean
    highPriceTick?: boolean
    lowPriceTick?: boolean
    isSettled?: boolean
    lpBaseToken?: boolean
    lpQuoteToken?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    marketId?: boolean
    market?: boolean | position$marketArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type positionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    positionId?: boolean
    owner?: boolean
    isLP?: boolean
    highPriceTick?: boolean
    lowPriceTick?: boolean
    isSettled?: boolean
    lpBaseToken?: boolean
    lpQuoteToken?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    marketId?: boolean
  }

  export type positionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "positionId" | "owner" | "isLP" | "highPriceTick" | "lowPriceTick" | "isSettled" | "lpBaseToken" | "lpQuoteToken" | "baseToken" | "quoteToken" | "borrowedBaseToken" | "borrowedQuoteToken" | "collateral" | "marketId", ExtArgs["result"]["position"]>
  export type positionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | position$marketArgs<ExtArgs>
    transaction?: boolean | position$transactionArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type positionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | position$marketArgs<ExtArgs>
  }
  export type positionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market?: boolean | position$marketArgs<ExtArgs>
  }

  export type $positionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "position"
    objects: {
      market: Prisma.$marketPayload<ExtArgs> | null
      transaction: Prisma.$transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      positionId: number
      owner: string | null
      isLP: boolean
      highPriceTick: Prisma.Decimal | null
      lowPriceTick: Prisma.Decimal | null
      isSettled: boolean | null
      lpBaseToken: Prisma.Decimal | null
      lpQuoteToken: Prisma.Decimal | null
      baseToken: Prisma.Decimal | null
      quoteToken: Prisma.Decimal | null
      borrowedBaseToken: Prisma.Decimal | null
      borrowedQuoteToken: Prisma.Decimal | null
      collateral: Prisma.Decimal
      marketId: number | null
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type positionGetPayload<S extends boolean | null | undefined | positionDefaultArgs> = $Result.GetResult<Prisma.$positionPayload, S>

  type positionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<positionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface positionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['position'], meta: { name: 'position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {positionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends positionFindUniqueArgs>(args: SelectSubset<T, positionFindUniqueArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {positionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends positionFindUniqueOrThrowArgs>(args: SelectSubset<T, positionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends positionFindFirstArgs>(args?: SelectSubset<T, positionFindFirstArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends positionFindFirstOrThrowArgs>(args?: SelectSubset<T, positionFindFirstOrThrowArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends positionFindManyArgs>(args?: SelectSubset<T, positionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {positionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends positionCreateArgs>(args: SelectSubset<T, positionCreateArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {positionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends positionCreateManyArgs>(args?: SelectSubset<T, positionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {positionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends positionCreateManyAndReturnArgs>(args?: SelectSubset<T, positionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {positionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends positionDeleteArgs>(args: SelectSubset<T, positionDeleteArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {positionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends positionUpdateArgs>(args: SelectSubset<T, positionUpdateArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {positionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends positionDeleteManyArgs>(args?: SelectSubset<T, positionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends positionUpdateManyArgs>(args: SelectSubset<T, positionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {positionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends positionUpdateManyAndReturnArgs>(args: SelectSubset<T, positionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {positionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends positionUpsertArgs>(args: SelectSubset<T, positionUpsertArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends positionCountArgs>(
      args?: Subset<T, positionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends positionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: positionGroupByArgs['orderBy'] }
        : { orderBy?: positionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, positionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the position model
   */
  readonly fields: positionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__positionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market<T extends position$marketArgs<ExtArgs> = {}>(args?: Subset<T, position$marketArgs<ExtArgs>>): Prisma__marketClient<$Result.GetResult<Prisma.$marketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends position$transactionArgs<ExtArgs> = {}>(args?: Subset<T, position$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the position model
   */
  interface positionFieldRefs {
    readonly id: FieldRef<"position", 'Int'>
    readonly createdAt: FieldRef<"position", 'DateTime'>
    readonly positionId: FieldRef<"position", 'Int'>
    readonly owner: FieldRef<"position", 'String'>
    readonly isLP: FieldRef<"position", 'Boolean'>
    readonly highPriceTick: FieldRef<"position", 'Decimal'>
    readonly lowPriceTick: FieldRef<"position", 'Decimal'>
    readonly isSettled: FieldRef<"position", 'Boolean'>
    readonly lpBaseToken: FieldRef<"position", 'Decimal'>
    readonly lpQuoteToken: FieldRef<"position", 'Decimal'>
    readonly baseToken: FieldRef<"position", 'Decimal'>
    readonly quoteToken: FieldRef<"position", 'Decimal'>
    readonly borrowedBaseToken: FieldRef<"position", 'Decimal'>
    readonly borrowedQuoteToken: FieldRef<"position", 'Decimal'>
    readonly collateral: FieldRef<"position", 'Decimal'>
    readonly marketId: FieldRef<"position", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * position findUnique
   */
  export type positionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position findUniqueOrThrow
   */
  export type positionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position findFirst
   */
  export type positionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position findFirstOrThrow
   */
  export type positionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position findMany
   */
  export type positionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which positions to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position create
   */
  export type positionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The data needed to create a position.
     */
    data: XOR<positionCreateInput, positionUncheckedCreateInput>
  }

  /**
   * position createMany
   */
  export type positionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many positions.
     */
    data: positionCreateManyInput | positionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * position createManyAndReturn
   */
  export type positionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * The data used to create many positions.
     */
    data: positionCreateManyInput | positionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * position update
   */
  export type positionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The data needed to update a position.
     */
    data: XOR<positionUpdateInput, positionUncheckedUpdateInput>
    /**
     * Choose, which position to update.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position updateMany
   */
  export type positionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update positions.
     */
    data: XOR<positionUpdateManyMutationInput, positionUncheckedUpdateManyInput>
    /**
     * Filter which positions to update
     */
    where?: positionWhereInput
    /**
     * Limit how many positions to update.
     */
    limit?: number
  }

  /**
   * position updateManyAndReturn
   */
  export type positionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * The data used to update positions.
     */
    data: XOR<positionUpdateManyMutationInput, positionUncheckedUpdateManyInput>
    /**
     * Filter which positions to update
     */
    where?: positionWhereInput
    /**
     * Limit how many positions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * position upsert
   */
  export type positionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The filter to search for the position to update in case it exists.
     */
    where: positionWhereUniqueInput
    /**
     * In case the position found by the `where` argument doesn't exist, create a new position with this data.
     */
    create: XOR<positionCreateInput, positionUncheckedCreateInput>
    /**
     * In case the position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<positionUpdateInput, positionUncheckedUpdateInput>
  }

  /**
   * position delete
   */
  export type positionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter which position to delete.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position deleteMany
   */
  export type positionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which positions to delete
     */
    where?: positionWhereInput
    /**
     * Limit how many positions to delete.
     */
    limit?: number
  }

  /**
   * position.market
   */
  export type position$marketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market
     */
    select?: marketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market
     */
    omit?: marketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketInclude<ExtArgs> | null
    where?: marketWhereInput
  }

  /**
   * position.transaction
   */
  export type position$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * position without action
   */
  export type positionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
  }


  /**
   * Model render_job
   */

  export type AggregateRender_job = {
    _count: Render_jobCountAggregateOutputType | null
    _avg: Render_jobAvgAggregateOutputType | null
    _sum: Render_jobSumAggregateOutputType | null
    _min: Render_jobMinAggregateOutputType | null
    _max: Render_jobMaxAggregateOutputType | null
  }

  export type Render_jobAvgAggregateOutputType = {
    id: number | null
  }

  export type Render_jobSumAggregateOutputType = {
    id: number | null
  }

  export type Render_jobMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    jobId: string | null
    serviceId: string | null
  }

  export type Render_jobMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    jobId: string | null
    serviceId: string | null
  }

  export type Render_jobCountAggregateOutputType = {
    id: number
    createdAt: number
    jobId: number
    serviceId: number
    _all: number
  }


  export type Render_jobAvgAggregateInputType = {
    id?: true
  }

  export type Render_jobSumAggregateInputType = {
    id?: true
  }

  export type Render_jobMinAggregateInputType = {
    id?: true
    createdAt?: true
    jobId?: true
    serviceId?: true
  }

  export type Render_jobMaxAggregateInputType = {
    id?: true
    createdAt?: true
    jobId?: true
    serviceId?: true
  }

  export type Render_jobCountAggregateInputType = {
    id?: true
    createdAt?: true
    jobId?: true
    serviceId?: true
    _all?: true
  }

  export type Render_jobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which render_job to aggregate.
     */
    where?: render_jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of render_jobs to fetch.
     */
    orderBy?: render_jobOrderByWithRelationInput | render_jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: render_jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` render_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` render_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned render_jobs
    **/
    _count?: true | Render_jobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Render_jobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Render_jobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Render_jobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Render_jobMaxAggregateInputType
  }

  export type GetRender_jobAggregateType<T extends Render_jobAggregateArgs> = {
        [P in keyof T & keyof AggregateRender_job]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRender_job[P]>
      : GetScalarType<T[P], AggregateRender_job[P]>
  }




  export type render_jobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: render_jobWhereInput
    orderBy?: render_jobOrderByWithAggregationInput | render_jobOrderByWithAggregationInput[]
    by: Render_jobScalarFieldEnum[] | Render_jobScalarFieldEnum
    having?: render_jobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Render_jobCountAggregateInputType | true
    _avg?: Render_jobAvgAggregateInputType
    _sum?: Render_jobSumAggregateInputType
    _min?: Render_jobMinAggregateInputType
    _max?: Render_jobMaxAggregateInputType
  }

  export type Render_jobGroupByOutputType = {
    id: number
    createdAt: Date
    jobId: string
    serviceId: string
    _count: Render_jobCountAggregateOutputType | null
    _avg: Render_jobAvgAggregateOutputType | null
    _sum: Render_jobSumAggregateOutputType | null
    _min: Render_jobMinAggregateOutputType | null
    _max: Render_jobMaxAggregateOutputType | null
  }

  type GetRender_jobGroupByPayload<T extends render_jobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Render_jobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Render_jobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Render_jobGroupByOutputType[P]>
            : GetScalarType<T[P], Render_jobGroupByOutputType[P]>
        }
      >
    >


  export type render_jobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    jobId?: boolean
    serviceId?: boolean
  }, ExtArgs["result"]["render_job"]>

  export type render_jobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    jobId?: boolean
    serviceId?: boolean
  }, ExtArgs["result"]["render_job"]>

  export type render_jobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    jobId?: boolean
    serviceId?: boolean
  }, ExtArgs["result"]["render_job"]>

  export type render_jobSelectScalar = {
    id?: boolean
    createdAt?: boolean
    jobId?: boolean
    serviceId?: boolean
  }

  export type render_jobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "jobId" | "serviceId", ExtArgs["result"]["render_job"]>

  export type $render_jobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "render_job"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      jobId: string
      serviceId: string
    }, ExtArgs["result"]["render_job"]>
    composites: {}
  }

  type render_jobGetPayload<S extends boolean | null | undefined | render_jobDefaultArgs> = $Result.GetResult<Prisma.$render_jobPayload, S>

  type render_jobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<render_jobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Render_jobCountAggregateInputType | true
    }

  export interface render_jobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['render_job'], meta: { name: 'render_job' } }
    /**
     * Find zero or one Render_job that matches the filter.
     * @param {render_jobFindUniqueArgs} args - Arguments to find a Render_job
     * @example
     * // Get one Render_job
     * const render_job = await prisma.render_job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends render_jobFindUniqueArgs>(args: SelectSubset<T, render_jobFindUniqueArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Render_job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {render_jobFindUniqueOrThrowArgs} args - Arguments to find a Render_job
     * @example
     * // Get one Render_job
     * const render_job = await prisma.render_job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends render_jobFindUniqueOrThrowArgs>(args: SelectSubset<T, render_jobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Render_job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobFindFirstArgs} args - Arguments to find a Render_job
     * @example
     * // Get one Render_job
     * const render_job = await prisma.render_job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends render_jobFindFirstArgs>(args?: SelectSubset<T, render_jobFindFirstArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Render_job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobFindFirstOrThrowArgs} args - Arguments to find a Render_job
     * @example
     * // Get one Render_job
     * const render_job = await prisma.render_job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends render_jobFindFirstOrThrowArgs>(args?: SelectSubset<T, render_jobFindFirstOrThrowArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Render_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Render_jobs
     * const render_jobs = await prisma.render_job.findMany()
     * 
     * // Get first 10 Render_jobs
     * const render_jobs = await prisma.render_job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const render_jobWithIdOnly = await prisma.render_job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends render_jobFindManyArgs>(args?: SelectSubset<T, render_jobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Render_job.
     * @param {render_jobCreateArgs} args - Arguments to create a Render_job.
     * @example
     * // Create one Render_job
     * const Render_job = await prisma.render_job.create({
     *   data: {
     *     // ... data to create a Render_job
     *   }
     * })
     * 
     */
    create<T extends render_jobCreateArgs>(args: SelectSubset<T, render_jobCreateArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Render_jobs.
     * @param {render_jobCreateManyArgs} args - Arguments to create many Render_jobs.
     * @example
     * // Create many Render_jobs
     * const render_job = await prisma.render_job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends render_jobCreateManyArgs>(args?: SelectSubset<T, render_jobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Render_jobs and returns the data saved in the database.
     * @param {render_jobCreateManyAndReturnArgs} args - Arguments to create many Render_jobs.
     * @example
     * // Create many Render_jobs
     * const render_job = await prisma.render_job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Render_jobs and only return the `id`
     * const render_jobWithIdOnly = await prisma.render_job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends render_jobCreateManyAndReturnArgs>(args?: SelectSubset<T, render_jobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Render_job.
     * @param {render_jobDeleteArgs} args - Arguments to delete one Render_job.
     * @example
     * // Delete one Render_job
     * const Render_job = await prisma.render_job.delete({
     *   where: {
     *     // ... filter to delete one Render_job
     *   }
     * })
     * 
     */
    delete<T extends render_jobDeleteArgs>(args: SelectSubset<T, render_jobDeleteArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Render_job.
     * @param {render_jobUpdateArgs} args - Arguments to update one Render_job.
     * @example
     * // Update one Render_job
     * const render_job = await prisma.render_job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends render_jobUpdateArgs>(args: SelectSubset<T, render_jobUpdateArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Render_jobs.
     * @param {render_jobDeleteManyArgs} args - Arguments to filter Render_jobs to delete.
     * @example
     * // Delete a few Render_jobs
     * const { count } = await prisma.render_job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends render_jobDeleteManyArgs>(args?: SelectSubset<T, render_jobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Render_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Render_jobs
     * const render_job = await prisma.render_job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends render_jobUpdateManyArgs>(args: SelectSubset<T, render_jobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Render_jobs and returns the data updated in the database.
     * @param {render_jobUpdateManyAndReturnArgs} args - Arguments to update many Render_jobs.
     * @example
     * // Update many Render_jobs
     * const render_job = await prisma.render_job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Render_jobs and only return the `id`
     * const render_jobWithIdOnly = await prisma.render_job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends render_jobUpdateManyAndReturnArgs>(args: SelectSubset<T, render_jobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Render_job.
     * @param {render_jobUpsertArgs} args - Arguments to update or create a Render_job.
     * @example
     * // Update or create a Render_job
     * const render_job = await prisma.render_job.upsert({
     *   create: {
     *     // ... data to create a Render_job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Render_job we want to update
     *   }
     * })
     */
    upsert<T extends render_jobUpsertArgs>(args: SelectSubset<T, render_jobUpsertArgs<ExtArgs>>): Prisma__render_jobClient<$Result.GetResult<Prisma.$render_jobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Render_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobCountArgs} args - Arguments to filter Render_jobs to count.
     * @example
     * // Count the number of Render_jobs
     * const count = await prisma.render_job.count({
     *   where: {
     *     // ... the filter for the Render_jobs we want to count
     *   }
     * })
    **/
    count<T extends render_jobCountArgs>(
      args?: Subset<T, render_jobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Render_jobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Render_job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Render_jobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Render_jobAggregateArgs>(args: Subset<T, Render_jobAggregateArgs>): Prisma.PrismaPromise<GetRender_jobAggregateType<T>>

    /**
     * Group by Render_job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {render_jobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends render_jobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: render_jobGroupByArgs['orderBy'] }
        : { orderBy?: render_jobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, render_jobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRender_jobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the render_job model
   */
  readonly fields: render_jobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for render_job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__render_jobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the render_job model
   */
  interface render_jobFieldRefs {
    readonly id: FieldRef<"render_job", 'Int'>
    readonly createdAt: FieldRef<"render_job", 'DateTime'>
    readonly jobId: FieldRef<"render_job", 'String'>
    readonly serviceId: FieldRef<"render_job", 'String'>
  }
    

  // Custom InputTypes
  /**
   * render_job findUnique
   */
  export type render_jobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter, which render_job to fetch.
     */
    where: render_jobWhereUniqueInput
  }

  /**
   * render_job findUniqueOrThrow
   */
  export type render_jobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter, which render_job to fetch.
     */
    where: render_jobWhereUniqueInput
  }

  /**
   * render_job findFirst
   */
  export type render_jobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter, which render_job to fetch.
     */
    where?: render_jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of render_jobs to fetch.
     */
    orderBy?: render_jobOrderByWithRelationInput | render_jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for render_jobs.
     */
    cursor?: render_jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` render_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` render_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of render_jobs.
     */
    distinct?: Render_jobScalarFieldEnum | Render_jobScalarFieldEnum[]
  }

  /**
   * render_job findFirstOrThrow
   */
  export type render_jobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter, which render_job to fetch.
     */
    where?: render_jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of render_jobs to fetch.
     */
    orderBy?: render_jobOrderByWithRelationInput | render_jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for render_jobs.
     */
    cursor?: render_jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` render_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` render_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of render_jobs.
     */
    distinct?: Render_jobScalarFieldEnum | Render_jobScalarFieldEnum[]
  }

  /**
   * render_job findMany
   */
  export type render_jobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter, which render_jobs to fetch.
     */
    where?: render_jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of render_jobs to fetch.
     */
    orderBy?: render_jobOrderByWithRelationInput | render_jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing render_jobs.
     */
    cursor?: render_jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` render_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` render_jobs.
     */
    skip?: number
    distinct?: Render_jobScalarFieldEnum | Render_jobScalarFieldEnum[]
  }

  /**
   * render_job create
   */
  export type render_jobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * The data needed to create a render_job.
     */
    data: XOR<render_jobCreateInput, render_jobUncheckedCreateInput>
  }

  /**
   * render_job createMany
   */
  export type render_jobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many render_jobs.
     */
    data: render_jobCreateManyInput | render_jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * render_job createManyAndReturn
   */
  export type render_jobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * The data used to create many render_jobs.
     */
    data: render_jobCreateManyInput | render_jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * render_job update
   */
  export type render_jobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * The data needed to update a render_job.
     */
    data: XOR<render_jobUpdateInput, render_jobUncheckedUpdateInput>
    /**
     * Choose, which render_job to update.
     */
    where: render_jobWhereUniqueInput
  }

  /**
   * render_job updateMany
   */
  export type render_jobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update render_jobs.
     */
    data: XOR<render_jobUpdateManyMutationInput, render_jobUncheckedUpdateManyInput>
    /**
     * Filter which render_jobs to update
     */
    where?: render_jobWhereInput
    /**
     * Limit how many render_jobs to update.
     */
    limit?: number
  }

  /**
   * render_job updateManyAndReturn
   */
  export type render_jobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * The data used to update render_jobs.
     */
    data: XOR<render_jobUpdateManyMutationInput, render_jobUncheckedUpdateManyInput>
    /**
     * Filter which render_jobs to update
     */
    where?: render_jobWhereInput
    /**
     * Limit how many render_jobs to update.
     */
    limit?: number
  }

  /**
   * render_job upsert
   */
  export type render_jobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * The filter to search for the render_job to update in case it exists.
     */
    where: render_jobWhereUniqueInput
    /**
     * In case the render_job found by the `where` argument doesn't exist, create a new render_job with this data.
     */
    create: XOR<render_jobCreateInput, render_jobUncheckedCreateInput>
    /**
     * In case the render_job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<render_jobUpdateInput, render_jobUncheckedUpdateInput>
  }

  /**
   * render_job delete
   */
  export type render_jobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
    /**
     * Filter which render_job to delete.
     */
    where: render_jobWhereUniqueInput
  }

  /**
   * render_job deleteMany
   */
  export type render_jobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which render_jobs to delete
     */
    where?: render_jobWhereInput
    /**
     * Limit how many render_jobs to delete.
     */
    limit?: number
  }

  /**
   * render_job without action
   */
  export type render_jobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the render_job
     */
    select?: render_jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the render_job
     */
    omit?: render_jobOmit<ExtArgs> | null
  }


  /**
   * Model resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    slug: string | null
    categoryId: number | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    slug: string | null
    categoryId: number | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    slug: number
    categoryId: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
    categoryId?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
    categoryId?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    slug?: true
    categoryId?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resource to aggregate.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type resourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourceWhereInput
    orderBy?: resourceOrderByWithAggregationInput | resourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: resourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    slug: string
    categoryId: number | null
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends resourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type resourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
    market_group?: boolean | resource$market_groupArgs<ExtArgs>
    category?: boolean | resource$categoryArgs<ExtArgs>
    resource_price?: boolean | resource$resource_priceArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
    category?: boolean | resource$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
    category?: boolean | resource$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type resourceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
  }

  export type resourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "slug" | "categoryId", ExtArgs["result"]["resource"]>
  export type resourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    market_group?: boolean | resource$market_groupArgs<ExtArgs>
    category?: boolean | resource$categoryArgs<ExtArgs>
    resource_price?: boolean | resource$resource_priceArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type resourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | resource$categoryArgs<ExtArgs>
  }
  export type resourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | resource$categoryArgs<ExtArgs>
  }

  export type $resourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resource"
    objects: {
      market_group: Prisma.$market_groupPayload<ExtArgs>[]
      category: Prisma.$categoryPayload<ExtArgs> | null
      resource_price: Prisma.$resource_pricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      slug: string
      categoryId: number | null
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type resourceGetPayload<S extends boolean | null | undefined | resourceDefaultArgs> = $Result.GetResult<Prisma.$resourcePayload, S>

  type resourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface resourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resource'], meta: { name: 'resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {resourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resourceFindUniqueArgs>(args: SelectSubset<T, resourceFindUniqueArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resourceFindUniqueOrThrowArgs>(args: SelectSubset<T, resourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resourceFindFirstArgs>(args?: SelectSubset<T, resourceFindFirstArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resourceFindFirstOrThrowArgs>(args?: SelectSubset<T, resourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resourceFindManyArgs>(args?: SelectSubset<T, resourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {resourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends resourceCreateArgs>(args: SelectSubset<T, resourceCreateArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {resourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resourceCreateManyArgs>(args?: SelectSubset<T, resourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {resourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resourceCreateManyAndReturnArgs>(args?: SelectSubset<T, resourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {resourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends resourceDeleteArgs>(args: SelectSubset<T, resourceDeleteArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {resourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resourceUpdateArgs>(args: SelectSubset<T, resourceUpdateArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {resourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resourceDeleteManyArgs>(args?: SelectSubset<T, resourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resourceUpdateManyArgs>(args: SelectSubset<T, resourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {resourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resourceUpdateManyAndReturnArgs>(args: SelectSubset<T, resourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {resourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends resourceUpsertArgs>(args: SelectSubset<T, resourceUpsertArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends resourceCountArgs>(
      args?: Subset<T, resourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resourceGroupByArgs['orderBy'] }
        : { orderBy?: resourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resource model
   */
  readonly fields: resourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    market_group<T extends resource$market_groupArgs<ExtArgs> = {}>(args?: Subset<T, resource$market_groupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends resource$categoryArgs<ExtArgs> = {}>(args?: Subset<T, resource$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resource_price<T extends resource$resource_priceArgs<ExtArgs> = {}>(args?: Subset<T, resource$resource_priceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resource model
   */
  interface resourceFieldRefs {
    readonly id: FieldRef<"resource", 'Int'>
    readonly createdAt: FieldRef<"resource", 'DateTime'>
    readonly name: FieldRef<"resource", 'String'>
    readonly slug: FieldRef<"resource", 'String'>
    readonly categoryId: FieldRef<"resource", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * resource findUnique
   */
  export type resourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource findUniqueOrThrow
   */
  export type resourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource findFirst
   */
  export type resourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource findFirstOrThrow
   */
  export type resourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resource to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource findMany
   */
  export type resourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourceOrderByWithRelationInput | resourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resources.
     */
    cursor?: resourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * resource create
   */
  export type resourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The data needed to create a resource.
     */
    data: XOR<resourceCreateInput, resourceUncheckedCreateInput>
  }

  /**
   * resource createMany
   */
  export type resourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resources.
     */
    data: resourceCreateManyInput | resourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resource createManyAndReturn
   */
  export type resourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * The data used to create many resources.
     */
    data: resourceCreateManyInput | resourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource update
   */
  export type resourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The data needed to update a resource.
     */
    data: XOR<resourceUpdateInput, resourceUncheckedUpdateInput>
    /**
     * Choose, which resource to update.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource updateMany
   */
  export type resourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resources.
     */
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
  }

  /**
   * resource updateManyAndReturn
   */
  export type resourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * The data used to update resources.
     */
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource upsert
   */
  export type resourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * The filter to search for the resource to update in case it exists.
     */
    where: resourceWhereUniqueInput
    /**
     * In case the resource found by the `where` argument doesn't exist, create a new resource with this data.
     */
    create: XOR<resourceCreateInput, resourceUncheckedCreateInput>
    /**
     * In case the resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resourceUpdateInput, resourceUncheckedUpdateInput>
  }

  /**
   * resource delete
   */
  export type resourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    /**
     * Filter which resource to delete.
     */
    where: resourceWhereUniqueInput
  }

  /**
   * resource deleteMany
   */
  export type resourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to delete
     */
    where?: resourceWhereInput
    /**
     * Limit how many resources to delete.
     */
    limit?: number
  }

  /**
   * resource.market_group
   */
  export type resource$market_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_group
     */
    select?: market_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_group
     */
    omit?: market_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_groupInclude<ExtArgs> | null
    where?: market_groupWhereInput
    orderBy?: market_groupOrderByWithRelationInput | market_groupOrderByWithRelationInput[]
    cursor?: market_groupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Market_groupScalarFieldEnum | Market_groupScalarFieldEnum[]
  }

  /**
   * resource.category
   */
  export type resource$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * resource.resource_price
   */
  export type resource$resource_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    where?: resource_priceWhereInput
    orderBy?: resource_priceOrderByWithRelationInput | resource_priceOrderByWithRelationInput[]
    cursor?: resource_priceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Resource_priceScalarFieldEnum | Resource_priceScalarFieldEnum[]
  }

  /**
   * resource without action
   */
  export type resourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
  }


  /**
   * Model resource_price
   */

  export type AggregateResource_price = {
    _count: Resource_priceCountAggregateOutputType | null
    _avg: Resource_priceAvgAggregateOutputType | null
    _sum: Resource_priceSumAggregateOutputType | null
    _min: Resource_priceMinAggregateOutputType | null
    _max: Resource_priceMaxAggregateOutputType | null
  }

  export type Resource_priceAvgAggregateOutputType = {
    id: number | null
    blockNumber: number | null
    timestamp: number | null
    value: Decimal | null
    used: Decimal | null
    feePaid: Decimal | null
    resourceId: number | null
  }

  export type Resource_priceSumAggregateOutputType = {
    id: number | null
    blockNumber: number | null
    timestamp: number | null
    value: Decimal | null
    used: Decimal | null
    feePaid: Decimal | null
    resourceId: number | null
  }

  export type Resource_priceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockNumber: number | null
    timestamp: number | null
    value: Decimal | null
    used: Decimal | null
    feePaid: Decimal | null
    resourceId: number | null
  }

  export type Resource_priceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockNumber: number | null
    timestamp: number | null
    value: Decimal | null
    used: Decimal | null
    feePaid: Decimal | null
    resourceId: number | null
  }

  export type Resource_priceCountAggregateOutputType = {
    id: number
    createdAt: number
    blockNumber: number
    timestamp: number
    value: number
    used: number
    feePaid: number
    resourceId: number
    _all: number
  }


  export type Resource_priceAvgAggregateInputType = {
    id?: true
    blockNumber?: true
    timestamp?: true
    value?: true
    used?: true
    feePaid?: true
    resourceId?: true
  }

  export type Resource_priceSumAggregateInputType = {
    id?: true
    blockNumber?: true
    timestamp?: true
    value?: true
    used?: true
    feePaid?: true
    resourceId?: true
  }

  export type Resource_priceMinAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    timestamp?: true
    value?: true
    used?: true
    feePaid?: true
    resourceId?: true
  }

  export type Resource_priceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    timestamp?: true
    value?: true
    used?: true
    feePaid?: true
    resourceId?: true
  }

  export type Resource_priceCountAggregateInputType = {
    id?: true
    createdAt?: true
    blockNumber?: true
    timestamp?: true
    value?: true
    used?: true
    feePaid?: true
    resourceId?: true
    _all?: true
  }

  export type Resource_priceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resource_price to aggregate.
     */
    where?: resource_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resource_prices to fetch.
     */
    orderBy?: resource_priceOrderByWithRelationInput | resource_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resource_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resource_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resource_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resource_prices
    **/
    _count?: true | Resource_priceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Resource_priceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Resource_priceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Resource_priceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Resource_priceMaxAggregateInputType
  }

  export type GetResource_priceAggregateType<T extends Resource_priceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource_price]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource_price[P]>
      : GetScalarType<T[P], AggregateResource_price[P]>
  }




  export type resource_priceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resource_priceWhereInput
    orderBy?: resource_priceOrderByWithAggregationInput | resource_priceOrderByWithAggregationInput[]
    by: Resource_priceScalarFieldEnum[] | Resource_priceScalarFieldEnum
    having?: resource_priceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Resource_priceCountAggregateInputType | true
    _avg?: Resource_priceAvgAggregateInputType
    _sum?: Resource_priceSumAggregateInputType
    _min?: Resource_priceMinAggregateInputType
    _max?: Resource_priceMaxAggregateInputType
  }

  export type Resource_priceGroupByOutputType = {
    id: number
    createdAt: Date
    blockNumber: number
    timestamp: number
    value: Decimal
    used: Decimal
    feePaid: Decimal
    resourceId: number | null
    _count: Resource_priceCountAggregateOutputType | null
    _avg: Resource_priceAvgAggregateOutputType | null
    _sum: Resource_priceSumAggregateOutputType | null
    _min: Resource_priceMinAggregateOutputType | null
    _max: Resource_priceMaxAggregateOutputType | null
  }

  type GetResource_priceGroupByPayload<T extends resource_priceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Resource_priceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Resource_priceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Resource_priceGroupByOutputType[P]>
            : GetScalarType<T[P], Resource_priceGroupByOutputType[P]>
        }
      >
    >


  export type resource_priceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    value?: boolean
    used?: boolean
    feePaid?: boolean
    resourceId?: boolean
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["resource_price"]>

  export type resource_priceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    value?: boolean
    used?: boolean
    feePaid?: boolean
    resourceId?: boolean
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["resource_price"]>

  export type resource_priceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    value?: boolean
    used?: boolean
    feePaid?: boolean
    resourceId?: boolean
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["resource_price"]>

  export type resource_priceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    value?: boolean
    used?: boolean
    feePaid?: boolean
    resourceId?: boolean
  }

  export type resource_priceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "blockNumber" | "timestamp" | "value" | "used" | "feePaid" | "resourceId", ExtArgs["result"]["resource_price"]>
  export type resource_priceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }
  export type resource_priceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }
  export type resource_priceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | resource_price$resourceArgs<ExtArgs>
  }

  export type $resource_pricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resource_price"
    objects: {
      resource: Prisma.$resourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      blockNumber: number
      timestamp: number
      value: Prisma.Decimal
      used: Prisma.Decimal
      feePaid: Prisma.Decimal
      resourceId: number | null
    }, ExtArgs["result"]["resource_price"]>
    composites: {}
  }

  type resource_priceGetPayload<S extends boolean | null | undefined | resource_priceDefaultArgs> = $Result.GetResult<Prisma.$resource_pricePayload, S>

  type resource_priceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resource_priceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Resource_priceCountAggregateInputType | true
    }

  export interface resource_priceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resource_price'], meta: { name: 'resource_price' } }
    /**
     * Find zero or one Resource_price that matches the filter.
     * @param {resource_priceFindUniqueArgs} args - Arguments to find a Resource_price
     * @example
     * // Get one Resource_price
     * const resource_price = await prisma.resource_price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resource_priceFindUniqueArgs>(args: SelectSubset<T, resource_priceFindUniqueArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource_price that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resource_priceFindUniqueOrThrowArgs} args - Arguments to find a Resource_price
     * @example
     * // Get one Resource_price
     * const resource_price = await prisma.resource_price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resource_priceFindUniqueOrThrowArgs>(args: SelectSubset<T, resource_priceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource_price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceFindFirstArgs} args - Arguments to find a Resource_price
     * @example
     * // Get one Resource_price
     * const resource_price = await prisma.resource_price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resource_priceFindFirstArgs>(args?: SelectSubset<T, resource_priceFindFirstArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource_price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceFindFirstOrThrowArgs} args - Arguments to find a Resource_price
     * @example
     * // Get one Resource_price
     * const resource_price = await prisma.resource_price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resource_priceFindFirstOrThrowArgs>(args?: SelectSubset<T, resource_priceFindFirstOrThrowArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resource_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resource_prices
     * const resource_prices = await prisma.resource_price.findMany()
     * 
     * // Get first 10 Resource_prices
     * const resource_prices = await prisma.resource_price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resource_priceWithIdOnly = await prisma.resource_price.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends resource_priceFindManyArgs>(args?: SelectSubset<T, resource_priceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource_price.
     * @param {resource_priceCreateArgs} args - Arguments to create a Resource_price.
     * @example
     * // Create one Resource_price
     * const Resource_price = await prisma.resource_price.create({
     *   data: {
     *     // ... data to create a Resource_price
     *   }
     * })
     * 
     */
    create<T extends resource_priceCreateArgs>(args: SelectSubset<T, resource_priceCreateArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resource_prices.
     * @param {resource_priceCreateManyArgs} args - Arguments to create many Resource_prices.
     * @example
     * // Create many Resource_prices
     * const resource_price = await prisma.resource_price.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resource_priceCreateManyArgs>(args?: SelectSubset<T, resource_priceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resource_prices and returns the data saved in the database.
     * @param {resource_priceCreateManyAndReturnArgs} args - Arguments to create many Resource_prices.
     * @example
     * // Create many Resource_prices
     * const resource_price = await prisma.resource_price.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resource_prices and only return the `id`
     * const resource_priceWithIdOnly = await prisma.resource_price.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends resource_priceCreateManyAndReturnArgs>(args?: SelectSubset<T, resource_priceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource_price.
     * @param {resource_priceDeleteArgs} args - Arguments to delete one Resource_price.
     * @example
     * // Delete one Resource_price
     * const Resource_price = await prisma.resource_price.delete({
     *   where: {
     *     // ... filter to delete one Resource_price
     *   }
     * })
     * 
     */
    delete<T extends resource_priceDeleteArgs>(args: SelectSubset<T, resource_priceDeleteArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource_price.
     * @param {resource_priceUpdateArgs} args - Arguments to update one Resource_price.
     * @example
     * // Update one Resource_price
     * const resource_price = await prisma.resource_price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resource_priceUpdateArgs>(args: SelectSubset<T, resource_priceUpdateArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resource_prices.
     * @param {resource_priceDeleteManyArgs} args - Arguments to filter Resource_prices to delete.
     * @example
     * // Delete a few Resource_prices
     * const { count } = await prisma.resource_price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resource_priceDeleteManyArgs>(args?: SelectSubset<T, resource_priceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resource_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resource_prices
     * const resource_price = await prisma.resource_price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resource_priceUpdateManyArgs>(args: SelectSubset<T, resource_priceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resource_prices and returns the data updated in the database.
     * @param {resource_priceUpdateManyAndReturnArgs} args - Arguments to update many Resource_prices.
     * @example
     * // Update many Resource_prices
     * const resource_price = await prisma.resource_price.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resource_prices and only return the `id`
     * const resource_priceWithIdOnly = await prisma.resource_price.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends resource_priceUpdateManyAndReturnArgs>(args: SelectSubset<T, resource_priceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource_price.
     * @param {resource_priceUpsertArgs} args - Arguments to update or create a Resource_price.
     * @example
     * // Update or create a Resource_price
     * const resource_price = await prisma.resource_price.upsert({
     *   create: {
     *     // ... data to create a Resource_price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource_price we want to update
     *   }
     * })
     */
    upsert<T extends resource_priceUpsertArgs>(args: SelectSubset<T, resource_priceUpsertArgs<ExtArgs>>): Prisma__resource_priceClient<$Result.GetResult<Prisma.$resource_pricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resource_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceCountArgs} args - Arguments to filter Resource_prices to count.
     * @example
     * // Count the number of Resource_prices
     * const count = await prisma.resource_price.count({
     *   where: {
     *     // ... the filter for the Resource_prices we want to count
     *   }
     * })
    **/
    count<T extends resource_priceCountArgs>(
      args?: Subset<T, resource_priceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Resource_priceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Resource_priceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Resource_priceAggregateArgs>(args: Subset<T, Resource_priceAggregateArgs>): Prisma.PrismaPromise<GetResource_priceAggregateType<T>>

    /**
     * Group by Resource_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resource_priceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resource_priceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resource_priceGroupByArgs['orderBy'] }
        : { orderBy?: resource_priceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resource_priceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResource_priceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resource_price model
   */
  readonly fields: resource_priceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resource_price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resource_priceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends resource_price$resourceArgs<ExtArgs> = {}>(args?: Subset<T, resource_price$resourceArgs<ExtArgs>>): Prisma__resourceClient<$Result.GetResult<Prisma.$resourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resource_price model
   */
  interface resource_priceFieldRefs {
    readonly id: FieldRef<"resource_price", 'Int'>
    readonly createdAt: FieldRef<"resource_price", 'DateTime'>
    readonly blockNumber: FieldRef<"resource_price", 'Int'>
    readonly timestamp: FieldRef<"resource_price", 'Int'>
    readonly value: FieldRef<"resource_price", 'Decimal'>
    readonly used: FieldRef<"resource_price", 'Decimal'>
    readonly feePaid: FieldRef<"resource_price", 'Decimal'>
    readonly resourceId: FieldRef<"resource_price", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * resource_price findUnique
   */
  export type resource_priceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter, which resource_price to fetch.
     */
    where: resource_priceWhereUniqueInput
  }

  /**
   * resource_price findUniqueOrThrow
   */
  export type resource_priceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter, which resource_price to fetch.
     */
    where: resource_priceWhereUniqueInput
  }

  /**
   * resource_price findFirst
   */
  export type resource_priceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter, which resource_price to fetch.
     */
    where?: resource_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resource_prices to fetch.
     */
    orderBy?: resource_priceOrderByWithRelationInput | resource_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resource_prices.
     */
    cursor?: resource_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resource_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resource_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resource_prices.
     */
    distinct?: Resource_priceScalarFieldEnum | Resource_priceScalarFieldEnum[]
  }

  /**
   * resource_price findFirstOrThrow
   */
  export type resource_priceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter, which resource_price to fetch.
     */
    where?: resource_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resource_prices to fetch.
     */
    orderBy?: resource_priceOrderByWithRelationInput | resource_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resource_prices.
     */
    cursor?: resource_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resource_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resource_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resource_prices.
     */
    distinct?: Resource_priceScalarFieldEnum | Resource_priceScalarFieldEnum[]
  }

  /**
   * resource_price findMany
   */
  export type resource_priceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter, which resource_prices to fetch.
     */
    where?: resource_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resource_prices to fetch.
     */
    orderBy?: resource_priceOrderByWithRelationInput | resource_priceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resource_prices.
     */
    cursor?: resource_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resource_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resource_prices.
     */
    skip?: number
    distinct?: Resource_priceScalarFieldEnum | Resource_priceScalarFieldEnum[]
  }

  /**
   * resource_price create
   */
  export type resource_priceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * The data needed to create a resource_price.
     */
    data: XOR<resource_priceCreateInput, resource_priceUncheckedCreateInput>
  }

  /**
   * resource_price createMany
   */
  export type resource_priceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resource_prices.
     */
    data: resource_priceCreateManyInput | resource_priceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resource_price createManyAndReturn
   */
  export type resource_priceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * The data used to create many resource_prices.
     */
    data: resource_priceCreateManyInput | resource_priceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource_price update
   */
  export type resource_priceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * The data needed to update a resource_price.
     */
    data: XOR<resource_priceUpdateInput, resource_priceUncheckedUpdateInput>
    /**
     * Choose, which resource_price to update.
     */
    where: resource_priceWhereUniqueInput
  }

  /**
   * resource_price updateMany
   */
  export type resource_priceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resource_prices.
     */
    data: XOR<resource_priceUpdateManyMutationInput, resource_priceUncheckedUpdateManyInput>
    /**
     * Filter which resource_prices to update
     */
    where?: resource_priceWhereInput
    /**
     * Limit how many resource_prices to update.
     */
    limit?: number
  }

  /**
   * resource_price updateManyAndReturn
   */
  export type resource_priceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * The data used to update resource_prices.
     */
    data: XOR<resource_priceUpdateManyMutationInput, resource_priceUncheckedUpdateManyInput>
    /**
     * Filter which resource_prices to update
     */
    where?: resource_priceWhereInput
    /**
     * Limit how many resource_prices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * resource_price upsert
   */
  export type resource_priceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * The filter to search for the resource_price to update in case it exists.
     */
    where: resource_priceWhereUniqueInput
    /**
     * In case the resource_price found by the `where` argument doesn't exist, create a new resource_price with this data.
     */
    create: XOR<resource_priceCreateInput, resource_priceUncheckedCreateInput>
    /**
     * In case the resource_price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resource_priceUpdateInput, resource_priceUncheckedUpdateInput>
  }

  /**
   * resource_price delete
   */
  export type resource_priceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
    /**
     * Filter which resource_price to delete.
     */
    where: resource_priceWhereUniqueInput
  }

  /**
   * resource_price deleteMany
   */
  export type resource_priceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resource_prices to delete
     */
    where?: resource_priceWhereInput
    /**
     * Limit how many resource_prices to delete.
     */
    limit?: number
  }

  /**
   * resource_price.resource
   */
  export type resource_price$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource
     */
    select?: resourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource
     */
    omit?: resourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourceInclude<ExtArgs> | null
    where?: resourceWhereInput
  }

  /**
   * resource_price without action
   */
  export type resource_priceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resource_price
     */
    select?: resource_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resource_price
     */
    omit?: resource_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resource_priceInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    tradeRatioD18: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    lpBaseDeltaToken: Decimal | null
    lpQuoteDeltaToken: Decimal | null
    eventId: number | null
    positionId: number | null
    marketPriceId: number | null
    collateralTransferId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    tradeRatioD18: Decimal | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    lpBaseDeltaToken: Decimal | null
    lpQuoteDeltaToken: Decimal | null
    eventId: number | null
    positionId: number | null
    marketPriceId: number | null
    collateralTransferId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    tradeRatioD18: Decimal | null
    type: $Enums.transaction_type_enum | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    lpBaseDeltaToken: Decimal | null
    lpQuoteDeltaToken: Decimal | null
    eventId: number | null
    positionId: number | null
    marketPriceId: number | null
    collateralTransferId: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    tradeRatioD18: Decimal | null
    type: $Enums.transaction_type_enum | null
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal | null
    lpBaseDeltaToken: Decimal | null
    lpQuoteDeltaToken: Decimal | null
    eventId: number | null
    positionId: number | null
    marketPriceId: number | null
    collateralTransferId: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    createdAt: number
    tradeRatioD18: number
    type: number
    baseToken: number
    quoteToken: number
    borrowedBaseToken: number
    borrowedQuoteToken: number
    collateral: number
    lpBaseDeltaToken: number
    lpQuoteDeltaToken: number
    eventId: number
    positionId: number
    marketPriceId: number
    collateralTransferId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    tradeRatioD18?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    lpBaseDeltaToken?: true
    lpQuoteDeltaToken?: true
    eventId?: true
    positionId?: true
    marketPriceId?: true
    collateralTransferId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    tradeRatioD18?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    lpBaseDeltaToken?: true
    lpQuoteDeltaToken?: true
    eventId?: true
    positionId?: true
    marketPriceId?: true
    collateralTransferId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    tradeRatioD18?: true
    type?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    lpBaseDeltaToken?: true
    lpQuoteDeltaToken?: true
    eventId?: true
    positionId?: true
    marketPriceId?: true
    collateralTransferId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    tradeRatioD18?: true
    type?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    lpBaseDeltaToken?: true
    lpQuoteDeltaToken?: true
    eventId?: true
    positionId?: true
    marketPriceId?: true
    collateralTransferId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    tradeRatioD18?: true
    type?: true
    baseToken?: true
    quoteToken?: true
    borrowedBaseToken?: true
    borrowedQuoteToken?: true
    collateral?: true
    lpBaseDeltaToken?: true
    lpQuoteDeltaToken?: true
    eventId?: true
    positionId?: true
    marketPriceId?: true
    collateralTransferId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    createdAt: Date
    tradeRatioD18: Decimal | null
    type: $Enums.transaction_type_enum
    baseToken: Decimal | null
    quoteToken: Decimal | null
    borrowedBaseToken: Decimal | null
    borrowedQuoteToken: Decimal | null
    collateral: Decimal
    lpBaseDeltaToken: Decimal | null
    lpQuoteDeltaToken: Decimal | null
    eventId: number | null
    positionId: number | null
    marketPriceId: number | null
    collateralTransferId: number | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    tradeRatioD18?: boolean
    type?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    lpBaseDeltaToken?: boolean
    lpQuoteDeltaToken?: boolean
    eventId?: boolean
    positionId?: boolean
    marketPriceId?: boolean
    collateralTransferId?: boolean
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    tradeRatioD18?: boolean
    type?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    lpBaseDeltaToken?: boolean
    lpQuoteDeltaToken?: boolean
    eventId?: boolean
    positionId?: boolean
    marketPriceId?: boolean
    collateralTransferId?: boolean
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    tradeRatioD18?: boolean
    type?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    lpBaseDeltaToken?: boolean
    lpQuoteDeltaToken?: boolean
    eventId?: boolean
    positionId?: boolean
    marketPriceId?: boolean
    collateralTransferId?: boolean
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    tradeRatioD18?: boolean
    type?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    borrowedBaseToken?: boolean
    borrowedQuoteToken?: boolean
    collateral?: boolean
    lpBaseDeltaToken?: boolean
    lpQuoteDeltaToken?: boolean
    eventId?: boolean
    positionId?: boolean
    marketPriceId?: boolean
    collateralTransferId?: boolean
  }

  export type transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "tradeRatioD18" | "type" | "baseToken" | "quoteToken" | "borrowedBaseToken" | "borrowedQuoteToken" | "collateral" | "lpBaseDeltaToken" | "lpQuoteDeltaToken" | "eventId" | "positionId" | "marketPriceId" | "collateralTransferId", ExtArgs["result"]["transaction"]>
  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }
  export type transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }
  export type transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collateral_transfer?: boolean | transaction$collateral_transferArgs<ExtArgs>
    market_price?: boolean | transaction$market_priceArgs<ExtArgs>
    event?: boolean | transaction$eventArgs<ExtArgs>
    position?: boolean | transaction$positionArgs<ExtArgs>
  }

  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      collateral_transfer: Prisma.$collateral_transferPayload<ExtArgs> | null
      market_price: Prisma.$market_pricePayload<ExtArgs> | null
      event: Prisma.$eventPayload<ExtArgs> | null
      position: Prisma.$positionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      tradeRatioD18: Prisma.Decimal | null
      type: $Enums.transaction_type_enum
      baseToken: Prisma.Decimal | null
      quoteToken: Prisma.Decimal | null
      borrowedBaseToken: Prisma.Decimal | null
      borrowedQuoteToken: Prisma.Decimal | null
      collateral: Prisma.Decimal
      lpBaseDeltaToken: Prisma.Decimal | null
      lpQuoteDeltaToken: Prisma.Decimal | null
      eventId: number | null
      positionId: number | null
      marketPriceId: number | null
      collateralTransferId: number | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionFindUniqueArgs>(args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionFindFirstArgs>(args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionFindManyArgs>(args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends transactionCreateArgs>(args: SelectSubset<T, transactionCreateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionCreateManyArgs>(args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends transactionDeleteArgs>(args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionUpdateArgs>(args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionDeleteManyArgs>(args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionUpdateManyArgs>(args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends transactionUpsertArgs>(args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collateral_transfer<T extends transaction$collateral_transferArgs<ExtArgs> = {}>(args?: Subset<T, transaction$collateral_transferArgs<ExtArgs>>): Prisma__collateral_transferClient<$Result.GetResult<Prisma.$collateral_transferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    market_price<T extends transaction$market_priceArgs<ExtArgs> = {}>(args?: Subset<T, transaction$market_priceArgs<ExtArgs>>): Prisma__market_priceClient<$Result.GetResult<Prisma.$market_pricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    event<T extends transaction$eventArgs<ExtArgs> = {}>(args?: Subset<T, transaction$eventArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends transaction$positionArgs<ExtArgs> = {}>(args?: Subset<T, transaction$positionArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction model
   */
  interface transactionFieldRefs {
    readonly id: FieldRef<"transaction", 'Int'>
    readonly createdAt: FieldRef<"transaction", 'DateTime'>
    readonly tradeRatioD18: FieldRef<"transaction", 'Decimal'>
    readonly type: FieldRef<"transaction", 'transaction_type_enum'>
    readonly baseToken: FieldRef<"transaction", 'Decimal'>
    readonly quoteToken: FieldRef<"transaction", 'Decimal'>
    readonly borrowedBaseToken: FieldRef<"transaction", 'Decimal'>
    readonly borrowedQuoteToken: FieldRef<"transaction", 'Decimal'>
    readonly collateral: FieldRef<"transaction", 'Decimal'>
    readonly lpBaseDeltaToken: FieldRef<"transaction", 'Decimal'>
    readonly lpQuoteDeltaToken: FieldRef<"transaction", 'Decimal'>
    readonly eventId: FieldRef<"transaction", 'Int'>
    readonly positionId: FieldRef<"transaction", 'Int'>
    readonly marketPriceId: FieldRef<"transaction", 'Int'>
    readonly collateralTransferId: FieldRef<"transaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction createManyAndReturn
   */
  export type transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transaction updateManyAndReturn
   */
  export type transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transaction.collateral_transfer
   */
  export type transaction$collateral_transferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_transfer
     */
    select?: collateral_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_transfer
     */
    omit?: collateral_transferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collateral_transferInclude<ExtArgs> | null
    where?: collateral_transferWhereInput
  }

  /**
   * transaction.market_price
   */
  export type transaction$market_priceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_price
     */
    select?: market_priceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_price
     */
    omit?: market_priceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: market_priceInclude<ExtArgs> | null
    where?: market_priceWhereInput
  }

  /**
   * transaction.event
   */
  export type transaction$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
  }

  /**
   * transaction.position
   */
  export type transaction$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    where?: positionWhereInput
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Cache_candleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    candleType: 'candleType',
    interval: 'interval',
    trailingAvgTime: 'trailingAvgTime',
    resourceSlug: 'resourceSlug',
    marketIdx: 'marketIdx',
    timestamp: 'timestamp',
    open: 'open',
    high: 'high',
    low: 'low',
    close: 'close',
    endTimestamp: 'endTimestamp',
    lastUpdatedTimestamp: 'lastUpdatedTimestamp',
    sumUsed: 'sumUsed',
    sumFeePaid: 'sumFeePaid',
    trailingStartTimestamp: 'trailingStartTimestamp',
    address: 'address',
    chainId: 'chainId',
    marketId: 'marketId'
  };

  export type Cache_candleScalarFieldEnum = (typeof Cache_candleScalarFieldEnum)[keyof typeof Cache_candleScalarFieldEnum]


  export const Cache_paramScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    paramName: 'paramName',
    paramValueNumber: 'paramValueNumber',
    paramValueString: 'paramValueString'
  };

  export type Cache_paramScalarFieldEnum = (typeof Cache_paramScalarFieldEnum)[keyof typeof Cache_paramScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    slug: 'slug'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const Collateral_transferScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    transactionHash: 'transactionHash',
    timestamp: 'timestamp',
    owner: 'owner',
    collateral: 'collateral'
  };

  export type Collateral_transferScalarFieldEnum = (typeof Collateral_transferScalarFieldEnum)[keyof typeof Collateral_transferScalarFieldEnum]


  export const Crypto_pricesScalarFieldEnum: {
    id: 'id',
    ticker: 'ticker',
    price: 'price',
    timestamp: 'timestamp'
  };

  export type Crypto_pricesScalarFieldEnum = (typeof Crypto_pricesScalarFieldEnum)[keyof typeof Crypto_pricesScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    blockNumber: 'blockNumber',
    transactionHash: 'transactionHash',
    timestamp: 'timestamp',
    logIndex: 'logIndex',
    logData: 'logData',
    marketGroupId: 'marketGroupId'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const MarketScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    marketId: 'marketId',
    startTimestamp: 'startTimestamp',
    endTimestamp: 'endTimestamp',
    startingSqrtPriceX96: 'startingSqrtPriceX96',
    settlementPriceD18: 'settlementPriceD18',
    settled: 'settled',
    baseAssetMinPriceTick: 'baseAssetMinPriceTick',
    baseAssetMaxPriceTick: 'baseAssetMaxPriceTick',
    minPriceD18: 'minPriceD18',
    maxPriceD18: 'maxPriceD18',
    marketGroupId: 'marketGroupId',
    marketParamsFeerate: 'marketParamsFeerate',
    marketParamsAssertionliveness: 'marketParamsAssertionliveness',
    marketParamsBondcurrency: 'marketParamsBondcurrency',
    marketParamsBondamount: 'marketParamsBondamount',
    marketParamsClaimstatement: 'marketParamsClaimstatement',
    marketParamsUniswappositionmanager: 'marketParamsUniswappositionmanager',
    marketParamsUniswapswaprouter: 'marketParamsUniswapswaprouter',
    marketParamsUniswapquoter: 'marketParamsUniswapquoter',
    marketParamsOptimisticoraclev3: 'marketParamsOptimisticoraclev3',
    public: 'public',
    question: 'question',
    poolAddress: 'poolAddress',
    optionName: 'optionName',
    rules: 'rules'
  };

  export type MarketScalarFieldEnum = (typeof MarketScalarFieldEnum)[keyof typeof MarketScalarFieldEnum]


  export const Market_groupScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    address: 'address',
    vaultAddress: 'vaultAddress',
    isYin: 'isYin',
    chainId: 'chainId',
    deployTimestamp: 'deployTimestamp',
    deployTxnBlockNumber: 'deployTxnBlockNumber',
    owner: 'owner',
    collateralAsset: 'collateralAsset',
    resourceId: 'resourceId',
    marketParamsFeerate: 'marketParamsFeerate',
    marketParamsAssertionliveness: 'marketParamsAssertionliveness',
    marketParamsBondcurrency: 'marketParamsBondcurrency',
    marketParamsBondamount: 'marketParamsBondamount',
    marketParamsClaimstatement: 'marketParamsClaimstatement',
    marketParamsUniswappositionmanager: 'marketParamsUniswappositionmanager',
    marketParamsUniswapswaprouter: 'marketParamsUniswapswaprouter',
    marketParamsUniswapquoter: 'marketParamsUniswapquoter',
    marketParamsOptimisticoraclev3: 'marketParamsOptimisticoraclev3',
    isCumulative: 'isCumulative',
    categoryId: 'categoryId',
    question: 'question',
    baseTokenName: 'baseTokenName',
    quoteTokenName: 'quoteTokenName',
    collateralDecimals: 'collateralDecimals',
    collateralSymbol: 'collateralSymbol',
    initializationNonce: 'initializationNonce',
    factoryAddress: 'factoryAddress',
    minTradeSize: 'minTradeSize'
  };

  export type Market_groupScalarFieldEnum = (typeof Market_groupScalarFieldEnum)[keyof typeof Market_groupScalarFieldEnum]


  export const Market_priceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    timestamp: 'timestamp',
    value: 'value'
  };

  export type Market_priceScalarFieldEnum = (typeof Market_priceScalarFieldEnum)[keyof typeof Market_priceScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    name: 'name'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    positionId: 'positionId',
    owner: 'owner',
    isLP: 'isLP',
    highPriceTick: 'highPriceTick',
    lowPriceTick: 'lowPriceTick',
    isSettled: 'isSettled',
    lpBaseToken: 'lpBaseToken',
    lpQuoteToken: 'lpQuoteToken',
    baseToken: 'baseToken',
    quoteToken: 'quoteToken',
    borrowedBaseToken: 'borrowedBaseToken',
    borrowedQuoteToken: 'borrowedQuoteToken',
    collateral: 'collateral',
    marketId: 'marketId'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const Render_jobScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    jobId: 'jobId',
    serviceId: 'serviceId'
  };

  export type Render_jobScalarFieldEnum = (typeof Render_jobScalarFieldEnum)[keyof typeof Render_jobScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    slug: 'slug',
    categoryId: 'categoryId'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const Resource_priceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    value: 'value',
    used: 'used',
    feePaid: 'feePaid',
    resourceId: 'resourceId'
  };

  export type Resource_priceScalarFieldEnum = (typeof Resource_priceScalarFieldEnum)[keyof typeof Resource_priceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    tradeRatioD18: 'tradeRatioD18',
    type: 'type',
    baseToken: 'baseToken',
    quoteToken: 'quoteToken',
    borrowedBaseToken: 'borrowedBaseToken',
    borrowedQuoteToken: 'borrowedQuoteToken',
    collateral: 'collateral',
    lpBaseDeltaToken: 'lpBaseDeltaToken',
    lpQuoteDeltaToken: 'lpQuoteDeltaToken',
    eventId: 'eventId',
    positionId: 'positionId',
    marketPriceId: 'marketPriceId',
    collateralTransferId: 'collateralTransferId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'transaction_type_enum'
   */
  export type Enumtransaction_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transaction_type_enum'>
    


  /**
   * Reference to a field of type 'transaction_type_enum[]'
   */
  export type ListEnumtransaction_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transaction_type_enum[]'>
    
  /**
   * Deep Input Types
   */


  export type cache_candleWhereInput = {
    AND?: cache_candleWhereInput | cache_candleWhereInput[]
    OR?: cache_candleWhereInput[]
    NOT?: cache_candleWhereInput | cache_candleWhereInput[]
    id?: IntFilter<"cache_candle"> | number
    createdAt?: DateTimeFilter<"cache_candle"> | Date | string
    candleType?: StringFilter<"cache_candle"> | string
    interval?: IntFilter<"cache_candle"> | number
    trailingAvgTime?: IntNullableFilter<"cache_candle"> | number | null
    resourceSlug?: StringNullableFilter<"cache_candle"> | string | null
    marketIdx?: IntNullableFilter<"cache_candle"> | number | null
    timestamp?: IntFilter<"cache_candle"> | number
    open?: StringFilter<"cache_candle"> | string
    high?: StringFilter<"cache_candle"> | string
    low?: StringFilter<"cache_candle"> | string
    close?: StringFilter<"cache_candle"> | string
    endTimestamp?: IntFilter<"cache_candle"> | number
    lastUpdatedTimestamp?: IntFilter<"cache_candle"> | number
    sumUsed?: DecimalNullableFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: DecimalNullableFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: IntNullableFilter<"cache_candle"> | number | null
    address?: StringNullableFilter<"cache_candle"> | string | null
    chainId?: IntNullableFilter<"cache_candle"> | number | null
    marketId?: IntNullableFilter<"cache_candle"> | number | null
  }

  export type cache_candleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    candleType?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrderInput | SortOrder
    resourceSlug?: SortOrderInput | SortOrder
    marketIdx?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrderInput | SortOrder
    sumFeePaid?: SortOrderInput | SortOrder
    trailingStartTimestamp?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    chainId?: SortOrderInput | SortOrder
    marketId?: SortOrderInput | SortOrder
  }

  export type cache_candleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    candleType_interval_timestamp_resourceSlug_marketIdx_trailingAvgTime?: cache_candleCandleTypeIntervalTimestampResourceSlugMarketIdxTrailingAvgTimeCompoundUniqueInput
    AND?: cache_candleWhereInput | cache_candleWhereInput[]
    OR?: cache_candleWhereInput[]
    NOT?: cache_candleWhereInput | cache_candleWhereInput[]
    createdAt?: DateTimeFilter<"cache_candle"> | Date | string
    candleType?: StringFilter<"cache_candle"> | string
    interval?: IntFilter<"cache_candle"> | number
    trailingAvgTime?: IntNullableFilter<"cache_candle"> | number | null
    resourceSlug?: StringNullableFilter<"cache_candle"> | string | null
    marketIdx?: IntNullableFilter<"cache_candle"> | number | null
    timestamp?: IntFilter<"cache_candle"> | number
    open?: StringFilter<"cache_candle"> | string
    high?: StringFilter<"cache_candle"> | string
    low?: StringFilter<"cache_candle"> | string
    close?: StringFilter<"cache_candle"> | string
    endTimestamp?: IntFilter<"cache_candle"> | number
    lastUpdatedTimestamp?: IntFilter<"cache_candle"> | number
    sumUsed?: DecimalNullableFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: DecimalNullableFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: IntNullableFilter<"cache_candle"> | number | null
    address?: StringNullableFilter<"cache_candle"> | string | null
    chainId?: IntNullableFilter<"cache_candle"> | number | null
    marketId?: IntNullableFilter<"cache_candle"> | number | null
  }, "id" | "candleType_interval_timestamp_resourceSlug_marketIdx_trailingAvgTime">

  export type cache_candleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    candleType?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrderInput | SortOrder
    resourceSlug?: SortOrderInput | SortOrder
    marketIdx?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrderInput | SortOrder
    sumFeePaid?: SortOrderInput | SortOrder
    trailingStartTimestamp?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    chainId?: SortOrderInput | SortOrder
    marketId?: SortOrderInput | SortOrder
    _count?: cache_candleCountOrderByAggregateInput
    _avg?: cache_candleAvgOrderByAggregateInput
    _max?: cache_candleMaxOrderByAggregateInput
    _min?: cache_candleMinOrderByAggregateInput
    _sum?: cache_candleSumOrderByAggregateInput
  }

  export type cache_candleScalarWhereWithAggregatesInput = {
    AND?: cache_candleScalarWhereWithAggregatesInput | cache_candleScalarWhereWithAggregatesInput[]
    OR?: cache_candleScalarWhereWithAggregatesInput[]
    NOT?: cache_candleScalarWhereWithAggregatesInput | cache_candleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cache_candle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"cache_candle"> | Date | string
    candleType?: StringWithAggregatesFilter<"cache_candle"> | string
    interval?: IntWithAggregatesFilter<"cache_candle"> | number
    trailingAvgTime?: IntNullableWithAggregatesFilter<"cache_candle"> | number | null
    resourceSlug?: StringNullableWithAggregatesFilter<"cache_candle"> | string | null
    marketIdx?: IntNullableWithAggregatesFilter<"cache_candle"> | number | null
    timestamp?: IntWithAggregatesFilter<"cache_candle"> | number
    open?: StringWithAggregatesFilter<"cache_candle"> | string
    high?: StringWithAggregatesFilter<"cache_candle"> | string
    low?: StringWithAggregatesFilter<"cache_candle"> | string
    close?: StringWithAggregatesFilter<"cache_candle"> | string
    endTimestamp?: IntWithAggregatesFilter<"cache_candle"> | number
    lastUpdatedTimestamp?: IntWithAggregatesFilter<"cache_candle"> | number
    sumUsed?: DecimalNullableWithAggregatesFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: DecimalNullableWithAggregatesFilter<"cache_candle"> | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: IntNullableWithAggregatesFilter<"cache_candle"> | number | null
    address?: StringNullableWithAggregatesFilter<"cache_candle"> | string | null
    chainId?: IntNullableWithAggregatesFilter<"cache_candle"> | number | null
    marketId?: IntNullableWithAggregatesFilter<"cache_candle"> | number | null
  }

  export type cache_paramWhereInput = {
    AND?: cache_paramWhereInput | cache_paramWhereInput[]
    OR?: cache_paramWhereInput[]
    NOT?: cache_paramWhereInput | cache_paramWhereInput[]
    id?: IntFilter<"cache_param"> | number
    createdAt?: DateTimeFilter<"cache_param"> | Date | string
    paramName?: StringFilter<"cache_param"> | string
    paramValueNumber?: DecimalFilter<"cache_param"> | Decimal | DecimalJsLike | number | string
    paramValueString?: StringNullableFilter<"cache_param"> | string | null
  }

  export type cache_paramOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    paramName?: SortOrder
    paramValueNumber?: SortOrder
    paramValueString?: SortOrderInput | SortOrder
  }

  export type cache_paramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    paramName?: string
    AND?: cache_paramWhereInput | cache_paramWhereInput[]
    OR?: cache_paramWhereInput[]
    NOT?: cache_paramWhereInput | cache_paramWhereInput[]
    createdAt?: DateTimeFilter<"cache_param"> | Date | string
    paramValueNumber?: DecimalFilter<"cache_param"> | Decimal | DecimalJsLike | number | string
    paramValueString?: StringNullableFilter<"cache_param"> | string | null
  }, "id" | "paramName">

  export type cache_paramOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    paramName?: SortOrder
    paramValueNumber?: SortOrder
    paramValueString?: SortOrderInput | SortOrder
    _count?: cache_paramCountOrderByAggregateInput
    _avg?: cache_paramAvgOrderByAggregateInput
    _max?: cache_paramMaxOrderByAggregateInput
    _min?: cache_paramMinOrderByAggregateInput
    _sum?: cache_paramSumOrderByAggregateInput
  }

  export type cache_paramScalarWhereWithAggregatesInput = {
    AND?: cache_paramScalarWhereWithAggregatesInput | cache_paramScalarWhereWithAggregatesInput[]
    OR?: cache_paramScalarWhereWithAggregatesInput[]
    NOT?: cache_paramScalarWhereWithAggregatesInput | cache_paramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cache_param"> | number
    createdAt?: DateTimeWithAggregatesFilter<"cache_param"> | Date | string
    paramName?: StringWithAggregatesFilter<"cache_param"> | string
    paramValueNumber?: DecimalWithAggregatesFilter<"cache_param"> | Decimal | DecimalJsLike | number | string
    paramValueString?: StringNullableWithAggregatesFilter<"cache_param"> | string | null
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    createdAt?: DateTimeFilter<"category"> | Date | string
    name?: StringFilter<"category"> | string
    slug?: StringFilter<"category"> | string
    market_group?: Market_groupListRelationFilter
    resource?: ResourceListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    market_group?: market_groupOrderByRelationAggregateInput
    resource?: resourceOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    createdAt?: DateTimeFilter<"category"> | Date | string
    market_group?: Market_groupListRelationFilter
    resource?: ResourceListRelationFilter
  }, "id" | "name" | "slug">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"category"> | Date | string
    name?: StringWithAggregatesFilter<"category"> | string
    slug?: StringWithAggregatesFilter<"category"> | string
  }

  export type collateral_transferWhereInput = {
    AND?: collateral_transferWhereInput | collateral_transferWhereInput[]
    OR?: collateral_transferWhereInput[]
    NOT?: collateral_transferWhereInput | collateral_transferWhereInput[]
    id?: IntFilter<"collateral_transfer"> | number
    createdAt?: DateTimeFilter<"collateral_transfer"> | Date | string
    transactionHash?: StringFilter<"collateral_transfer"> | string
    timestamp?: IntFilter<"collateral_transfer"> | number
    owner?: StringFilter<"collateral_transfer"> | string
    collateral?: DecimalFilter<"collateral_transfer"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }

  export type collateral_transferOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    owner?: SortOrder
    collateral?: SortOrder
    transaction?: transactionOrderByWithRelationInput
  }

  export type collateral_transferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionHash?: string
    AND?: collateral_transferWhereInput | collateral_transferWhereInput[]
    OR?: collateral_transferWhereInput[]
    NOT?: collateral_transferWhereInput | collateral_transferWhereInput[]
    createdAt?: DateTimeFilter<"collateral_transfer"> | Date | string
    timestamp?: IntFilter<"collateral_transfer"> | number
    owner?: StringFilter<"collateral_transfer"> | string
    collateral?: DecimalFilter<"collateral_transfer"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }, "id" | "transactionHash">

  export type collateral_transferOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    owner?: SortOrder
    collateral?: SortOrder
    _count?: collateral_transferCountOrderByAggregateInput
    _avg?: collateral_transferAvgOrderByAggregateInput
    _max?: collateral_transferMaxOrderByAggregateInput
    _min?: collateral_transferMinOrderByAggregateInput
    _sum?: collateral_transferSumOrderByAggregateInput
  }

  export type collateral_transferScalarWhereWithAggregatesInput = {
    AND?: collateral_transferScalarWhereWithAggregatesInput | collateral_transferScalarWhereWithAggregatesInput[]
    OR?: collateral_transferScalarWhereWithAggregatesInput[]
    NOT?: collateral_transferScalarWhereWithAggregatesInput | collateral_transferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collateral_transfer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"collateral_transfer"> | Date | string
    transactionHash?: StringWithAggregatesFilter<"collateral_transfer"> | string
    timestamp?: IntWithAggregatesFilter<"collateral_transfer"> | number
    owner?: StringWithAggregatesFilter<"collateral_transfer"> | string
    collateral?: DecimalWithAggregatesFilter<"collateral_transfer"> | Decimal | DecimalJsLike | number | string
  }

  export type crypto_pricesWhereInput = {
    AND?: crypto_pricesWhereInput | crypto_pricesWhereInput[]
    OR?: crypto_pricesWhereInput[]
    NOT?: crypto_pricesWhereInput | crypto_pricesWhereInput[]
    id?: IntFilter<"crypto_prices"> | number
    ticker?: StringNullableFilter<"crypto_prices"> | string | null
    price?: FloatFilter<"crypto_prices"> | number
    timestamp?: DateTimeFilter<"crypto_prices"> | Date | string
  }

  export type crypto_pricesOrderByWithRelationInput = {
    id?: SortOrder
    ticker?: SortOrderInput | SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type crypto_pricesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: crypto_pricesWhereInput | crypto_pricesWhereInput[]
    OR?: crypto_pricesWhereInput[]
    NOT?: crypto_pricesWhereInput | crypto_pricesWhereInput[]
    ticker?: StringNullableFilter<"crypto_prices"> | string | null
    price?: FloatFilter<"crypto_prices"> | number
    timestamp?: DateTimeFilter<"crypto_prices"> | Date | string
  }, "id">

  export type crypto_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    ticker?: SortOrderInput | SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    _count?: crypto_pricesCountOrderByAggregateInput
    _avg?: crypto_pricesAvgOrderByAggregateInput
    _max?: crypto_pricesMaxOrderByAggregateInput
    _min?: crypto_pricesMinOrderByAggregateInput
    _sum?: crypto_pricesSumOrderByAggregateInput
  }

  export type crypto_pricesScalarWhereWithAggregatesInput = {
    AND?: crypto_pricesScalarWhereWithAggregatesInput | crypto_pricesScalarWhereWithAggregatesInput[]
    OR?: crypto_pricesScalarWhereWithAggregatesInput[]
    NOT?: crypto_pricesScalarWhereWithAggregatesInput | crypto_pricesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"crypto_prices"> | number
    ticker?: StringNullableWithAggregatesFilter<"crypto_prices"> | string | null
    price?: FloatWithAggregatesFilter<"crypto_prices"> | number
    timestamp?: DateTimeWithAggregatesFilter<"crypto_prices"> | Date | string
  }

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    id?: IntFilter<"event"> | number
    createdAt?: DateTimeFilter<"event"> | Date | string
    blockNumber?: IntFilter<"event"> | number
    transactionHash?: StringFilter<"event"> | string
    timestamp?: BigIntFilter<"event"> | bigint | number
    logIndex?: IntFilter<"event"> | number
    logData?: JsonFilter<"event">
    marketGroupId?: IntNullableFilter<"event"> | number | null
    market_group?: XOR<Market_groupNullableScalarRelationFilter, market_groupWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }

  export type eventOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    logData?: SortOrder
    marketGroupId?: SortOrderInput | SortOrder
    market_group?: market_groupOrderByWithRelationInput
    transaction?: transactionOrderByWithRelationInput
  }

  export type eventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionHash_marketGroupId_blockNumber_logIndex?: eventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    createdAt?: DateTimeFilter<"event"> | Date | string
    blockNumber?: IntFilter<"event"> | number
    transactionHash?: StringFilter<"event"> | string
    timestamp?: BigIntFilter<"event"> | bigint | number
    logIndex?: IntFilter<"event"> | number
    logData?: JsonFilter<"event">
    marketGroupId?: IntNullableFilter<"event"> | number | null
    market_group?: XOR<Market_groupNullableScalarRelationFilter, market_groupWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }, "id" | "transactionHash_marketGroupId_blockNumber_logIndex">

  export type eventOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    logData?: SortOrder
    marketGroupId?: SortOrderInput | SortOrder
    _count?: eventCountOrderByAggregateInput
    _avg?: eventAvgOrderByAggregateInput
    _max?: eventMaxOrderByAggregateInput
    _min?: eventMinOrderByAggregateInput
    _sum?: eventSumOrderByAggregateInput
  }

  export type eventScalarWhereWithAggregatesInput = {
    AND?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    OR?: eventScalarWhereWithAggregatesInput[]
    NOT?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"event"> | number
    createdAt?: DateTimeWithAggregatesFilter<"event"> | Date | string
    blockNumber?: IntWithAggregatesFilter<"event"> | number
    transactionHash?: StringWithAggregatesFilter<"event"> | string
    timestamp?: BigIntWithAggregatesFilter<"event"> | bigint | number
    logIndex?: IntWithAggregatesFilter<"event"> | number
    logData?: JsonWithAggregatesFilter<"event">
    marketGroupId?: IntNullableWithAggregatesFilter<"event"> | number | null
  }

  export type marketWhereInput = {
    AND?: marketWhereInput | marketWhereInput[]
    OR?: marketWhereInput[]
    NOT?: marketWhereInput | marketWhereInput[]
    id?: IntFilter<"market"> | number
    createdAt?: DateTimeFilter<"market"> | Date | string
    marketId?: IntFilter<"market"> | number
    startTimestamp?: IntNullableFilter<"market"> | number | null
    endTimestamp?: IntNullableFilter<"market"> | number | null
    startingSqrtPriceX96?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settled?: BoolNullableFilter<"market"> | boolean | null
    baseAssetMinPriceTick?: IntNullableFilter<"market"> | number | null
    baseAssetMaxPriceTick?: IntNullableFilter<"market"> | number | null
    minPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: IntNullableFilter<"market"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market"> | string | null
    public?: BoolFilter<"market"> | boolean
    question?: StringNullableFilter<"market"> | string | null
    poolAddress?: StringNullableFilter<"market"> | string | null
    optionName?: StringNullableFilter<"market"> | string | null
    rules?: StringNullableFilter<"market"> | string | null
    market_group?: XOR<Market_groupNullableScalarRelationFilter, market_groupWhereInput> | null
    position?: PositionListRelationFilter
  }

  export type marketOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrderInput | SortOrder
    endTimestamp?: SortOrderInput | SortOrder
    startingSqrtPriceX96?: SortOrderInput | SortOrder
    settlementPriceD18?: SortOrderInput | SortOrder
    settled?: SortOrderInput | SortOrder
    baseAssetMinPriceTick?: SortOrderInput | SortOrder
    baseAssetMaxPriceTick?: SortOrderInput | SortOrder
    minPriceD18?: SortOrderInput | SortOrder
    maxPriceD18?: SortOrderInput | SortOrder
    marketGroupId?: SortOrderInput | SortOrder
    marketParamsFeerate?: SortOrderInput | SortOrder
    marketParamsAssertionliveness?: SortOrderInput | SortOrder
    marketParamsBondcurrency?: SortOrderInput | SortOrder
    marketParamsBondamount?: SortOrderInput | SortOrder
    marketParamsClaimstatement?: SortOrderInput | SortOrder
    marketParamsUniswappositionmanager?: SortOrderInput | SortOrder
    marketParamsUniswapswaprouter?: SortOrderInput | SortOrder
    marketParamsUniswapquoter?: SortOrderInput | SortOrder
    marketParamsOptimisticoraclev3?: SortOrderInput | SortOrder
    public?: SortOrder
    question?: SortOrderInput | SortOrder
    poolAddress?: SortOrderInput | SortOrder
    optionName?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    market_group?: market_groupOrderByWithRelationInput
    position?: positionOrderByRelationAggregateInput
  }

  export type marketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    marketGroupId_marketId?: marketMarketGroupIdMarketIdCompoundUniqueInput
    AND?: marketWhereInput | marketWhereInput[]
    OR?: marketWhereInput[]
    NOT?: marketWhereInput | marketWhereInput[]
    createdAt?: DateTimeFilter<"market"> | Date | string
    marketId?: IntFilter<"market"> | number
    startTimestamp?: IntNullableFilter<"market"> | number | null
    endTimestamp?: IntNullableFilter<"market"> | number | null
    startingSqrtPriceX96?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settled?: BoolNullableFilter<"market"> | boolean | null
    baseAssetMinPriceTick?: IntNullableFilter<"market"> | number | null
    baseAssetMaxPriceTick?: IntNullableFilter<"market"> | number | null
    minPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: IntNullableFilter<"market"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market"> | string | null
    public?: BoolFilter<"market"> | boolean
    question?: StringNullableFilter<"market"> | string | null
    poolAddress?: StringNullableFilter<"market"> | string | null
    optionName?: StringNullableFilter<"market"> | string | null
    rules?: StringNullableFilter<"market"> | string | null
    market_group?: XOR<Market_groupNullableScalarRelationFilter, market_groupWhereInput> | null
    position?: PositionListRelationFilter
  }, "id" | "marketGroupId_marketId" | "marketGroupId_marketId">

  export type marketOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrderInput | SortOrder
    endTimestamp?: SortOrderInput | SortOrder
    startingSqrtPriceX96?: SortOrderInput | SortOrder
    settlementPriceD18?: SortOrderInput | SortOrder
    settled?: SortOrderInput | SortOrder
    baseAssetMinPriceTick?: SortOrderInput | SortOrder
    baseAssetMaxPriceTick?: SortOrderInput | SortOrder
    minPriceD18?: SortOrderInput | SortOrder
    maxPriceD18?: SortOrderInput | SortOrder
    marketGroupId?: SortOrderInput | SortOrder
    marketParamsFeerate?: SortOrderInput | SortOrder
    marketParamsAssertionliveness?: SortOrderInput | SortOrder
    marketParamsBondcurrency?: SortOrderInput | SortOrder
    marketParamsBondamount?: SortOrderInput | SortOrder
    marketParamsClaimstatement?: SortOrderInput | SortOrder
    marketParamsUniswappositionmanager?: SortOrderInput | SortOrder
    marketParamsUniswapswaprouter?: SortOrderInput | SortOrder
    marketParamsUniswapquoter?: SortOrderInput | SortOrder
    marketParamsOptimisticoraclev3?: SortOrderInput | SortOrder
    public?: SortOrder
    question?: SortOrderInput | SortOrder
    poolAddress?: SortOrderInput | SortOrder
    optionName?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    _count?: marketCountOrderByAggregateInput
    _avg?: marketAvgOrderByAggregateInput
    _max?: marketMaxOrderByAggregateInput
    _min?: marketMinOrderByAggregateInput
    _sum?: marketSumOrderByAggregateInput
  }

  export type marketScalarWhereWithAggregatesInput = {
    AND?: marketScalarWhereWithAggregatesInput | marketScalarWhereWithAggregatesInput[]
    OR?: marketScalarWhereWithAggregatesInput[]
    NOT?: marketScalarWhereWithAggregatesInput | marketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"market"> | number
    createdAt?: DateTimeWithAggregatesFilter<"market"> | Date | string
    marketId?: IntWithAggregatesFilter<"market"> | number
    startTimestamp?: IntNullableWithAggregatesFilter<"market"> | number | null
    endTimestamp?: IntNullableWithAggregatesFilter<"market"> | number | null
    startingSqrtPriceX96?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settled?: BoolNullableWithAggregatesFilter<"market"> | boolean | null
    baseAssetMinPriceTick?: IntNullableWithAggregatesFilter<"market"> | number | null
    baseAssetMaxPriceTick?: IntNullableWithAggregatesFilter<"market"> | number | null
    minPriceD18?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: IntNullableWithAggregatesFilter<"market"> | number | null
    marketParamsFeerate?: IntNullableWithAggregatesFilter<"market"> | number | null
    marketParamsAssertionliveness?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableWithAggregatesFilter<"market"> | string | null
    marketParamsBondamount?: DecimalNullableWithAggregatesFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableWithAggregatesFilter<"market"> | string | null
    marketParamsUniswappositionmanager?: StringNullableWithAggregatesFilter<"market"> | string | null
    marketParamsUniswapswaprouter?: StringNullableWithAggregatesFilter<"market"> | string | null
    marketParamsUniswapquoter?: StringNullableWithAggregatesFilter<"market"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableWithAggregatesFilter<"market"> | string | null
    public?: BoolWithAggregatesFilter<"market"> | boolean
    question?: StringNullableWithAggregatesFilter<"market"> | string | null
    poolAddress?: StringNullableWithAggregatesFilter<"market"> | string | null
    optionName?: StringNullableWithAggregatesFilter<"market"> | string | null
    rules?: StringNullableWithAggregatesFilter<"market"> | string | null
  }

  export type market_groupWhereInput = {
    AND?: market_groupWhereInput | market_groupWhereInput[]
    OR?: market_groupWhereInput[]
    NOT?: market_groupWhereInput | market_groupWhereInput[]
    id?: IntFilter<"market_group"> | number
    createdAt?: DateTimeFilter<"market_group"> | Date | string
    address?: StringNullableFilter<"market_group"> | string | null
    vaultAddress?: StringNullableFilter<"market_group"> | string | null
    isYin?: BoolFilter<"market_group"> | boolean
    chainId?: IntFilter<"market_group"> | number
    deployTimestamp?: IntNullableFilter<"market_group"> | number | null
    deployTxnBlockNumber?: IntNullableFilter<"market_group"> | number | null
    owner?: StringNullableFilter<"market_group"> | string | null
    collateralAsset?: StringNullableFilter<"market_group"> | string | null
    resourceId?: IntNullableFilter<"market_group"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market_group"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market_group"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market_group"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market_group"> | string | null
    isCumulative?: BoolFilter<"market_group"> | boolean
    categoryId?: IntNullableFilter<"market_group"> | number | null
    question?: StringNullableFilter<"market_group"> | string | null
    baseTokenName?: StringNullableFilter<"market_group"> | string | null
    quoteTokenName?: StringNullableFilter<"market_group"> | string | null
    collateralDecimals?: IntNullableFilter<"market_group"> | number | null
    collateralSymbol?: StringNullableFilter<"market_group"> | string | null
    initializationNonce?: StringNullableFilter<"market_group"> | string | null
    factoryAddress?: StringNullableFilter<"market_group"> | string | null
    minTradeSize?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    event?: EventListRelationFilter
    market?: MarketListRelationFilter
    resource?: XOR<ResourceNullableScalarRelationFilter, resourceWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
  }

  export type market_groupOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    address?: SortOrderInput | SortOrder
    vaultAddress?: SortOrderInput | SortOrder
    isYin?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrderInput | SortOrder
    deployTxnBlockNumber?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    collateralAsset?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    marketParamsFeerate?: SortOrderInput | SortOrder
    marketParamsAssertionliveness?: SortOrderInput | SortOrder
    marketParamsBondcurrency?: SortOrderInput | SortOrder
    marketParamsBondamount?: SortOrderInput | SortOrder
    marketParamsClaimstatement?: SortOrderInput | SortOrder
    marketParamsUniswappositionmanager?: SortOrderInput | SortOrder
    marketParamsUniswapswaprouter?: SortOrderInput | SortOrder
    marketParamsUniswapquoter?: SortOrderInput | SortOrder
    marketParamsOptimisticoraclev3?: SortOrderInput | SortOrder
    isCumulative?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    question?: SortOrderInput | SortOrder
    baseTokenName?: SortOrderInput | SortOrder
    quoteTokenName?: SortOrderInput | SortOrder
    collateralDecimals?: SortOrderInput | SortOrder
    collateralSymbol?: SortOrderInput | SortOrder
    initializationNonce?: SortOrderInput | SortOrder
    factoryAddress?: SortOrderInput | SortOrder
    minTradeSize?: SortOrderInput | SortOrder
    event?: eventOrderByRelationAggregateInput
    market?: marketOrderByRelationAggregateInput
    resource?: resourceOrderByWithRelationInput
    category?: categoryOrderByWithRelationInput
  }

  export type market_groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    address_chainId?: market_groupAddressChainIdCompoundUniqueInput
    AND?: market_groupWhereInput | market_groupWhereInput[]
    OR?: market_groupWhereInput[]
    NOT?: market_groupWhereInput | market_groupWhereInput[]
    createdAt?: DateTimeFilter<"market_group"> | Date | string
    address?: StringNullableFilter<"market_group"> | string | null
    vaultAddress?: StringNullableFilter<"market_group"> | string | null
    isYin?: BoolFilter<"market_group"> | boolean
    chainId?: IntFilter<"market_group"> | number
    deployTimestamp?: IntNullableFilter<"market_group"> | number | null
    deployTxnBlockNumber?: IntNullableFilter<"market_group"> | number | null
    owner?: StringNullableFilter<"market_group"> | string | null
    collateralAsset?: StringNullableFilter<"market_group"> | string | null
    resourceId?: IntNullableFilter<"market_group"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market_group"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market_group"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market_group"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market_group"> | string | null
    isCumulative?: BoolFilter<"market_group"> | boolean
    categoryId?: IntNullableFilter<"market_group"> | number | null
    question?: StringNullableFilter<"market_group"> | string | null
    baseTokenName?: StringNullableFilter<"market_group"> | string | null
    quoteTokenName?: StringNullableFilter<"market_group"> | string | null
    collateralDecimals?: IntNullableFilter<"market_group"> | number | null
    collateralSymbol?: StringNullableFilter<"market_group"> | string | null
    initializationNonce?: StringNullableFilter<"market_group"> | string | null
    factoryAddress?: StringNullableFilter<"market_group"> | string | null
    minTradeSize?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    event?: EventListRelationFilter
    market?: MarketListRelationFilter
    resource?: XOR<ResourceNullableScalarRelationFilter, resourceWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
  }, "id" | "address_chainId">

  export type market_groupOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    address?: SortOrderInput | SortOrder
    vaultAddress?: SortOrderInput | SortOrder
    isYin?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrderInput | SortOrder
    deployTxnBlockNumber?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    collateralAsset?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    marketParamsFeerate?: SortOrderInput | SortOrder
    marketParamsAssertionliveness?: SortOrderInput | SortOrder
    marketParamsBondcurrency?: SortOrderInput | SortOrder
    marketParamsBondamount?: SortOrderInput | SortOrder
    marketParamsClaimstatement?: SortOrderInput | SortOrder
    marketParamsUniswappositionmanager?: SortOrderInput | SortOrder
    marketParamsUniswapswaprouter?: SortOrderInput | SortOrder
    marketParamsUniswapquoter?: SortOrderInput | SortOrder
    marketParamsOptimisticoraclev3?: SortOrderInput | SortOrder
    isCumulative?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    question?: SortOrderInput | SortOrder
    baseTokenName?: SortOrderInput | SortOrder
    quoteTokenName?: SortOrderInput | SortOrder
    collateralDecimals?: SortOrderInput | SortOrder
    collateralSymbol?: SortOrderInput | SortOrder
    initializationNonce?: SortOrderInput | SortOrder
    factoryAddress?: SortOrderInput | SortOrder
    minTradeSize?: SortOrderInput | SortOrder
    _count?: market_groupCountOrderByAggregateInput
    _avg?: market_groupAvgOrderByAggregateInput
    _max?: market_groupMaxOrderByAggregateInput
    _min?: market_groupMinOrderByAggregateInput
    _sum?: market_groupSumOrderByAggregateInput
  }

  export type market_groupScalarWhereWithAggregatesInput = {
    AND?: market_groupScalarWhereWithAggregatesInput | market_groupScalarWhereWithAggregatesInput[]
    OR?: market_groupScalarWhereWithAggregatesInput[]
    NOT?: market_groupScalarWhereWithAggregatesInput | market_groupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"market_group"> | number
    createdAt?: DateTimeWithAggregatesFilter<"market_group"> | Date | string
    address?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    vaultAddress?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    isYin?: BoolWithAggregatesFilter<"market_group"> | boolean
    chainId?: IntWithAggregatesFilter<"market_group"> | number
    deployTimestamp?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    deployTxnBlockNumber?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    owner?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    collateralAsset?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    resourceId?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    marketParamsFeerate?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    marketParamsAssertionliveness?: DecimalNullableWithAggregatesFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    marketParamsBondamount?: DecimalNullableWithAggregatesFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    marketParamsUniswappositionmanager?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    marketParamsUniswapswaprouter?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    marketParamsUniswapquoter?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    isCumulative?: BoolWithAggregatesFilter<"market_group"> | boolean
    categoryId?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    question?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    baseTokenName?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    quoteTokenName?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    collateralDecimals?: IntNullableWithAggregatesFilter<"market_group"> | number | null
    collateralSymbol?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    initializationNonce?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    factoryAddress?: StringNullableWithAggregatesFilter<"market_group"> | string | null
    minTradeSize?: DecimalNullableWithAggregatesFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
  }

  export type market_priceWhereInput = {
    AND?: market_priceWhereInput | market_priceWhereInput[]
    OR?: market_priceWhereInput[]
    NOT?: market_priceWhereInput | market_priceWhereInput[]
    id?: IntFilter<"market_price"> | number
    createdAt?: DateTimeFilter<"market_price"> | Date | string
    timestamp?: BigIntFilter<"market_price"> | bigint | number
    value?: DecimalFilter<"market_price"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }

  export type market_priceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    transaction?: transactionOrderByWithRelationInput
  }

  export type market_priceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: market_priceWhereInput | market_priceWhereInput[]
    OR?: market_priceWhereInput[]
    NOT?: market_priceWhereInput | market_priceWhereInput[]
    createdAt?: DateTimeFilter<"market_price"> | Date | string
    timestamp?: BigIntFilter<"market_price"> | bigint | number
    value?: DecimalFilter<"market_price"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, transactionWhereInput> | null
  }, "id">

  export type market_priceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    _count?: market_priceCountOrderByAggregateInput
    _avg?: market_priceAvgOrderByAggregateInput
    _max?: market_priceMaxOrderByAggregateInput
    _min?: market_priceMinOrderByAggregateInput
    _sum?: market_priceSumOrderByAggregateInput
  }

  export type market_priceScalarWhereWithAggregatesInput = {
    AND?: market_priceScalarWhereWithAggregatesInput | market_priceScalarWhereWithAggregatesInput[]
    OR?: market_priceScalarWhereWithAggregatesInput[]
    NOT?: market_priceScalarWhereWithAggregatesInput | market_priceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"market_price"> | number
    createdAt?: DateTimeWithAggregatesFilter<"market_price"> | Date | string
    timestamp?: BigIntWithAggregatesFilter<"market_price"> | bigint | number
    value?: DecimalWithAggregatesFilter<"market_price"> | Decimal | DecimalJsLike | number | string
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    timestamp?: BigIntFilter<"migrations"> | bigint | number
    name?: StringFilter<"migrations"> | string
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    timestamp?: BigIntFilter<"migrations"> | bigint | number
    name?: StringFilter<"migrations"> | string
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    timestamp?: BigIntWithAggregatesFilter<"migrations"> | bigint | number
    name?: StringWithAggregatesFilter<"migrations"> | string
  }

  export type positionWhereInput = {
    AND?: positionWhereInput | positionWhereInput[]
    OR?: positionWhereInput[]
    NOT?: positionWhereInput | positionWhereInput[]
    id?: IntFilter<"position"> | number
    createdAt?: DateTimeFilter<"position"> | Date | string
    positionId?: IntFilter<"position"> | number
    owner?: StringNullableFilter<"position"> | string | null
    isLP?: BoolFilter<"position"> | boolean
    highPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    isSettled?: BoolNullableFilter<"position"> | boolean | null
    lpBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    baseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"position"> | Decimal | DecimalJsLike | number | string
    marketId?: IntNullableFilter<"position"> | number | null
    market?: XOR<MarketNullableScalarRelationFilter, marketWhereInput> | null
    transaction?: TransactionListRelationFilter
  }

  export type positionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    positionId?: SortOrder
    owner?: SortOrderInput | SortOrder
    isLP?: SortOrder
    highPriceTick?: SortOrderInput | SortOrder
    lowPriceTick?: SortOrderInput | SortOrder
    isSettled?: SortOrderInput | SortOrder
    lpBaseToken?: SortOrderInput | SortOrder
    lpQuoteToken?: SortOrderInput | SortOrder
    baseToken?: SortOrderInput | SortOrder
    quoteToken?: SortOrderInput | SortOrder
    borrowedBaseToken?: SortOrderInput | SortOrder
    borrowedQuoteToken?: SortOrderInput | SortOrder
    collateral?: SortOrder
    marketId?: SortOrderInput | SortOrder
    market?: marketOrderByWithRelationInput
    transaction?: transactionOrderByRelationAggregateInput
  }

  export type positionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    positionId_marketId?: positionPositionIdMarketIdCompoundUniqueInput
    AND?: positionWhereInput | positionWhereInput[]
    OR?: positionWhereInput[]
    NOT?: positionWhereInput | positionWhereInput[]
    createdAt?: DateTimeFilter<"position"> | Date | string
    positionId?: IntFilter<"position"> | number
    owner?: StringNullableFilter<"position"> | string | null
    isLP?: BoolFilter<"position"> | boolean
    highPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    isSettled?: BoolNullableFilter<"position"> | boolean | null
    lpBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    baseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"position"> | Decimal | DecimalJsLike | number | string
    marketId?: IntNullableFilter<"position"> | number | null
    market?: XOR<MarketNullableScalarRelationFilter, marketWhereInput> | null
    transaction?: TransactionListRelationFilter
  }, "id" | "positionId_marketId">

  export type positionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    positionId?: SortOrder
    owner?: SortOrderInput | SortOrder
    isLP?: SortOrder
    highPriceTick?: SortOrderInput | SortOrder
    lowPriceTick?: SortOrderInput | SortOrder
    isSettled?: SortOrderInput | SortOrder
    lpBaseToken?: SortOrderInput | SortOrder
    lpQuoteToken?: SortOrderInput | SortOrder
    baseToken?: SortOrderInput | SortOrder
    quoteToken?: SortOrderInput | SortOrder
    borrowedBaseToken?: SortOrderInput | SortOrder
    borrowedQuoteToken?: SortOrderInput | SortOrder
    collateral?: SortOrder
    marketId?: SortOrderInput | SortOrder
    _count?: positionCountOrderByAggregateInput
    _avg?: positionAvgOrderByAggregateInput
    _max?: positionMaxOrderByAggregateInput
    _min?: positionMinOrderByAggregateInput
    _sum?: positionSumOrderByAggregateInput
  }

  export type positionScalarWhereWithAggregatesInput = {
    AND?: positionScalarWhereWithAggregatesInput | positionScalarWhereWithAggregatesInput[]
    OR?: positionScalarWhereWithAggregatesInput[]
    NOT?: positionScalarWhereWithAggregatesInput | positionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"position"> | number
    createdAt?: DateTimeWithAggregatesFilter<"position"> | Date | string
    positionId?: IntWithAggregatesFilter<"position"> | number
    owner?: StringNullableWithAggregatesFilter<"position"> | string | null
    isLP?: BoolWithAggregatesFilter<"position"> | boolean
    highPriceTick?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    isSettled?: BoolNullableWithAggregatesFilter<"position"> | boolean | null
    lpBaseToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    baseToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalWithAggregatesFilter<"position"> | Decimal | DecimalJsLike | number | string
    marketId?: IntNullableWithAggregatesFilter<"position"> | number | null
  }

  export type render_jobWhereInput = {
    AND?: render_jobWhereInput | render_jobWhereInput[]
    OR?: render_jobWhereInput[]
    NOT?: render_jobWhereInput | render_jobWhereInput[]
    id?: IntFilter<"render_job"> | number
    createdAt?: DateTimeFilter<"render_job"> | Date | string
    jobId?: StringFilter<"render_job"> | string
    serviceId?: StringFilter<"render_job"> | string
  }

  export type render_jobOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    serviceId?: SortOrder
  }

  export type render_jobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: render_jobWhereInput | render_jobWhereInput[]
    OR?: render_jobWhereInput[]
    NOT?: render_jobWhereInput | render_jobWhereInput[]
    createdAt?: DateTimeFilter<"render_job"> | Date | string
    jobId?: StringFilter<"render_job"> | string
    serviceId?: StringFilter<"render_job"> | string
  }, "id">

  export type render_jobOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    serviceId?: SortOrder
    _count?: render_jobCountOrderByAggregateInput
    _avg?: render_jobAvgOrderByAggregateInput
    _max?: render_jobMaxOrderByAggregateInput
    _min?: render_jobMinOrderByAggregateInput
    _sum?: render_jobSumOrderByAggregateInput
  }

  export type render_jobScalarWhereWithAggregatesInput = {
    AND?: render_jobScalarWhereWithAggregatesInput | render_jobScalarWhereWithAggregatesInput[]
    OR?: render_jobScalarWhereWithAggregatesInput[]
    NOT?: render_jobScalarWhereWithAggregatesInput | render_jobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"render_job"> | number
    createdAt?: DateTimeWithAggregatesFilter<"render_job"> | Date | string
    jobId?: StringWithAggregatesFilter<"render_job"> | string
    serviceId?: StringWithAggregatesFilter<"render_job"> | string
  }

  export type resourceWhereInput = {
    AND?: resourceWhereInput | resourceWhereInput[]
    OR?: resourceWhereInput[]
    NOT?: resourceWhereInput | resourceWhereInput[]
    id?: IntFilter<"resource"> | number
    createdAt?: DateTimeFilter<"resource"> | Date | string
    name?: StringFilter<"resource"> | string
    slug?: StringFilter<"resource"> | string
    categoryId?: IntNullableFilter<"resource"> | number | null
    market_group?: Market_groupListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    resource_price?: Resource_priceListRelationFilter
  }

  export type resourceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    market_group?: market_groupOrderByRelationAggregateInput
    category?: categoryOrderByWithRelationInput
    resource_price?: resource_priceOrderByRelationAggregateInput
  }

  export type resourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: resourceWhereInput | resourceWhereInput[]
    OR?: resourceWhereInput[]
    NOT?: resourceWhereInput | resourceWhereInput[]
    createdAt?: DateTimeFilter<"resource"> | Date | string
    categoryId?: IntNullableFilter<"resource"> | number | null
    market_group?: Market_groupListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    resource_price?: Resource_priceListRelationFilter
  }, "id" | "name" | "slug">

  export type resourceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: resourceCountOrderByAggregateInput
    _avg?: resourceAvgOrderByAggregateInput
    _max?: resourceMaxOrderByAggregateInput
    _min?: resourceMinOrderByAggregateInput
    _sum?: resourceSumOrderByAggregateInput
  }

  export type resourceScalarWhereWithAggregatesInput = {
    AND?: resourceScalarWhereWithAggregatesInput | resourceScalarWhereWithAggregatesInput[]
    OR?: resourceScalarWhereWithAggregatesInput[]
    NOT?: resourceScalarWhereWithAggregatesInput | resourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"resource"> | number
    createdAt?: DateTimeWithAggregatesFilter<"resource"> | Date | string
    name?: StringWithAggregatesFilter<"resource"> | string
    slug?: StringWithAggregatesFilter<"resource"> | string
    categoryId?: IntNullableWithAggregatesFilter<"resource"> | number | null
  }

  export type resource_priceWhereInput = {
    AND?: resource_priceWhereInput | resource_priceWhereInput[]
    OR?: resource_priceWhereInput[]
    NOT?: resource_priceWhereInput | resource_priceWhereInput[]
    id?: IntFilter<"resource_price"> | number
    createdAt?: DateTimeFilter<"resource_price"> | Date | string
    blockNumber?: IntFilter<"resource_price"> | number
    timestamp?: IntFilter<"resource_price"> | number
    value?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    used?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    resourceId?: IntNullableFilter<"resource_price"> | number | null
    resource?: XOR<ResourceNullableScalarRelationFilter, resourceWhereInput> | null
  }

  export type resource_priceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    resource?: resourceOrderByWithRelationInput
  }

  export type resource_priceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    resourceId_timestamp?: resource_priceResourceIdTimestampCompoundUniqueInput
    AND?: resource_priceWhereInput | resource_priceWhereInput[]
    OR?: resource_priceWhereInput[]
    NOT?: resource_priceWhereInput | resource_priceWhereInput[]
    createdAt?: DateTimeFilter<"resource_price"> | Date | string
    blockNumber?: IntFilter<"resource_price"> | number
    timestamp?: IntFilter<"resource_price"> | number
    value?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    used?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    resourceId?: IntNullableFilter<"resource_price"> | number | null
    resource?: XOR<ResourceNullableScalarRelationFilter, resourceWhereInput> | null
  }, "id" | "resourceId_timestamp">

  export type resource_priceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    _count?: resource_priceCountOrderByAggregateInput
    _avg?: resource_priceAvgOrderByAggregateInput
    _max?: resource_priceMaxOrderByAggregateInput
    _min?: resource_priceMinOrderByAggregateInput
    _sum?: resource_priceSumOrderByAggregateInput
  }

  export type resource_priceScalarWhereWithAggregatesInput = {
    AND?: resource_priceScalarWhereWithAggregatesInput | resource_priceScalarWhereWithAggregatesInput[]
    OR?: resource_priceScalarWhereWithAggregatesInput[]
    NOT?: resource_priceScalarWhereWithAggregatesInput | resource_priceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"resource_price"> | number
    createdAt?: DateTimeWithAggregatesFilter<"resource_price"> | Date | string
    blockNumber?: IntWithAggregatesFilter<"resource_price"> | number
    timestamp?: IntWithAggregatesFilter<"resource_price"> | number
    value?: DecimalWithAggregatesFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    used?: DecimalWithAggregatesFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalWithAggregatesFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    resourceId?: IntNullableWithAggregatesFilter<"resource_price"> | number | null
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id?: IntFilter<"transaction"> | number
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    tradeRatioD18?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFilter<"transaction"> | $Enums.transaction_type_enum
    baseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    eventId?: IntNullableFilter<"transaction"> | number | null
    positionId?: IntNullableFilter<"transaction"> | number | null
    marketPriceId?: IntNullableFilter<"transaction"> | number | null
    collateralTransferId?: IntNullableFilter<"transaction"> | number | null
    collateral_transfer?: XOR<Collateral_transferNullableScalarRelationFilter, collateral_transferWhereInput> | null
    market_price?: XOR<Market_priceNullableScalarRelationFilter, market_priceWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, eventWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, positionWhereInput> | null
  }

  export type transactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tradeRatioD18?: SortOrderInput | SortOrder
    type?: SortOrder
    baseToken?: SortOrderInput | SortOrder
    quoteToken?: SortOrderInput | SortOrder
    borrowedBaseToken?: SortOrderInput | SortOrder
    borrowedQuoteToken?: SortOrderInput | SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrderInput | SortOrder
    lpQuoteDeltaToken?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    marketPriceId?: SortOrderInput | SortOrder
    collateralTransferId?: SortOrderInput | SortOrder
    collateral_transfer?: collateral_transferOrderByWithRelationInput
    market_price?: market_priceOrderByWithRelationInput
    event?: eventOrderByWithRelationInput
    position?: positionOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    eventId?: number
    marketPriceId?: number
    collateralTransferId?: number
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    tradeRatioD18?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFilter<"transaction"> | $Enums.transaction_type_enum
    baseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    positionId?: IntNullableFilter<"transaction"> | number | null
    collateral_transfer?: XOR<Collateral_transferNullableScalarRelationFilter, collateral_transferWhereInput> | null
    market_price?: XOR<Market_priceNullableScalarRelationFilter, market_priceWhereInput> | null
    event?: XOR<EventNullableScalarRelationFilter, eventWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, positionWhereInput> | null
  }, "id" | "eventId" | "marketPriceId" | "collateralTransferId">

  export type transactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tradeRatioD18?: SortOrderInput | SortOrder
    type?: SortOrder
    baseToken?: SortOrderInput | SortOrder
    quoteToken?: SortOrderInput | SortOrder
    borrowedBaseToken?: SortOrderInput | SortOrder
    borrowedQuoteToken?: SortOrderInput | SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrderInput | SortOrder
    lpQuoteDeltaToken?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    marketPriceId?: SortOrderInput | SortOrder
    collateralTransferId?: SortOrderInput | SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
    tradeRatioD18?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumWithAggregatesFilter<"transaction"> | $Enums.transaction_type_enum
    baseToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: DecimalNullableWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    eventId?: IntNullableWithAggregatesFilter<"transaction"> | number | null
    positionId?: IntNullableWithAggregatesFilter<"transaction"> | number | null
    marketPriceId?: IntNullableWithAggregatesFilter<"transaction"> | number | null
    collateralTransferId?: IntNullableWithAggregatesFilter<"transaction"> | number | null
  }

  export type cache_candleCreateInput = {
    createdAt?: Date | string
    candleType: string
    interval: number
    trailingAvgTime?: number | null
    resourceSlug?: string | null
    marketIdx?: number | null
    timestamp: number
    open: string
    high: string
    low: string
    close: string
    endTimestamp: number
    lastUpdatedTimestamp: number
    sumUsed?: Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: number | null
    address?: string | null
    chainId?: number | null
    marketId?: number | null
  }

  export type cache_candleUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    candleType: string
    interval: number
    trailingAvgTime?: number | null
    resourceSlug?: string | null
    marketIdx?: number | null
    timestamp: number
    open: string
    high: string
    low: string
    close: string
    endTimestamp: number
    lastUpdatedTimestamp: number
    sumUsed?: Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: number | null
    address?: string | null
    chainId?: number | null
    marketId?: number | null
  }

  export type cache_candleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candleType?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    trailingAvgTime?: NullableIntFieldUpdateOperationsInput | number | null
    resourceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    marketIdx?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: IntFieldUpdateOperationsInput | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    endTimestamp?: IntFieldUpdateOperationsInput | number
    lastUpdatedTimestamp?: IntFieldUpdateOperationsInput | number
    sumUsed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: NullableIntFieldUpdateOperationsInput | number | null
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cache_candleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candleType?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    trailingAvgTime?: NullableIntFieldUpdateOperationsInput | number | null
    resourceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    marketIdx?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: IntFieldUpdateOperationsInput | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    endTimestamp?: IntFieldUpdateOperationsInput | number
    lastUpdatedTimestamp?: IntFieldUpdateOperationsInput | number
    sumUsed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: NullableIntFieldUpdateOperationsInput | number | null
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cache_candleCreateManyInput = {
    id?: number
    createdAt?: Date | string
    candleType: string
    interval: number
    trailingAvgTime?: number | null
    resourceSlug?: string | null
    marketIdx?: number | null
    timestamp: number
    open: string
    high: string
    low: string
    close: string
    endTimestamp: number
    lastUpdatedTimestamp: number
    sumUsed?: Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: number | null
    address?: string | null
    chainId?: number | null
    marketId?: number | null
  }

  export type cache_candleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candleType?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    trailingAvgTime?: NullableIntFieldUpdateOperationsInput | number | null
    resourceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    marketIdx?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: IntFieldUpdateOperationsInput | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    endTimestamp?: IntFieldUpdateOperationsInput | number
    lastUpdatedTimestamp?: IntFieldUpdateOperationsInput | number
    sumUsed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: NullableIntFieldUpdateOperationsInput | number | null
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cache_candleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candleType?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    trailingAvgTime?: NullableIntFieldUpdateOperationsInput | number | null
    resourceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    marketIdx?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: IntFieldUpdateOperationsInput | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    endTimestamp?: IntFieldUpdateOperationsInput | number
    lastUpdatedTimestamp?: IntFieldUpdateOperationsInput | number
    sumUsed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sumFeePaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingStartTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    chainId?: NullableIntFieldUpdateOperationsInput | number | null
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cache_paramCreateInput = {
    createdAt?: Date | string
    paramName: string
    paramValueNumber: Decimal | DecimalJsLike | number | string
    paramValueString?: string | null
  }

  export type cache_paramUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    paramName: string
    paramValueNumber: Decimal | DecimalJsLike | number | string
    paramValueString?: string | null
  }

  export type cache_paramUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paramName?: StringFieldUpdateOperationsInput | string
    paramValueNumber?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paramValueString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cache_paramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paramName?: StringFieldUpdateOperationsInput | string
    paramValueNumber?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paramValueString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cache_paramCreateManyInput = {
    id?: number
    createdAt?: Date | string
    paramName: string
    paramValueNumber: Decimal | DecimalJsLike | number | string
    paramValueString?: string | null
  }

  export type cache_paramUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paramName?: StringFieldUpdateOperationsInput | string
    paramValueNumber?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paramValueString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cache_paramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paramName?: StringFieldUpdateOperationsInput | string
    paramValueNumber?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paramValueString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryCreateInput = {
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupCreateNestedManyWithoutCategoryInput
    resource?: resourceCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupUncheckedCreateNestedManyWithoutCategoryInput
    resource?: resourceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUpdateManyWithoutCategoryNestedInput
    resource?: resourceUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUncheckedUpdateManyWithoutCategoryNestedInput
    resource?: resourceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
  }

  export type categoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type collateral_transferCreateInput = {
    createdAt?: Date | string
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal | DecimalJsLike | number | string
    transaction?: transactionCreateNestedOneWithoutCollateral_transferInput
  }

  export type collateral_transferUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedCreateNestedOneWithoutCollateral_transferInput
  }

  export type collateral_transferUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUpdateOneWithoutCollateral_transferNestedInput
  }

  export type collateral_transferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedUpdateOneWithoutCollateral_transferNestedInput
  }

  export type collateral_transferCreateManyInput = {
    id?: number
    createdAt?: Date | string
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal | DecimalJsLike | number | string
  }

  export type collateral_transferUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type collateral_transferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type crypto_pricesCreateInput = {
    ticker?: string | null
    price: number
    timestamp?: Date | string
  }

  export type crypto_pricesUncheckedCreateInput = {
    id?: number
    ticker?: string | null
    price: number
    timestamp?: Date | string
  }

  export type crypto_pricesUpdateInput = {
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crypto_pricesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crypto_pricesCreateManyInput = {
    id?: number
    ticker?: string | null
    price: number
    timestamp?: Date | string
  }

  export type crypto_pricesUpdateManyMutationInput = {
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crypto_pricesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventCreateInput = {
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    market_group?: market_groupCreateNestedOneWithoutEventInput
    transaction?: transactionCreateNestedOneWithoutEventInput
  }

  export type eventUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    marketGroupId?: number | null
    transaction?: transactionUncheckedCreateNestedOneWithoutEventInput
  }

  export type eventUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    market_group?: market_groupUpdateOneWithoutEventNestedInput
    transaction?: transactionUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: transactionUncheckedUpdateOneWithoutEventNestedInput
  }

  export type eventCreateManyInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    marketGroupId?: number | null
  }

  export type eventUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
  }

  export type eventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type marketCreateInput = {
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
    market_group?: market_groupCreateNestedOneWithoutMarketInput
    position?: positionCreateNestedManyWithoutMarketInput
  }

  export type marketUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketGroupId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
    position?: positionUncheckedCreateNestedManyWithoutMarketInput
  }

  export type marketUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    market_group?: market_groupUpdateOneWithoutMarketNestedInput
    position?: positionUpdateManyWithoutMarketNestedInput
  }

  export type marketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    position?: positionUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type marketCreateManyInput = {
    id?: number
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketGroupId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
  }

  export type marketUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type marketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type market_groupCreateInput = {
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventCreateNestedManyWithoutMarket_groupInput
    market?: marketCreateNestedManyWithoutMarket_groupInput
    resource?: resourceCreateNestedOneWithoutMarket_groupInput
    category?: categoryCreateNestedOneWithoutMarket_groupInput
  }

  export type market_groupUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedCreateNestedManyWithoutMarket_groupInput
    market?: marketUncheckedCreateNestedManyWithoutMarket_groupInput
  }

  export type market_groupUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUpdateManyWithoutMarket_groupNestedInput
    market?: marketUpdateManyWithoutMarket_groupNestedInput
    resource?: resourceUpdateOneWithoutMarket_groupNestedInput
    category?: categoryUpdateOneWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedUpdateManyWithoutMarket_groupNestedInput
    market?: marketUncheckedUpdateManyWithoutMarket_groupNestedInput
  }

  export type market_groupCreateManyInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
  }

  export type market_groupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type market_groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type market_priceCreateInput = {
    createdAt?: Date | string
    timestamp: bigint | number
    value: Decimal | DecimalJsLike | number | string
    transaction?: transactionCreateNestedOneWithoutMarket_priceInput
  }

  export type market_priceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    timestamp: bigint | number
    value: Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedCreateNestedOneWithoutMarket_priceInput
  }

  export type market_priceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUpdateOneWithoutMarket_priceNestedInput
  }

  export type market_priceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedUpdateOneWithoutMarket_priceNestedInput
  }

  export type market_priceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    timestamp: bigint | number
    value: Decimal | DecimalJsLike | number | string
  }

  export type market_priceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type market_priceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type migrationsCreateInput = {
    timestamp: bigint | number
    name: string
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsCreateManyInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateManyMutationInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type positionCreateInput = {
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    market?: marketCreateNestedOneWithoutPositionInput
    transaction?: transactionCreateNestedManyWithoutPositionInput
  }

  export type positionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    marketId?: number | null
    transaction?: transactionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type positionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    market?: marketUpdateOneWithoutPositionNestedInput
    transaction?: transactionUpdateManyWithoutPositionNestedInput
  }

  export type positionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
    transaction?: transactionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type positionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    marketId?: number | null
  }

  export type positionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type positionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type render_jobCreateInput = {
    createdAt?: Date | string
    jobId: string
    serviceId: string
  }

  export type render_jobUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    jobId: string
    serviceId: string
  }

  export type render_jobUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type render_jobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type render_jobCreateManyInput = {
    id?: number
    createdAt?: Date | string
    jobId: string
    serviceId: string
  }

  export type render_jobUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type render_jobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type resourceCreateInput = {
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupCreateNestedManyWithoutResourceInput
    category?: categoryCreateNestedOneWithoutResourceInput
    resource_price?: resource_priceCreateNestedManyWithoutResourceInput
  }

  export type resourceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    categoryId?: number | null
    market_group?: market_groupUncheckedCreateNestedManyWithoutResourceInput
    resource_price?: resource_priceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type resourceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUpdateManyWithoutResourceNestedInput
    category?: categoryUpdateOneWithoutResourceNestedInput
    resource_price?: resource_priceUpdateManyWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    market_group?: market_groupUncheckedUpdateManyWithoutResourceNestedInput
    resource_price?: resource_priceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type resourceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    categoryId?: number | null
  }

  export type resourceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type resourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type resource_priceCreateInput = {
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
    resource?: resourceCreateNestedOneWithoutResource_priceInput
  }

  export type resource_priceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
    resourceId?: number | null
  }

  export type resource_priceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resource?: resourceUpdateOneWithoutResource_priceNestedInput
  }

  export type resource_priceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type resource_priceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
    resourceId?: number | null
  }

  export type resource_priceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type resource_priceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionCreateInput = {
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferCreateNestedOneWithoutTransactionInput
    market_price?: market_priceCreateNestedOneWithoutTransactionInput
    event?: eventCreateNestedOneWithoutTransactionInput
    position?: positionCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    positionId?: number | null
    marketPriceId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferUpdateOneWithoutTransactionNestedInput
    market_price?: market_priceUpdateOneWithoutTransactionNestedInput
    event?: eventUpdateOneWithoutTransactionNestedInput
    position?: positionUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    positionId?: number | null
    marketPriceId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type cache_candleCandleTypeIntervalTimestampResourceSlugMarketIdxTrailingAvgTimeCompoundUniqueInput = {
    candleType: string
    interval: number
    timestamp: number
    resourceSlug: string
    marketIdx: number
    trailingAvgTime: number
  }

  export type cache_candleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    candleType?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrder
    resourceSlug?: SortOrder
    marketIdx?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrder
    sumFeePaid?: SortOrder
    trailingStartTimestamp?: SortOrder
    address?: SortOrder
    chainId?: SortOrder
    marketId?: SortOrder
  }

  export type cache_candleAvgOrderByAggregateInput = {
    id?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrder
    marketIdx?: SortOrder
    timestamp?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrder
    sumFeePaid?: SortOrder
    trailingStartTimestamp?: SortOrder
    chainId?: SortOrder
    marketId?: SortOrder
  }

  export type cache_candleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    candleType?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrder
    resourceSlug?: SortOrder
    marketIdx?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrder
    sumFeePaid?: SortOrder
    trailingStartTimestamp?: SortOrder
    address?: SortOrder
    chainId?: SortOrder
    marketId?: SortOrder
  }

  export type cache_candleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    candleType?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrder
    resourceSlug?: SortOrder
    marketIdx?: SortOrder
    timestamp?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrder
    sumFeePaid?: SortOrder
    trailingStartTimestamp?: SortOrder
    address?: SortOrder
    chainId?: SortOrder
    marketId?: SortOrder
  }

  export type cache_candleSumOrderByAggregateInput = {
    id?: SortOrder
    interval?: SortOrder
    trailingAvgTime?: SortOrder
    marketIdx?: SortOrder
    timestamp?: SortOrder
    endTimestamp?: SortOrder
    lastUpdatedTimestamp?: SortOrder
    sumUsed?: SortOrder
    sumFeePaid?: SortOrder
    trailingStartTimestamp?: SortOrder
    chainId?: SortOrder
    marketId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type cache_paramCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    paramName?: SortOrder
    paramValueNumber?: SortOrder
    paramValueString?: SortOrder
  }

  export type cache_paramAvgOrderByAggregateInput = {
    id?: SortOrder
    paramValueNumber?: SortOrder
  }

  export type cache_paramMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    paramName?: SortOrder
    paramValueNumber?: SortOrder
    paramValueString?: SortOrder
  }

  export type cache_paramMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    paramName?: SortOrder
    paramValueNumber?: SortOrder
    paramValueString?: SortOrder
  }

  export type cache_paramSumOrderByAggregateInput = {
    id?: SortOrder
    paramValueNumber?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Market_groupListRelationFilter = {
    every?: market_groupWhereInput
    some?: market_groupWhereInput
    none?: market_groupWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: resourceWhereInput
    some?: resourceWhereInput
    none?: resourceWhereInput
  }

  export type market_groupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: transactionWhereInput | null
    isNot?: transactionWhereInput | null
  }

  export type collateral_transferCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    owner?: SortOrder
    collateral?: SortOrder
  }

  export type collateral_transferAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    collateral?: SortOrder
  }

  export type collateral_transferMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    owner?: SortOrder
    collateral?: SortOrder
  }

  export type collateral_transferMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    owner?: SortOrder
    collateral?: SortOrder
  }

  export type collateral_transferSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    collateral?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type crypto_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type crypto_pricesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type crypto_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type crypto_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type crypto_pricesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Market_groupNullableScalarRelationFilter = {
    is?: market_groupWhereInput | null
    isNot?: market_groupWhereInput | null
  }

  export type eventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput = {
    transactionHash: string
    marketGroupId: number
    blockNumber: number
    logIndex: number
  }

  export type eventCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    logData?: SortOrder
    marketGroupId?: SortOrder
  }

  export type eventAvgOrderByAggregateInput = {
    id?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    marketGroupId?: SortOrder
  }

  export type eventMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    marketGroupId?: SortOrder
  }

  export type eventMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    transactionHash?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    marketGroupId?: SortOrder
  }

  export type eventSumOrderByAggregateInput = {
    id?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    logIndex?: SortOrder
    marketGroupId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PositionListRelationFilter = {
    every?: positionWhereInput
    some?: positionWhereInput
    none?: positionWhereInput
  }

  export type positionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marketMarketGroupIdMarketIdCompoundUniqueInput = {
    marketGroupId: number
    marketId: number
  }

  export type marketCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    startingSqrtPriceX96?: SortOrder
    settlementPriceD18?: SortOrder
    settled?: SortOrder
    baseAssetMinPriceTick?: SortOrder
    baseAssetMaxPriceTick?: SortOrder
    minPriceD18?: SortOrder
    maxPriceD18?: SortOrder
    marketGroupId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    public?: SortOrder
    question?: SortOrder
    poolAddress?: SortOrder
    optionName?: SortOrder
    rules?: SortOrder
  }

  export type marketAvgOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    startingSqrtPriceX96?: SortOrder
    settlementPriceD18?: SortOrder
    baseAssetMinPriceTick?: SortOrder
    baseAssetMaxPriceTick?: SortOrder
    minPriceD18?: SortOrder
    maxPriceD18?: SortOrder
    marketGroupId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondamount?: SortOrder
  }

  export type marketMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    startingSqrtPriceX96?: SortOrder
    settlementPriceD18?: SortOrder
    settled?: SortOrder
    baseAssetMinPriceTick?: SortOrder
    baseAssetMaxPriceTick?: SortOrder
    minPriceD18?: SortOrder
    maxPriceD18?: SortOrder
    marketGroupId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    public?: SortOrder
    question?: SortOrder
    poolAddress?: SortOrder
    optionName?: SortOrder
    rules?: SortOrder
  }

  export type marketMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    startingSqrtPriceX96?: SortOrder
    settlementPriceD18?: SortOrder
    settled?: SortOrder
    baseAssetMinPriceTick?: SortOrder
    baseAssetMaxPriceTick?: SortOrder
    minPriceD18?: SortOrder
    maxPriceD18?: SortOrder
    marketGroupId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    public?: SortOrder
    question?: SortOrder
    poolAddress?: SortOrder
    optionName?: SortOrder
    rules?: SortOrder
  }

  export type marketSumOrderByAggregateInput = {
    id?: SortOrder
    marketId?: SortOrder
    startTimestamp?: SortOrder
    endTimestamp?: SortOrder
    startingSqrtPriceX96?: SortOrder
    settlementPriceD18?: SortOrder
    baseAssetMinPriceTick?: SortOrder
    baseAssetMaxPriceTick?: SortOrder
    minPriceD18?: SortOrder
    maxPriceD18?: SortOrder
    marketGroupId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondamount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EventListRelationFilter = {
    every?: eventWhereInput
    some?: eventWhereInput
    none?: eventWhereInput
  }

  export type MarketListRelationFilter = {
    every?: marketWhereInput
    some?: marketWhereInput
    none?: marketWhereInput
  }

  export type ResourceNullableScalarRelationFilter = {
    is?: resourceWhereInput | null
    isNot?: resourceWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type eventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type market_groupAddressChainIdCompoundUniqueInput = {
    address: string
    chainId: number
  }

  export type market_groupCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    address?: SortOrder
    vaultAddress?: SortOrder
    isYin?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrder
    deployTxnBlockNumber?: SortOrder
    owner?: SortOrder
    collateralAsset?: SortOrder
    resourceId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    isCumulative?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    baseTokenName?: SortOrder
    quoteTokenName?: SortOrder
    collateralDecimals?: SortOrder
    collateralSymbol?: SortOrder
    initializationNonce?: SortOrder
    factoryAddress?: SortOrder
    minTradeSize?: SortOrder
  }

  export type market_groupAvgOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrder
    deployTxnBlockNumber?: SortOrder
    resourceId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondamount?: SortOrder
    categoryId?: SortOrder
    collateralDecimals?: SortOrder
    minTradeSize?: SortOrder
  }

  export type market_groupMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    address?: SortOrder
    vaultAddress?: SortOrder
    isYin?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrder
    deployTxnBlockNumber?: SortOrder
    owner?: SortOrder
    collateralAsset?: SortOrder
    resourceId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    isCumulative?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    baseTokenName?: SortOrder
    quoteTokenName?: SortOrder
    collateralDecimals?: SortOrder
    collateralSymbol?: SortOrder
    initializationNonce?: SortOrder
    factoryAddress?: SortOrder
    minTradeSize?: SortOrder
  }

  export type market_groupMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    address?: SortOrder
    vaultAddress?: SortOrder
    isYin?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrder
    deployTxnBlockNumber?: SortOrder
    owner?: SortOrder
    collateralAsset?: SortOrder
    resourceId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondcurrency?: SortOrder
    marketParamsBondamount?: SortOrder
    marketParamsClaimstatement?: SortOrder
    marketParamsUniswappositionmanager?: SortOrder
    marketParamsUniswapswaprouter?: SortOrder
    marketParamsUniswapquoter?: SortOrder
    marketParamsOptimisticoraclev3?: SortOrder
    isCumulative?: SortOrder
    categoryId?: SortOrder
    question?: SortOrder
    baseTokenName?: SortOrder
    quoteTokenName?: SortOrder
    collateralDecimals?: SortOrder
    collateralSymbol?: SortOrder
    initializationNonce?: SortOrder
    factoryAddress?: SortOrder
    minTradeSize?: SortOrder
  }

  export type market_groupSumOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    deployTimestamp?: SortOrder
    deployTxnBlockNumber?: SortOrder
    resourceId?: SortOrder
    marketParamsFeerate?: SortOrder
    marketParamsAssertionliveness?: SortOrder
    marketParamsBondamount?: SortOrder
    categoryId?: SortOrder
    collateralDecimals?: SortOrder
    minTradeSize?: SortOrder
  }

  export type market_priceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
  }

  export type market_priceAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
  }

  export type market_priceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
  }

  export type market_priceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
  }

  export type market_priceSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketNullableScalarRelationFilter = {
    is?: marketWhereInput | null
    isNot?: marketWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type positionPositionIdMarketIdCompoundUniqueInput = {
    positionId: number
    marketId: number
  }

  export type positionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    positionId?: SortOrder
    owner?: SortOrder
    isLP?: SortOrder
    highPriceTick?: SortOrder
    lowPriceTick?: SortOrder
    isSettled?: SortOrder
    lpBaseToken?: SortOrder
    lpQuoteToken?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    marketId?: SortOrder
  }

  export type positionAvgOrderByAggregateInput = {
    id?: SortOrder
    positionId?: SortOrder
    highPriceTick?: SortOrder
    lowPriceTick?: SortOrder
    lpBaseToken?: SortOrder
    lpQuoteToken?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    marketId?: SortOrder
  }

  export type positionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    positionId?: SortOrder
    owner?: SortOrder
    isLP?: SortOrder
    highPriceTick?: SortOrder
    lowPriceTick?: SortOrder
    isSettled?: SortOrder
    lpBaseToken?: SortOrder
    lpQuoteToken?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    marketId?: SortOrder
  }

  export type positionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    positionId?: SortOrder
    owner?: SortOrder
    isLP?: SortOrder
    highPriceTick?: SortOrder
    lowPriceTick?: SortOrder
    isSettled?: SortOrder
    lpBaseToken?: SortOrder
    lpQuoteToken?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    marketId?: SortOrder
  }

  export type positionSumOrderByAggregateInput = {
    id?: SortOrder
    positionId?: SortOrder
    highPriceTick?: SortOrder
    lowPriceTick?: SortOrder
    lpBaseToken?: SortOrder
    lpQuoteToken?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    marketId?: SortOrder
  }

  export type render_jobCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    serviceId?: SortOrder
  }

  export type render_jobAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type render_jobMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    serviceId?: SortOrder
  }

  export type render_jobMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    serviceId?: SortOrder
  }

  export type render_jobSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Resource_priceListRelationFilter = {
    every?: resource_priceWhereInput
    some?: resource_priceWhereInput
    none?: resource_priceWhereInput
  }

  export type resource_priceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type resourceAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type resourceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type resourceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type resourceSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type resource_priceResourceIdTimestampCompoundUniqueInput = {
    resourceId: number
    timestamp: number
  }

  export type resource_priceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrder
  }

  export type resource_priceAvgOrderByAggregateInput = {
    id?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrder
  }

  export type resource_priceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrder
  }

  export type resource_priceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrder
  }

  export type resource_priceSumOrderByAggregateInput = {
    id?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    used?: SortOrder
    feePaid?: SortOrder
    resourceId?: SortOrder
  }

  export type Enumtransaction_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.transaction_type_enum | Enumtransaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumtransaction_type_enumFilter<$PrismaModel> | $Enums.transaction_type_enum
  }

  export type Collateral_transferNullableScalarRelationFilter = {
    is?: collateral_transferWhereInput | null
    isNot?: collateral_transferWhereInput | null
  }

  export type Market_priceNullableScalarRelationFilter = {
    is?: market_priceWhereInput | null
    isNot?: market_priceWhereInput | null
  }

  export type EventNullableScalarRelationFilter = {
    is?: eventWhereInput | null
    isNot?: eventWhereInput | null
  }

  export type PositionNullableScalarRelationFilter = {
    is?: positionWhereInput | null
    isNot?: positionWhereInput | null
  }

  export type transactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tradeRatioD18?: SortOrder
    type?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrder
    lpQuoteDeltaToken?: SortOrder
    eventId?: SortOrder
    positionId?: SortOrder
    marketPriceId?: SortOrder
    collateralTransferId?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    id?: SortOrder
    tradeRatioD18?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrder
    lpQuoteDeltaToken?: SortOrder
    eventId?: SortOrder
    positionId?: SortOrder
    marketPriceId?: SortOrder
    collateralTransferId?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tradeRatioD18?: SortOrder
    type?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrder
    lpQuoteDeltaToken?: SortOrder
    eventId?: SortOrder
    positionId?: SortOrder
    marketPriceId?: SortOrder
    collateralTransferId?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    tradeRatioD18?: SortOrder
    type?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrder
    lpQuoteDeltaToken?: SortOrder
    eventId?: SortOrder
    positionId?: SortOrder
    marketPriceId?: SortOrder
    collateralTransferId?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    id?: SortOrder
    tradeRatioD18?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    borrowedBaseToken?: SortOrder
    borrowedQuoteToken?: SortOrder
    collateral?: SortOrder
    lpBaseDeltaToken?: SortOrder
    lpQuoteDeltaToken?: SortOrder
    eventId?: SortOrder
    positionId?: SortOrder
    marketPriceId?: SortOrder
    collateralTransferId?: SortOrder
  }

  export type Enumtransaction_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transaction_type_enum | Enumtransaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumtransaction_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.transaction_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransaction_type_enumFilter<$PrismaModel>
    _max?: NestedEnumtransaction_type_enumFilter<$PrismaModel>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type market_groupCreateNestedManyWithoutCategoryInput = {
    create?: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput> | market_groupCreateWithoutCategoryInput[] | market_groupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutCategoryInput | market_groupCreateOrConnectWithoutCategoryInput[]
    createMany?: market_groupCreateManyCategoryInputEnvelope
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
  }

  export type resourceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput> | resourceCreateWithoutCategoryInput[] | resourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutCategoryInput | resourceCreateOrConnectWithoutCategoryInput[]
    createMany?: resourceCreateManyCategoryInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type market_groupUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput> | market_groupCreateWithoutCategoryInput[] | market_groupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutCategoryInput | market_groupCreateOrConnectWithoutCategoryInput[]
    createMany?: market_groupCreateManyCategoryInputEnvelope
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
  }

  export type resourceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput> | resourceCreateWithoutCategoryInput[] | resourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutCategoryInput | resourceCreateOrConnectWithoutCategoryInput[]
    createMany?: resourceCreateManyCategoryInputEnvelope
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
  }

  export type market_groupUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput> | market_groupCreateWithoutCategoryInput[] | market_groupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutCategoryInput | market_groupCreateOrConnectWithoutCategoryInput[]
    upsert?: market_groupUpsertWithWhereUniqueWithoutCategoryInput | market_groupUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: market_groupCreateManyCategoryInputEnvelope
    set?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    disconnect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    delete?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    update?: market_groupUpdateWithWhereUniqueWithoutCategoryInput | market_groupUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: market_groupUpdateManyWithWhereWithoutCategoryInput | market_groupUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
  }

  export type resourceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput> | resourceCreateWithoutCategoryInput[] | resourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutCategoryInput | resourceCreateOrConnectWithoutCategoryInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutCategoryInput | resourceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: resourceCreateManyCategoryInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutCategoryInput | resourceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutCategoryInput | resourceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type market_groupUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput> | market_groupCreateWithoutCategoryInput[] | market_groupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutCategoryInput | market_groupCreateOrConnectWithoutCategoryInput[]
    upsert?: market_groupUpsertWithWhereUniqueWithoutCategoryInput | market_groupUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: market_groupCreateManyCategoryInputEnvelope
    set?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    disconnect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    delete?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    update?: market_groupUpdateWithWhereUniqueWithoutCategoryInput | market_groupUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: market_groupUpdateManyWithWhereWithoutCategoryInput | market_groupUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
  }

  export type resourceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput> | resourceCreateWithoutCategoryInput[] | resourceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: resourceCreateOrConnectWithoutCategoryInput | resourceCreateOrConnectWithoutCategoryInput[]
    upsert?: resourceUpsertWithWhereUniqueWithoutCategoryInput | resourceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: resourceCreateManyCategoryInputEnvelope
    set?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    disconnect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    delete?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    connect?: resourceWhereUniqueInput | resourceWhereUniqueInput[]
    update?: resourceUpdateWithWhereUniqueWithoutCategoryInput | resourceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: resourceUpdateManyWithWhereWithoutCategoryInput | resourceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: resourceScalarWhereInput | resourceScalarWhereInput[]
  }

  export type transactionCreateNestedOneWithoutCollateral_transferInput = {
    create?: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
    connectOrCreate?: transactionCreateOrConnectWithoutCollateral_transferInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUncheckedCreateNestedOneWithoutCollateral_transferInput = {
    create?: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
    connectOrCreate?: transactionCreateOrConnectWithoutCollateral_transferInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUpdateOneWithoutCollateral_transferNestedInput = {
    create?: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
    connectOrCreate?: transactionCreateOrConnectWithoutCollateral_transferInput
    upsert?: transactionUpsertWithoutCollateral_transferInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutCollateral_transferInput, transactionUpdateWithoutCollateral_transferInput>, transactionUncheckedUpdateWithoutCollateral_transferInput>
  }

  export type transactionUncheckedUpdateOneWithoutCollateral_transferNestedInput = {
    create?: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
    connectOrCreate?: transactionCreateOrConnectWithoutCollateral_transferInput
    upsert?: transactionUpsertWithoutCollateral_transferInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutCollateral_transferInput, transactionUpdateWithoutCollateral_transferInput>, transactionUncheckedUpdateWithoutCollateral_transferInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type market_groupCreateNestedOneWithoutEventInput = {
    create?: XOR<market_groupCreateWithoutEventInput, market_groupUncheckedCreateWithoutEventInput>
    connectOrCreate?: market_groupCreateOrConnectWithoutEventInput
    connect?: market_groupWhereUniqueInput
  }

  export type transactionCreateNestedOneWithoutEventInput = {
    create?: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
    connectOrCreate?: transactionCreateOrConnectWithoutEventInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
    connectOrCreate?: transactionCreateOrConnectWithoutEventInput
    connect?: transactionWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type market_groupUpdateOneWithoutEventNestedInput = {
    create?: XOR<market_groupCreateWithoutEventInput, market_groupUncheckedCreateWithoutEventInput>
    connectOrCreate?: market_groupCreateOrConnectWithoutEventInput
    upsert?: market_groupUpsertWithoutEventInput
    disconnect?: market_groupWhereInput | boolean
    delete?: market_groupWhereInput | boolean
    connect?: market_groupWhereUniqueInput
    update?: XOR<XOR<market_groupUpdateToOneWithWhereWithoutEventInput, market_groupUpdateWithoutEventInput>, market_groupUncheckedUpdateWithoutEventInput>
  }

  export type transactionUpdateOneWithoutEventNestedInput = {
    create?: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
    connectOrCreate?: transactionCreateOrConnectWithoutEventInput
    upsert?: transactionUpsertWithoutEventInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutEventInput, transactionUpdateWithoutEventInput>, transactionUncheckedUpdateWithoutEventInput>
  }

  export type transactionUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
    connectOrCreate?: transactionCreateOrConnectWithoutEventInput
    upsert?: transactionUpsertWithoutEventInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutEventInput, transactionUpdateWithoutEventInput>, transactionUncheckedUpdateWithoutEventInput>
  }

  export type market_groupCreateNestedOneWithoutMarketInput = {
    create?: XOR<market_groupCreateWithoutMarketInput, market_groupUncheckedCreateWithoutMarketInput>
    connectOrCreate?: market_groupCreateOrConnectWithoutMarketInput
    connect?: market_groupWhereUniqueInput
  }

  export type positionCreateNestedManyWithoutMarketInput = {
    create?: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput> | positionCreateWithoutMarketInput[] | positionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: positionCreateOrConnectWithoutMarketInput | positionCreateOrConnectWithoutMarketInput[]
    createMany?: positionCreateManyMarketInputEnvelope
    connect?: positionWhereUniqueInput | positionWhereUniqueInput[]
  }

  export type positionUncheckedCreateNestedManyWithoutMarketInput = {
    create?: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput> | positionCreateWithoutMarketInput[] | positionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: positionCreateOrConnectWithoutMarketInput | positionCreateOrConnectWithoutMarketInput[]
    createMany?: positionCreateManyMarketInputEnvelope
    connect?: positionWhereUniqueInput | positionWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type market_groupUpdateOneWithoutMarketNestedInput = {
    create?: XOR<market_groupCreateWithoutMarketInput, market_groupUncheckedCreateWithoutMarketInput>
    connectOrCreate?: market_groupCreateOrConnectWithoutMarketInput
    upsert?: market_groupUpsertWithoutMarketInput
    disconnect?: market_groupWhereInput | boolean
    delete?: market_groupWhereInput | boolean
    connect?: market_groupWhereUniqueInput
    update?: XOR<XOR<market_groupUpdateToOneWithWhereWithoutMarketInput, market_groupUpdateWithoutMarketInput>, market_groupUncheckedUpdateWithoutMarketInput>
  }

  export type positionUpdateManyWithoutMarketNestedInput = {
    create?: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput> | positionCreateWithoutMarketInput[] | positionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: positionCreateOrConnectWithoutMarketInput | positionCreateOrConnectWithoutMarketInput[]
    upsert?: positionUpsertWithWhereUniqueWithoutMarketInput | positionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: positionCreateManyMarketInputEnvelope
    set?: positionWhereUniqueInput | positionWhereUniqueInput[]
    disconnect?: positionWhereUniqueInput | positionWhereUniqueInput[]
    delete?: positionWhereUniqueInput | positionWhereUniqueInput[]
    connect?: positionWhereUniqueInput | positionWhereUniqueInput[]
    update?: positionUpdateWithWhereUniqueWithoutMarketInput | positionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: positionUpdateManyWithWhereWithoutMarketInput | positionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: positionScalarWhereInput | positionScalarWhereInput[]
  }

  export type positionUncheckedUpdateManyWithoutMarketNestedInput = {
    create?: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput> | positionCreateWithoutMarketInput[] | positionUncheckedCreateWithoutMarketInput[]
    connectOrCreate?: positionCreateOrConnectWithoutMarketInput | positionCreateOrConnectWithoutMarketInput[]
    upsert?: positionUpsertWithWhereUniqueWithoutMarketInput | positionUpsertWithWhereUniqueWithoutMarketInput[]
    createMany?: positionCreateManyMarketInputEnvelope
    set?: positionWhereUniqueInput | positionWhereUniqueInput[]
    disconnect?: positionWhereUniqueInput | positionWhereUniqueInput[]
    delete?: positionWhereUniqueInput | positionWhereUniqueInput[]
    connect?: positionWhereUniqueInput | positionWhereUniqueInput[]
    update?: positionUpdateWithWhereUniqueWithoutMarketInput | positionUpdateWithWhereUniqueWithoutMarketInput[]
    updateMany?: positionUpdateManyWithWhereWithoutMarketInput | positionUpdateManyWithWhereWithoutMarketInput[]
    deleteMany?: positionScalarWhereInput | positionScalarWhereInput[]
  }

  export type eventCreateNestedManyWithoutMarket_groupInput = {
    create?: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput> | eventCreateWithoutMarket_groupInput[] | eventUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: eventCreateOrConnectWithoutMarket_groupInput | eventCreateOrConnectWithoutMarket_groupInput[]
    createMany?: eventCreateManyMarket_groupInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type marketCreateNestedManyWithoutMarket_groupInput = {
    create?: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput> | marketCreateWithoutMarket_groupInput[] | marketUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: marketCreateOrConnectWithoutMarket_groupInput | marketCreateOrConnectWithoutMarket_groupInput[]
    createMany?: marketCreateManyMarket_groupInputEnvelope
    connect?: marketWhereUniqueInput | marketWhereUniqueInput[]
  }

  export type resourceCreateNestedOneWithoutMarket_groupInput = {
    create?: XOR<resourceCreateWithoutMarket_groupInput, resourceUncheckedCreateWithoutMarket_groupInput>
    connectOrCreate?: resourceCreateOrConnectWithoutMarket_groupInput
    connect?: resourceWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutMarket_groupInput = {
    create?: XOR<categoryCreateWithoutMarket_groupInput, categoryUncheckedCreateWithoutMarket_groupInput>
    connectOrCreate?: categoryCreateOrConnectWithoutMarket_groupInput
    connect?: categoryWhereUniqueInput
  }

  export type eventUncheckedCreateNestedManyWithoutMarket_groupInput = {
    create?: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput> | eventCreateWithoutMarket_groupInput[] | eventUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: eventCreateOrConnectWithoutMarket_groupInput | eventCreateOrConnectWithoutMarket_groupInput[]
    createMany?: eventCreateManyMarket_groupInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type marketUncheckedCreateNestedManyWithoutMarket_groupInput = {
    create?: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput> | marketCreateWithoutMarket_groupInput[] | marketUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: marketCreateOrConnectWithoutMarket_groupInput | marketCreateOrConnectWithoutMarket_groupInput[]
    createMany?: marketCreateManyMarket_groupInputEnvelope
    connect?: marketWhereUniqueInput | marketWhereUniqueInput[]
  }

  export type eventUpdateManyWithoutMarket_groupNestedInput = {
    create?: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput> | eventCreateWithoutMarket_groupInput[] | eventUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: eventCreateOrConnectWithoutMarket_groupInput | eventCreateOrConnectWithoutMarket_groupInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutMarket_groupInput | eventUpsertWithWhereUniqueWithoutMarket_groupInput[]
    createMany?: eventCreateManyMarket_groupInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutMarket_groupInput | eventUpdateWithWhereUniqueWithoutMarket_groupInput[]
    updateMany?: eventUpdateManyWithWhereWithoutMarket_groupInput | eventUpdateManyWithWhereWithoutMarket_groupInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type marketUpdateManyWithoutMarket_groupNestedInput = {
    create?: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput> | marketCreateWithoutMarket_groupInput[] | marketUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: marketCreateOrConnectWithoutMarket_groupInput | marketCreateOrConnectWithoutMarket_groupInput[]
    upsert?: marketUpsertWithWhereUniqueWithoutMarket_groupInput | marketUpsertWithWhereUniqueWithoutMarket_groupInput[]
    createMany?: marketCreateManyMarket_groupInputEnvelope
    set?: marketWhereUniqueInput | marketWhereUniqueInput[]
    disconnect?: marketWhereUniqueInput | marketWhereUniqueInput[]
    delete?: marketWhereUniqueInput | marketWhereUniqueInput[]
    connect?: marketWhereUniqueInput | marketWhereUniqueInput[]
    update?: marketUpdateWithWhereUniqueWithoutMarket_groupInput | marketUpdateWithWhereUniqueWithoutMarket_groupInput[]
    updateMany?: marketUpdateManyWithWhereWithoutMarket_groupInput | marketUpdateManyWithWhereWithoutMarket_groupInput[]
    deleteMany?: marketScalarWhereInput | marketScalarWhereInput[]
  }

  export type resourceUpdateOneWithoutMarket_groupNestedInput = {
    create?: XOR<resourceCreateWithoutMarket_groupInput, resourceUncheckedCreateWithoutMarket_groupInput>
    connectOrCreate?: resourceCreateOrConnectWithoutMarket_groupInput
    upsert?: resourceUpsertWithoutMarket_groupInput
    disconnect?: resourceWhereInput | boolean
    delete?: resourceWhereInput | boolean
    connect?: resourceWhereUniqueInput
    update?: XOR<XOR<resourceUpdateToOneWithWhereWithoutMarket_groupInput, resourceUpdateWithoutMarket_groupInput>, resourceUncheckedUpdateWithoutMarket_groupInput>
  }

  export type categoryUpdateOneWithoutMarket_groupNestedInput = {
    create?: XOR<categoryCreateWithoutMarket_groupInput, categoryUncheckedCreateWithoutMarket_groupInput>
    connectOrCreate?: categoryCreateOrConnectWithoutMarket_groupInput
    upsert?: categoryUpsertWithoutMarket_groupInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutMarket_groupInput, categoryUpdateWithoutMarket_groupInput>, categoryUncheckedUpdateWithoutMarket_groupInput>
  }

  export type eventUncheckedUpdateManyWithoutMarket_groupNestedInput = {
    create?: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput> | eventCreateWithoutMarket_groupInput[] | eventUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: eventCreateOrConnectWithoutMarket_groupInput | eventCreateOrConnectWithoutMarket_groupInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutMarket_groupInput | eventUpsertWithWhereUniqueWithoutMarket_groupInput[]
    createMany?: eventCreateManyMarket_groupInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutMarket_groupInput | eventUpdateWithWhereUniqueWithoutMarket_groupInput[]
    updateMany?: eventUpdateManyWithWhereWithoutMarket_groupInput | eventUpdateManyWithWhereWithoutMarket_groupInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type marketUncheckedUpdateManyWithoutMarket_groupNestedInput = {
    create?: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput> | marketCreateWithoutMarket_groupInput[] | marketUncheckedCreateWithoutMarket_groupInput[]
    connectOrCreate?: marketCreateOrConnectWithoutMarket_groupInput | marketCreateOrConnectWithoutMarket_groupInput[]
    upsert?: marketUpsertWithWhereUniqueWithoutMarket_groupInput | marketUpsertWithWhereUniqueWithoutMarket_groupInput[]
    createMany?: marketCreateManyMarket_groupInputEnvelope
    set?: marketWhereUniqueInput | marketWhereUniqueInput[]
    disconnect?: marketWhereUniqueInput | marketWhereUniqueInput[]
    delete?: marketWhereUniqueInput | marketWhereUniqueInput[]
    connect?: marketWhereUniqueInput | marketWhereUniqueInput[]
    update?: marketUpdateWithWhereUniqueWithoutMarket_groupInput | marketUpdateWithWhereUniqueWithoutMarket_groupInput[]
    updateMany?: marketUpdateManyWithWhereWithoutMarket_groupInput | marketUpdateManyWithWhereWithoutMarket_groupInput[]
    deleteMany?: marketScalarWhereInput | marketScalarWhereInput[]
  }

  export type transactionCreateNestedOneWithoutMarket_priceInput = {
    create?: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
    connectOrCreate?: transactionCreateOrConnectWithoutMarket_priceInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUncheckedCreateNestedOneWithoutMarket_priceInput = {
    create?: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
    connectOrCreate?: transactionCreateOrConnectWithoutMarket_priceInput
    connect?: transactionWhereUniqueInput
  }

  export type transactionUpdateOneWithoutMarket_priceNestedInput = {
    create?: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
    connectOrCreate?: transactionCreateOrConnectWithoutMarket_priceInput
    upsert?: transactionUpsertWithoutMarket_priceInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutMarket_priceInput, transactionUpdateWithoutMarket_priceInput>, transactionUncheckedUpdateWithoutMarket_priceInput>
  }

  export type transactionUncheckedUpdateOneWithoutMarket_priceNestedInput = {
    create?: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
    connectOrCreate?: transactionCreateOrConnectWithoutMarket_priceInput
    upsert?: transactionUpsertWithoutMarket_priceInput
    disconnect?: transactionWhereInput | boolean
    delete?: transactionWhereInput | boolean
    connect?: transactionWhereUniqueInput
    update?: XOR<XOR<transactionUpdateToOneWithWhereWithoutMarket_priceInput, transactionUpdateWithoutMarket_priceInput>, transactionUncheckedUpdateWithoutMarket_priceInput>
  }

  export type marketCreateNestedOneWithoutPositionInput = {
    create?: XOR<marketCreateWithoutPositionInput, marketUncheckedCreateWithoutPositionInput>
    connectOrCreate?: marketCreateOrConnectWithoutPositionInput
    connect?: marketWhereUniqueInput
  }

  export type transactionCreateNestedManyWithoutPositionInput = {
    create?: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput> | transactionCreateWithoutPositionInput[] | transactionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPositionInput | transactionCreateOrConnectWithoutPositionInput[]
    createMany?: transactionCreateManyPositionInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput> | transactionCreateWithoutPositionInput[] | transactionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPositionInput | transactionCreateOrConnectWithoutPositionInput[]
    createMany?: transactionCreateManyPositionInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type marketUpdateOneWithoutPositionNestedInput = {
    create?: XOR<marketCreateWithoutPositionInput, marketUncheckedCreateWithoutPositionInput>
    connectOrCreate?: marketCreateOrConnectWithoutPositionInput
    upsert?: marketUpsertWithoutPositionInput
    disconnect?: marketWhereInput | boolean
    delete?: marketWhereInput | boolean
    connect?: marketWhereUniqueInput
    update?: XOR<XOR<marketUpdateToOneWithWhereWithoutPositionInput, marketUpdateWithoutPositionInput>, marketUncheckedUpdateWithoutPositionInput>
  }

  export type transactionUpdateManyWithoutPositionNestedInput = {
    create?: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput> | transactionCreateWithoutPositionInput[] | transactionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPositionInput | transactionCreateOrConnectWithoutPositionInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPositionInput | transactionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: transactionCreateManyPositionInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPositionInput | transactionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPositionInput | transactionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput> | transactionCreateWithoutPositionInput[] | transactionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPositionInput | transactionCreateOrConnectWithoutPositionInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPositionInput | transactionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: transactionCreateManyPositionInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPositionInput | transactionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPositionInput | transactionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type market_groupCreateNestedManyWithoutResourceInput = {
    create?: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput> | market_groupCreateWithoutResourceInput[] | market_groupUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutResourceInput | market_groupCreateOrConnectWithoutResourceInput[]
    createMany?: market_groupCreateManyResourceInputEnvelope
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
  }

  export type categoryCreateNestedOneWithoutResourceInput = {
    create?: XOR<categoryCreateWithoutResourceInput, categoryUncheckedCreateWithoutResourceInput>
    connectOrCreate?: categoryCreateOrConnectWithoutResourceInput
    connect?: categoryWhereUniqueInput
  }

  export type resource_priceCreateNestedManyWithoutResourceInput = {
    create?: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput> | resource_priceCreateWithoutResourceInput[] | resource_priceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: resource_priceCreateOrConnectWithoutResourceInput | resource_priceCreateOrConnectWithoutResourceInput[]
    createMany?: resource_priceCreateManyResourceInputEnvelope
    connect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
  }

  export type market_groupUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput> | market_groupCreateWithoutResourceInput[] | market_groupUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutResourceInput | market_groupCreateOrConnectWithoutResourceInput[]
    createMany?: market_groupCreateManyResourceInputEnvelope
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
  }

  export type resource_priceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput> | resource_priceCreateWithoutResourceInput[] | resource_priceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: resource_priceCreateOrConnectWithoutResourceInput | resource_priceCreateOrConnectWithoutResourceInput[]
    createMany?: resource_priceCreateManyResourceInputEnvelope
    connect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
  }

  export type market_groupUpdateManyWithoutResourceNestedInput = {
    create?: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput> | market_groupCreateWithoutResourceInput[] | market_groupUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutResourceInput | market_groupCreateOrConnectWithoutResourceInput[]
    upsert?: market_groupUpsertWithWhereUniqueWithoutResourceInput | market_groupUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: market_groupCreateManyResourceInputEnvelope
    set?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    disconnect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    delete?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    update?: market_groupUpdateWithWhereUniqueWithoutResourceInput | market_groupUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: market_groupUpdateManyWithWhereWithoutResourceInput | market_groupUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
  }

  export type categoryUpdateOneWithoutResourceNestedInput = {
    create?: XOR<categoryCreateWithoutResourceInput, categoryUncheckedCreateWithoutResourceInput>
    connectOrCreate?: categoryCreateOrConnectWithoutResourceInput
    upsert?: categoryUpsertWithoutResourceInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutResourceInput, categoryUpdateWithoutResourceInput>, categoryUncheckedUpdateWithoutResourceInput>
  }

  export type resource_priceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput> | resource_priceCreateWithoutResourceInput[] | resource_priceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: resource_priceCreateOrConnectWithoutResourceInput | resource_priceCreateOrConnectWithoutResourceInput[]
    upsert?: resource_priceUpsertWithWhereUniqueWithoutResourceInput | resource_priceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: resource_priceCreateManyResourceInputEnvelope
    set?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    disconnect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    delete?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    connect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    update?: resource_priceUpdateWithWhereUniqueWithoutResourceInput | resource_priceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: resource_priceUpdateManyWithWhereWithoutResourceInput | resource_priceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: resource_priceScalarWhereInput | resource_priceScalarWhereInput[]
  }

  export type market_groupUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput> | market_groupCreateWithoutResourceInput[] | market_groupUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: market_groupCreateOrConnectWithoutResourceInput | market_groupCreateOrConnectWithoutResourceInput[]
    upsert?: market_groupUpsertWithWhereUniqueWithoutResourceInput | market_groupUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: market_groupCreateManyResourceInputEnvelope
    set?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    disconnect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    delete?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    connect?: market_groupWhereUniqueInput | market_groupWhereUniqueInput[]
    update?: market_groupUpdateWithWhereUniqueWithoutResourceInput | market_groupUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: market_groupUpdateManyWithWhereWithoutResourceInput | market_groupUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
  }

  export type resource_priceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput> | resource_priceCreateWithoutResourceInput[] | resource_priceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: resource_priceCreateOrConnectWithoutResourceInput | resource_priceCreateOrConnectWithoutResourceInput[]
    upsert?: resource_priceUpsertWithWhereUniqueWithoutResourceInput | resource_priceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: resource_priceCreateManyResourceInputEnvelope
    set?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    disconnect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    delete?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    connect?: resource_priceWhereUniqueInput | resource_priceWhereUniqueInput[]
    update?: resource_priceUpdateWithWhereUniqueWithoutResourceInput | resource_priceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: resource_priceUpdateManyWithWhereWithoutResourceInput | resource_priceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: resource_priceScalarWhereInput | resource_priceScalarWhereInput[]
  }

  export type resourceCreateNestedOneWithoutResource_priceInput = {
    create?: XOR<resourceCreateWithoutResource_priceInput, resourceUncheckedCreateWithoutResource_priceInput>
    connectOrCreate?: resourceCreateOrConnectWithoutResource_priceInput
    connect?: resourceWhereUniqueInput
  }

  export type resourceUpdateOneWithoutResource_priceNestedInput = {
    create?: XOR<resourceCreateWithoutResource_priceInput, resourceUncheckedCreateWithoutResource_priceInput>
    connectOrCreate?: resourceCreateOrConnectWithoutResource_priceInput
    upsert?: resourceUpsertWithoutResource_priceInput
    disconnect?: resourceWhereInput | boolean
    delete?: resourceWhereInput | boolean
    connect?: resourceWhereUniqueInput
    update?: XOR<XOR<resourceUpdateToOneWithWhereWithoutResource_priceInput, resourceUpdateWithoutResource_priceInput>, resourceUncheckedUpdateWithoutResource_priceInput>
  }

  export type collateral_transferCreateNestedOneWithoutTransactionInput = {
    create?: XOR<collateral_transferCreateWithoutTransactionInput, collateral_transferUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: collateral_transferCreateOrConnectWithoutTransactionInput
    connect?: collateral_transferWhereUniqueInput
  }

  export type market_priceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<market_priceCreateWithoutTransactionInput, market_priceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: market_priceCreateOrConnectWithoutTransactionInput
    connect?: market_priceWhereUniqueInput
  }

  export type eventCreateNestedOneWithoutTransactionInput = {
    create?: XOR<eventCreateWithoutTransactionInput, eventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: eventCreateOrConnectWithoutTransactionInput
    connect?: eventWhereUniqueInput
  }

  export type positionCreateNestedOneWithoutTransactionInput = {
    create?: XOR<positionCreateWithoutTransactionInput, positionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: positionCreateOrConnectWithoutTransactionInput
    connect?: positionWhereUniqueInput
  }

  export type Enumtransaction_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.transaction_type_enum
  }

  export type collateral_transferUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<collateral_transferCreateWithoutTransactionInput, collateral_transferUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: collateral_transferCreateOrConnectWithoutTransactionInput
    upsert?: collateral_transferUpsertWithoutTransactionInput
    disconnect?: collateral_transferWhereInput | boolean
    delete?: collateral_transferWhereInput | boolean
    connect?: collateral_transferWhereUniqueInput
    update?: XOR<XOR<collateral_transferUpdateToOneWithWhereWithoutTransactionInput, collateral_transferUpdateWithoutTransactionInput>, collateral_transferUncheckedUpdateWithoutTransactionInput>
  }

  export type market_priceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<market_priceCreateWithoutTransactionInput, market_priceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: market_priceCreateOrConnectWithoutTransactionInput
    upsert?: market_priceUpsertWithoutTransactionInput
    disconnect?: market_priceWhereInput | boolean
    delete?: market_priceWhereInput | boolean
    connect?: market_priceWhereUniqueInput
    update?: XOR<XOR<market_priceUpdateToOneWithWhereWithoutTransactionInput, market_priceUpdateWithoutTransactionInput>, market_priceUncheckedUpdateWithoutTransactionInput>
  }

  export type eventUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<eventCreateWithoutTransactionInput, eventUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: eventCreateOrConnectWithoutTransactionInput
    upsert?: eventUpsertWithoutTransactionInput
    disconnect?: eventWhereInput | boolean
    delete?: eventWhereInput | boolean
    connect?: eventWhereUniqueInput
    update?: XOR<XOR<eventUpdateToOneWithWhereWithoutTransactionInput, eventUpdateWithoutTransactionInput>, eventUncheckedUpdateWithoutTransactionInput>
  }

  export type positionUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<positionCreateWithoutTransactionInput, positionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: positionCreateOrConnectWithoutTransactionInput
    upsert?: positionUpsertWithoutTransactionInput
    disconnect?: positionWhereInput | boolean
    delete?: positionWhereInput | boolean
    connect?: positionWhereUniqueInput
    update?: XOR<XOR<positionUpdateToOneWithWhereWithoutTransactionInput, positionUpdateWithoutTransactionInput>, positionUncheckedUpdateWithoutTransactionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumtransaction_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.transaction_type_enum | Enumtransaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumtransaction_type_enumFilter<$PrismaModel> | $Enums.transaction_type_enum
  }

  export type NestedEnumtransaction_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transaction_type_enum | Enumtransaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.transaction_type_enum[] | ListEnumtransaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumtransaction_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.transaction_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransaction_type_enumFilter<$PrismaModel>
    _max?: NestedEnumtransaction_type_enumFilter<$PrismaModel>
  }

  export type market_groupCreateWithoutCategoryInput = {
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventCreateNestedManyWithoutMarket_groupInput
    market?: marketCreateNestedManyWithoutMarket_groupInput
    resource?: resourceCreateNestedOneWithoutMarket_groupInput
  }

  export type market_groupUncheckedCreateWithoutCategoryInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedCreateNestedManyWithoutMarket_groupInput
    market?: marketUncheckedCreateNestedManyWithoutMarket_groupInput
  }

  export type market_groupCreateOrConnectWithoutCategoryInput = {
    where: market_groupWhereUniqueInput
    create: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput>
  }

  export type market_groupCreateManyCategoryInputEnvelope = {
    data: market_groupCreateManyCategoryInput | market_groupCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type resourceCreateWithoutCategoryInput = {
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupCreateNestedManyWithoutResourceInput
    resource_price?: resource_priceCreateNestedManyWithoutResourceInput
  }

  export type resourceUncheckedCreateWithoutCategoryInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupUncheckedCreateNestedManyWithoutResourceInput
    resource_price?: resource_priceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type resourceCreateOrConnectWithoutCategoryInput = {
    where: resourceWhereUniqueInput
    create: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput>
  }

  export type resourceCreateManyCategoryInputEnvelope = {
    data: resourceCreateManyCategoryInput | resourceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type market_groupUpsertWithWhereUniqueWithoutCategoryInput = {
    where: market_groupWhereUniqueInput
    update: XOR<market_groupUpdateWithoutCategoryInput, market_groupUncheckedUpdateWithoutCategoryInput>
    create: XOR<market_groupCreateWithoutCategoryInput, market_groupUncheckedCreateWithoutCategoryInput>
  }

  export type market_groupUpdateWithWhereUniqueWithoutCategoryInput = {
    where: market_groupWhereUniqueInput
    data: XOR<market_groupUpdateWithoutCategoryInput, market_groupUncheckedUpdateWithoutCategoryInput>
  }

  export type market_groupUpdateManyWithWhereWithoutCategoryInput = {
    where: market_groupScalarWhereInput
    data: XOR<market_groupUpdateManyMutationInput, market_groupUncheckedUpdateManyWithoutCategoryInput>
  }

  export type market_groupScalarWhereInput = {
    AND?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
    OR?: market_groupScalarWhereInput[]
    NOT?: market_groupScalarWhereInput | market_groupScalarWhereInput[]
    id?: IntFilter<"market_group"> | number
    createdAt?: DateTimeFilter<"market_group"> | Date | string
    address?: StringNullableFilter<"market_group"> | string | null
    vaultAddress?: StringNullableFilter<"market_group"> | string | null
    isYin?: BoolFilter<"market_group"> | boolean
    chainId?: IntFilter<"market_group"> | number
    deployTimestamp?: IntNullableFilter<"market_group"> | number | null
    deployTxnBlockNumber?: IntNullableFilter<"market_group"> | number | null
    owner?: StringNullableFilter<"market_group"> | string | null
    collateralAsset?: StringNullableFilter<"market_group"> | string | null
    resourceId?: IntNullableFilter<"market_group"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market_group"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market_group"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market_group"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market_group"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market_group"> | string | null
    isCumulative?: BoolFilter<"market_group"> | boolean
    categoryId?: IntNullableFilter<"market_group"> | number | null
    question?: StringNullableFilter<"market_group"> | string | null
    baseTokenName?: StringNullableFilter<"market_group"> | string | null
    quoteTokenName?: StringNullableFilter<"market_group"> | string | null
    collateralDecimals?: IntNullableFilter<"market_group"> | number | null
    collateralSymbol?: StringNullableFilter<"market_group"> | string | null
    initializationNonce?: StringNullableFilter<"market_group"> | string | null
    factoryAddress?: StringNullableFilter<"market_group"> | string | null
    minTradeSize?: DecimalNullableFilter<"market_group"> | Decimal | DecimalJsLike | number | string | null
  }

  export type resourceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: resourceWhereUniqueInput
    update: XOR<resourceUpdateWithoutCategoryInput, resourceUncheckedUpdateWithoutCategoryInput>
    create: XOR<resourceCreateWithoutCategoryInput, resourceUncheckedCreateWithoutCategoryInput>
  }

  export type resourceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: resourceWhereUniqueInput
    data: XOR<resourceUpdateWithoutCategoryInput, resourceUncheckedUpdateWithoutCategoryInput>
  }

  export type resourceUpdateManyWithWhereWithoutCategoryInput = {
    where: resourceScalarWhereInput
    data: XOR<resourceUpdateManyMutationInput, resourceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type resourceScalarWhereInput = {
    AND?: resourceScalarWhereInput | resourceScalarWhereInput[]
    OR?: resourceScalarWhereInput[]
    NOT?: resourceScalarWhereInput | resourceScalarWhereInput[]
    id?: IntFilter<"resource"> | number
    createdAt?: DateTimeFilter<"resource"> | Date | string
    name?: StringFilter<"resource"> | string
    slug?: StringFilter<"resource"> | string
    categoryId?: IntNullableFilter<"resource"> | number | null
  }

  export type transactionCreateWithoutCollateral_transferInput = {
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    market_price?: market_priceCreateNestedOneWithoutTransactionInput
    event?: eventCreateNestedOneWithoutTransactionInput
    position?: positionCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutCollateral_transferInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    positionId?: number | null
    marketPriceId?: number | null
  }

  export type transactionCreateOrConnectWithoutCollateral_transferInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
  }

  export type transactionUpsertWithoutCollateral_transferInput = {
    update: XOR<transactionUpdateWithoutCollateral_transferInput, transactionUncheckedUpdateWithoutCollateral_transferInput>
    create: XOR<transactionCreateWithoutCollateral_transferInput, transactionUncheckedCreateWithoutCollateral_transferInput>
    where?: transactionWhereInput
  }

  export type transactionUpdateToOneWithWhereWithoutCollateral_transferInput = {
    where?: transactionWhereInput
    data: XOR<transactionUpdateWithoutCollateral_transferInput, transactionUncheckedUpdateWithoutCollateral_transferInput>
  }

  export type transactionUpdateWithoutCollateral_transferInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    market_price?: market_priceUpdateOneWithoutTransactionNestedInput
    event?: eventUpdateOneWithoutTransactionNestedInput
    position?: positionUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutCollateral_transferInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_groupCreateWithoutEventInput = {
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    market?: marketCreateNestedManyWithoutMarket_groupInput
    resource?: resourceCreateNestedOneWithoutMarket_groupInput
    category?: categoryCreateNestedOneWithoutMarket_groupInput
  }

  export type market_groupUncheckedCreateWithoutEventInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    market?: marketUncheckedCreateNestedManyWithoutMarket_groupInput
  }

  export type market_groupCreateOrConnectWithoutEventInput = {
    where: market_groupWhereUniqueInput
    create: XOR<market_groupCreateWithoutEventInput, market_groupUncheckedCreateWithoutEventInput>
  }

  export type transactionCreateWithoutEventInput = {
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferCreateNestedOneWithoutTransactionInput
    market_price?: market_priceCreateNestedOneWithoutTransactionInput
    position?: positionCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutEventInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    positionId?: number | null
    marketPriceId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionCreateOrConnectWithoutEventInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
  }

  export type market_groupUpsertWithoutEventInput = {
    update: XOR<market_groupUpdateWithoutEventInput, market_groupUncheckedUpdateWithoutEventInput>
    create: XOR<market_groupCreateWithoutEventInput, market_groupUncheckedCreateWithoutEventInput>
    where?: market_groupWhereInput
  }

  export type market_groupUpdateToOneWithWhereWithoutEventInput = {
    where?: market_groupWhereInput
    data: XOR<market_groupUpdateWithoutEventInput, market_groupUncheckedUpdateWithoutEventInput>
  }

  export type market_groupUpdateWithoutEventInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    market?: marketUpdateManyWithoutMarket_groupNestedInput
    resource?: resourceUpdateOneWithoutMarket_groupNestedInput
    category?: categoryUpdateOneWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    market?: marketUncheckedUpdateManyWithoutMarket_groupNestedInput
  }

  export type transactionUpsertWithoutEventInput = {
    update: XOR<transactionUpdateWithoutEventInput, transactionUncheckedUpdateWithoutEventInput>
    create: XOR<transactionCreateWithoutEventInput, transactionUncheckedCreateWithoutEventInput>
    where?: transactionWhereInput
  }

  export type transactionUpdateToOneWithWhereWithoutEventInput = {
    where?: transactionWhereInput
    data: XOR<transactionUpdateWithoutEventInput, transactionUncheckedUpdateWithoutEventInput>
  }

  export type transactionUpdateWithoutEventInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferUpdateOneWithoutTransactionNestedInput
    market_price?: market_priceUpdateOneWithoutTransactionNestedInput
    position?: positionUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_groupCreateWithoutMarketInput = {
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventCreateNestedManyWithoutMarket_groupInput
    resource?: resourceCreateNestedOneWithoutMarket_groupInput
    category?: categoryCreateNestedOneWithoutMarket_groupInput
  }

  export type market_groupUncheckedCreateWithoutMarketInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedCreateNestedManyWithoutMarket_groupInput
  }

  export type market_groupCreateOrConnectWithoutMarketInput = {
    where: market_groupWhereUniqueInput
    create: XOR<market_groupCreateWithoutMarketInput, market_groupUncheckedCreateWithoutMarketInput>
  }

  export type positionCreateWithoutMarketInput = {
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    transaction?: transactionCreateNestedManyWithoutPositionInput
  }

  export type positionUncheckedCreateWithoutMarketInput = {
    id?: number
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type positionCreateOrConnectWithoutMarketInput = {
    where: positionWhereUniqueInput
    create: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput>
  }

  export type positionCreateManyMarketInputEnvelope = {
    data: positionCreateManyMarketInput | positionCreateManyMarketInput[]
    skipDuplicates?: boolean
  }

  export type market_groupUpsertWithoutMarketInput = {
    update: XOR<market_groupUpdateWithoutMarketInput, market_groupUncheckedUpdateWithoutMarketInput>
    create: XOR<market_groupCreateWithoutMarketInput, market_groupUncheckedCreateWithoutMarketInput>
    where?: market_groupWhereInput
  }

  export type market_groupUpdateToOneWithWhereWithoutMarketInput = {
    where?: market_groupWhereInput
    data: XOR<market_groupUpdateWithoutMarketInput, market_groupUncheckedUpdateWithoutMarketInput>
  }

  export type market_groupUpdateWithoutMarketInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUpdateManyWithoutMarket_groupNestedInput
    resource?: resourceUpdateOneWithoutMarket_groupNestedInput
    category?: categoryUpdateOneWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateWithoutMarketInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedUpdateManyWithoutMarket_groupNestedInput
  }

  export type positionUpsertWithWhereUniqueWithoutMarketInput = {
    where: positionWhereUniqueInput
    update: XOR<positionUpdateWithoutMarketInput, positionUncheckedUpdateWithoutMarketInput>
    create: XOR<positionCreateWithoutMarketInput, positionUncheckedCreateWithoutMarketInput>
  }

  export type positionUpdateWithWhereUniqueWithoutMarketInput = {
    where: positionWhereUniqueInput
    data: XOR<positionUpdateWithoutMarketInput, positionUncheckedUpdateWithoutMarketInput>
  }

  export type positionUpdateManyWithWhereWithoutMarketInput = {
    where: positionScalarWhereInput
    data: XOR<positionUpdateManyMutationInput, positionUncheckedUpdateManyWithoutMarketInput>
  }

  export type positionScalarWhereInput = {
    AND?: positionScalarWhereInput | positionScalarWhereInput[]
    OR?: positionScalarWhereInput[]
    NOT?: positionScalarWhereInput | positionScalarWhereInput[]
    id?: IntFilter<"position"> | number
    createdAt?: DateTimeFilter<"position"> | Date | string
    positionId?: IntFilter<"position"> | number
    owner?: StringNullableFilter<"position"> | string | null
    isLP?: BoolFilter<"position"> | boolean
    highPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    isSettled?: BoolNullableFilter<"position"> | boolean | null
    lpBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    baseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"position"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"position"> | Decimal | DecimalJsLike | number | string
    marketId?: IntNullableFilter<"position"> | number | null
  }

  export type eventCreateWithoutMarket_groupInput = {
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    transaction?: transactionCreateNestedOneWithoutEventInput
  }

  export type eventUncheckedCreateWithoutMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    transaction?: transactionUncheckedCreateNestedOneWithoutEventInput
  }

  export type eventCreateOrConnectWithoutMarket_groupInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput>
  }

  export type eventCreateManyMarket_groupInputEnvelope = {
    data: eventCreateManyMarket_groupInput | eventCreateManyMarket_groupInput[]
    skipDuplicates?: boolean
  }

  export type marketCreateWithoutMarket_groupInput = {
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
    position?: positionCreateNestedManyWithoutMarketInput
  }

  export type marketUncheckedCreateWithoutMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
    position?: positionUncheckedCreateNestedManyWithoutMarketInput
  }

  export type marketCreateOrConnectWithoutMarket_groupInput = {
    where: marketWhereUniqueInput
    create: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput>
  }

  export type marketCreateManyMarket_groupInputEnvelope = {
    data: marketCreateManyMarket_groupInput | marketCreateManyMarket_groupInput[]
    skipDuplicates?: boolean
  }

  export type resourceCreateWithoutMarket_groupInput = {
    createdAt?: Date | string
    name: string
    slug: string
    category?: categoryCreateNestedOneWithoutResourceInput
    resource_price?: resource_priceCreateNestedManyWithoutResourceInput
  }

  export type resourceUncheckedCreateWithoutMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    categoryId?: number | null
    resource_price?: resource_priceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type resourceCreateOrConnectWithoutMarket_groupInput = {
    where: resourceWhereUniqueInput
    create: XOR<resourceCreateWithoutMarket_groupInput, resourceUncheckedCreateWithoutMarket_groupInput>
  }

  export type categoryCreateWithoutMarket_groupInput = {
    createdAt?: Date | string
    name: string
    slug: string
    resource?: resourceCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    resource?: resourceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutMarket_groupInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutMarket_groupInput, categoryUncheckedCreateWithoutMarket_groupInput>
  }

  export type eventUpsertWithWhereUniqueWithoutMarket_groupInput = {
    where: eventWhereUniqueInput
    update: XOR<eventUpdateWithoutMarket_groupInput, eventUncheckedUpdateWithoutMarket_groupInput>
    create: XOR<eventCreateWithoutMarket_groupInput, eventUncheckedCreateWithoutMarket_groupInput>
  }

  export type eventUpdateWithWhereUniqueWithoutMarket_groupInput = {
    where: eventWhereUniqueInput
    data: XOR<eventUpdateWithoutMarket_groupInput, eventUncheckedUpdateWithoutMarket_groupInput>
  }

  export type eventUpdateManyWithWhereWithoutMarket_groupInput = {
    where: eventScalarWhereInput
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyWithoutMarket_groupInput>
  }

  export type eventScalarWhereInput = {
    AND?: eventScalarWhereInput | eventScalarWhereInput[]
    OR?: eventScalarWhereInput[]
    NOT?: eventScalarWhereInput | eventScalarWhereInput[]
    id?: IntFilter<"event"> | number
    createdAt?: DateTimeFilter<"event"> | Date | string
    blockNumber?: IntFilter<"event"> | number
    transactionHash?: StringFilter<"event"> | string
    timestamp?: BigIntFilter<"event"> | bigint | number
    logIndex?: IntFilter<"event"> | number
    logData?: JsonFilter<"event">
    marketGroupId?: IntNullableFilter<"event"> | number | null
  }

  export type marketUpsertWithWhereUniqueWithoutMarket_groupInput = {
    where: marketWhereUniqueInput
    update: XOR<marketUpdateWithoutMarket_groupInput, marketUncheckedUpdateWithoutMarket_groupInput>
    create: XOR<marketCreateWithoutMarket_groupInput, marketUncheckedCreateWithoutMarket_groupInput>
  }

  export type marketUpdateWithWhereUniqueWithoutMarket_groupInput = {
    where: marketWhereUniqueInput
    data: XOR<marketUpdateWithoutMarket_groupInput, marketUncheckedUpdateWithoutMarket_groupInput>
  }

  export type marketUpdateManyWithWhereWithoutMarket_groupInput = {
    where: marketScalarWhereInput
    data: XOR<marketUpdateManyMutationInput, marketUncheckedUpdateManyWithoutMarket_groupInput>
  }

  export type marketScalarWhereInput = {
    AND?: marketScalarWhereInput | marketScalarWhereInput[]
    OR?: marketScalarWhereInput[]
    NOT?: marketScalarWhereInput | marketScalarWhereInput[]
    id?: IntFilter<"market"> | number
    createdAt?: DateTimeFilter<"market"> | Date | string
    marketId?: IntFilter<"market"> | number
    startTimestamp?: IntNullableFilter<"market"> | number | null
    endTimestamp?: IntNullableFilter<"market"> | number | null
    startingSqrtPriceX96?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    settled?: BoolNullableFilter<"market"> | boolean | null
    baseAssetMinPriceTick?: IntNullableFilter<"market"> | number | null
    baseAssetMaxPriceTick?: IntNullableFilter<"market"> | number | null
    minPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: IntNullableFilter<"market"> | number | null
    marketParamsFeerate?: IntNullableFilter<"market"> | number | null
    marketParamsAssertionliveness?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: StringNullableFilter<"market"> | string | null
    marketParamsBondamount?: DecimalNullableFilter<"market"> | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: StringNullableFilter<"market"> | string | null
    marketParamsUniswappositionmanager?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapswaprouter?: StringNullableFilter<"market"> | string | null
    marketParamsUniswapquoter?: StringNullableFilter<"market"> | string | null
    marketParamsOptimisticoraclev3?: StringNullableFilter<"market"> | string | null
    public?: BoolFilter<"market"> | boolean
    question?: StringNullableFilter<"market"> | string | null
    poolAddress?: StringNullableFilter<"market"> | string | null
    optionName?: StringNullableFilter<"market"> | string | null
    rules?: StringNullableFilter<"market"> | string | null
  }

  export type resourceUpsertWithoutMarket_groupInput = {
    update: XOR<resourceUpdateWithoutMarket_groupInput, resourceUncheckedUpdateWithoutMarket_groupInput>
    create: XOR<resourceCreateWithoutMarket_groupInput, resourceUncheckedCreateWithoutMarket_groupInput>
    where?: resourceWhereInput
  }

  export type resourceUpdateToOneWithWhereWithoutMarket_groupInput = {
    where?: resourceWhereInput
    data: XOR<resourceUpdateWithoutMarket_groupInput, resourceUncheckedUpdateWithoutMarket_groupInput>
  }

  export type resourceUpdateWithoutMarket_groupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: categoryUpdateOneWithoutResourceNestedInput
    resource_price?: resource_priceUpdateManyWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    resource_price?: resource_priceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type categoryUpsertWithoutMarket_groupInput = {
    update: XOR<categoryUpdateWithoutMarket_groupInput, categoryUncheckedUpdateWithoutMarket_groupInput>
    create: XOR<categoryCreateWithoutMarket_groupInput, categoryUncheckedCreateWithoutMarket_groupInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutMarket_groupInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutMarket_groupInput, categoryUncheckedUpdateWithoutMarket_groupInput>
  }

  export type categoryUpdateWithoutMarket_groupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    resource?: resourceUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    resource?: resourceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type transactionCreateWithoutMarket_priceInput = {
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferCreateNestedOneWithoutTransactionInput
    event?: eventCreateNestedOneWithoutTransactionInput
    position?: positionCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutMarket_priceInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    positionId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionCreateOrConnectWithoutMarket_priceInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
  }

  export type transactionUpsertWithoutMarket_priceInput = {
    update: XOR<transactionUpdateWithoutMarket_priceInput, transactionUncheckedUpdateWithoutMarket_priceInput>
    create: XOR<transactionCreateWithoutMarket_priceInput, transactionUncheckedCreateWithoutMarket_priceInput>
    where?: transactionWhereInput
  }

  export type transactionUpdateToOneWithWhereWithoutMarket_priceInput = {
    where?: transactionWhereInput
    data: XOR<transactionUpdateWithoutMarket_priceInput, transactionUncheckedUpdateWithoutMarket_priceInput>
  }

  export type transactionUpdateWithoutMarket_priceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferUpdateOneWithoutTransactionNestedInput
    event?: eventUpdateOneWithoutTransactionNestedInput
    position?: positionUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutMarket_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type marketCreateWithoutPositionInput = {
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
    market_group?: market_groupCreateNestedOneWithoutMarketInput
  }

  export type marketUncheckedCreateWithoutPositionInput = {
    id?: number
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketGroupId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
  }

  export type marketCreateOrConnectWithoutPositionInput = {
    where: marketWhereUniqueInput
    create: XOR<marketCreateWithoutPositionInput, marketUncheckedCreateWithoutPositionInput>
  }

  export type transactionCreateWithoutPositionInput = {
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferCreateNestedOneWithoutTransactionInput
    market_price?: market_priceCreateNestedOneWithoutTransactionInput
    event?: eventCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutPositionInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    marketPriceId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionCreateOrConnectWithoutPositionInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput>
  }

  export type transactionCreateManyPositionInputEnvelope = {
    data: transactionCreateManyPositionInput | transactionCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type marketUpsertWithoutPositionInput = {
    update: XOR<marketUpdateWithoutPositionInput, marketUncheckedUpdateWithoutPositionInput>
    create: XOR<marketCreateWithoutPositionInput, marketUncheckedCreateWithoutPositionInput>
    where?: marketWhereInput
  }

  export type marketUpdateToOneWithWhereWithoutPositionInput = {
    where?: marketWhereInput
    data: XOR<marketUpdateWithoutPositionInput, marketUncheckedUpdateWithoutPositionInput>
  }

  export type marketUpdateWithoutPositionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    market_group?: market_groupUpdateOneWithoutMarketNestedInput
  }

  export type marketUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionUpsertWithWhereUniqueWithoutPositionInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutPositionInput, transactionUncheckedUpdateWithoutPositionInput>
    create: XOR<transactionCreateWithoutPositionInput, transactionUncheckedCreateWithoutPositionInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutPositionInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutPositionInput, transactionUncheckedUpdateWithoutPositionInput>
  }

  export type transactionUpdateManyWithWhereWithoutPositionInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutPositionInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    id?: IntFilter<"transaction"> | number
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    tradeRatioD18?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFilter<"transaction"> | $Enums.transaction_type_enum
    baseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    quoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: DecimalNullableFilter<"transaction"> | Decimal | DecimalJsLike | number | string | null
    eventId?: IntNullableFilter<"transaction"> | number | null
    positionId?: IntNullableFilter<"transaction"> | number | null
    marketPriceId?: IntNullableFilter<"transaction"> | number | null
    collateralTransferId?: IntNullableFilter<"transaction"> | number | null
  }

  export type market_groupCreateWithoutResourceInput = {
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventCreateNestedManyWithoutMarket_groupInput
    market?: marketCreateNestedManyWithoutMarket_groupInput
    category?: categoryCreateNestedOneWithoutMarket_groupInput
  }

  export type market_groupUncheckedCreateWithoutResourceInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedCreateNestedManyWithoutMarket_groupInput
    market?: marketUncheckedCreateNestedManyWithoutMarket_groupInput
  }

  export type market_groupCreateOrConnectWithoutResourceInput = {
    where: market_groupWhereUniqueInput
    create: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput>
  }

  export type market_groupCreateManyResourceInputEnvelope = {
    data: market_groupCreateManyResourceInput | market_groupCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutResourceInput = {
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutResourceInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutResourceInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutResourceInput, categoryUncheckedCreateWithoutResourceInput>
  }

  export type resource_priceCreateWithoutResourceInput = {
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
  }

  export type resource_priceUncheckedCreateWithoutResourceInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
  }

  export type resource_priceCreateOrConnectWithoutResourceInput = {
    where: resource_priceWhereUniqueInput
    create: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput>
  }

  export type resource_priceCreateManyResourceInputEnvelope = {
    data: resource_priceCreateManyResourceInput | resource_priceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type market_groupUpsertWithWhereUniqueWithoutResourceInput = {
    where: market_groupWhereUniqueInput
    update: XOR<market_groupUpdateWithoutResourceInput, market_groupUncheckedUpdateWithoutResourceInput>
    create: XOR<market_groupCreateWithoutResourceInput, market_groupUncheckedCreateWithoutResourceInput>
  }

  export type market_groupUpdateWithWhereUniqueWithoutResourceInput = {
    where: market_groupWhereUniqueInput
    data: XOR<market_groupUpdateWithoutResourceInput, market_groupUncheckedUpdateWithoutResourceInput>
  }

  export type market_groupUpdateManyWithWhereWithoutResourceInput = {
    where: market_groupScalarWhereInput
    data: XOR<market_groupUpdateManyMutationInput, market_groupUncheckedUpdateManyWithoutResourceInput>
  }

  export type categoryUpsertWithoutResourceInput = {
    update: XOR<categoryUpdateWithoutResourceInput, categoryUncheckedUpdateWithoutResourceInput>
    create: XOR<categoryCreateWithoutResourceInput, categoryUncheckedCreateWithoutResourceInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutResourceInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutResourceInput, categoryUncheckedUpdateWithoutResourceInput>
  }

  export type categoryUpdateWithoutResourceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type resource_priceUpsertWithWhereUniqueWithoutResourceInput = {
    where: resource_priceWhereUniqueInput
    update: XOR<resource_priceUpdateWithoutResourceInput, resource_priceUncheckedUpdateWithoutResourceInput>
    create: XOR<resource_priceCreateWithoutResourceInput, resource_priceUncheckedCreateWithoutResourceInput>
  }

  export type resource_priceUpdateWithWhereUniqueWithoutResourceInput = {
    where: resource_priceWhereUniqueInput
    data: XOR<resource_priceUpdateWithoutResourceInput, resource_priceUncheckedUpdateWithoutResourceInput>
  }

  export type resource_priceUpdateManyWithWhereWithoutResourceInput = {
    where: resource_priceScalarWhereInput
    data: XOR<resource_priceUpdateManyMutationInput, resource_priceUncheckedUpdateManyWithoutResourceInput>
  }

  export type resource_priceScalarWhereInput = {
    AND?: resource_priceScalarWhereInput | resource_priceScalarWhereInput[]
    OR?: resource_priceScalarWhereInput[]
    NOT?: resource_priceScalarWhereInput | resource_priceScalarWhereInput[]
    id?: IntFilter<"resource_price"> | number
    createdAt?: DateTimeFilter<"resource_price"> | Date | string
    blockNumber?: IntFilter<"resource_price"> | number
    timestamp?: IntFilter<"resource_price"> | number
    value?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    used?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFilter<"resource_price"> | Decimal | DecimalJsLike | number | string
    resourceId?: IntNullableFilter<"resource_price"> | number | null
  }

  export type resourceCreateWithoutResource_priceInput = {
    createdAt?: Date | string
    name: string
    slug: string
    market_group?: market_groupCreateNestedManyWithoutResourceInput
    category?: categoryCreateNestedOneWithoutResourceInput
  }

  export type resourceUncheckedCreateWithoutResource_priceInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
    categoryId?: number | null
    market_group?: market_groupUncheckedCreateNestedManyWithoutResourceInput
  }

  export type resourceCreateOrConnectWithoutResource_priceInput = {
    where: resourceWhereUniqueInput
    create: XOR<resourceCreateWithoutResource_priceInput, resourceUncheckedCreateWithoutResource_priceInput>
  }

  export type resourceUpsertWithoutResource_priceInput = {
    update: XOR<resourceUpdateWithoutResource_priceInput, resourceUncheckedUpdateWithoutResource_priceInput>
    create: XOR<resourceCreateWithoutResource_priceInput, resourceUncheckedCreateWithoutResource_priceInput>
    where?: resourceWhereInput
  }

  export type resourceUpdateToOneWithWhereWithoutResource_priceInput = {
    where?: resourceWhereInput
    data: XOR<resourceUpdateWithoutResource_priceInput, resourceUncheckedUpdateWithoutResource_priceInput>
  }

  export type resourceUpdateWithoutResource_priceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUpdateManyWithoutResourceNestedInput
    category?: categoryUpdateOneWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateWithoutResource_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    market_group?: market_groupUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type collateral_transferCreateWithoutTransactionInput = {
    createdAt?: Date | string
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal | DecimalJsLike | number | string
  }

  export type collateral_transferUncheckedCreateWithoutTransactionInput = {
    id?: number
    createdAt?: Date | string
    transactionHash: string
    timestamp: number
    owner: string
    collateral: Decimal | DecimalJsLike | number | string
  }

  export type collateral_transferCreateOrConnectWithoutTransactionInput = {
    where: collateral_transferWhereUniqueInput
    create: XOR<collateral_transferCreateWithoutTransactionInput, collateral_transferUncheckedCreateWithoutTransactionInput>
  }

  export type market_priceCreateWithoutTransactionInput = {
    createdAt?: Date | string
    timestamp: bigint | number
    value: Decimal | DecimalJsLike | number | string
  }

  export type market_priceUncheckedCreateWithoutTransactionInput = {
    id?: number
    createdAt?: Date | string
    timestamp: bigint | number
    value: Decimal | DecimalJsLike | number | string
  }

  export type market_priceCreateOrConnectWithoutTransactionInput = {
    where: market_priceWhereUniqueInput
    create: XOR<market_priceCreateWithoutTransactionInput, market_priceUncheckedCreateWithoutTransactionInput>
  }

  export type eventCreateWithoutTransactionInput = {
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    market_group?: market_groupCreateNestedOneWithoutEventInput
  }

  export type eventUncheckedCreateWithoutTransactionInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
    marketGroupId?: number | null
  }

  export type eventCreateOrConnectWithoutTransactionInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutTransactionInput, eventUncheckedCreateWithoutTransactionInput>
  }

  export type positionCreateWithoutTransactionInput = {
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    market?: marketCreateNestedOneWithoutPositionInput
  }

  export type positionUncheckedCreateWithoutTransactionInput = {
    id?: number
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    marketId?: number | null
  }

  export type positionCreateOrConnectWithoutTransactionInput = {
    where: positionWhereUniqueInput
    create: XOR<positionCreateWithoutTransactionInput, positionUncheckedCreateWithoutTransactionInput>
  }

  export type collateral_transferUpsertWithoutTransactionInput = {
    update: XOR<collateral_transferUpdateWithoutTransactionInput, collateral_transferUncheckedUpdateWithoutTransactionInput>
    create: XOR<collateral_transferCreateWithoutTransactionInput, collateral_transferUncheckedCreateWithoutTransactionInput>
    where?: collateral_transferWhereInput
  }

  export type collateral_transferUpdateToOneWithWhereWithoutTransactionInput = {
    where?: collateral_transferWhereInput
    data: XOR<collateral_transferUpdateWithoutTransactionInput, collateral_transferUncheckedUpdateWithoutTransactionInput>
  }

  export type collateral_transferUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type collateral_transferUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type market_priceUpsertWithoutTransactionInput = {
    update: XOR<market_priceUpdateWithoutTransactionInput, market_priceUncheckedUpdateWithoutTransactionInput>
    create: XOR<market_priceCreateWithoutTransactionInput, market_priceUncheckedCreateWithoutTransactionInput>
    where?: market_priceWhereInput
  }

  export type market_priceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: market_priceWhereInput
    data: XOR<market_priceUpdateWithoutTransactionInput, market_priceUncheckedUpdateWithoutTransactionInput>
  }

  export type market_priceUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type market_priceUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type eventUpsertWithoutTransactionInput = {
    update: XOR<eventUpdateWithoutTransactionInput, eventUncheckedUpdateWithoutTransactionInput>
    create: XOR<eventCreateWithoutTransactionInput, eventUncheckedCreateWithoutTransactionInput>
    where?: eventWhereInput
  }

  export type eventUpdateToOneWithWhereWithoutTransactionInput = {
    where?: eventWhereInput
    data: XOR<eventUpdateWithoutTransactionInput, eventUncheckedUpdateWithoutTransactionInput>
  }

  export type eventUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    market_group?: market_groupUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    marketGroupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type positionUpsertWithoutTransactionInput = {
    update: XOR<positionUpdateWithoutTransactionInput, positionUncheckedUpdateWithoutTransactionInput>
    create: XOR<positionCreateWithoutTransactionInput, positionUncheckedCreateWithoutTransactionInput>
    where?: positionWhereInput
  }

  export type positionUpdateToOneWithWhereWithoutTransactionInput = {
    where?: positionWhereInput
    data: XOR<positionUpdateWithoutTransactionInput, positionUncheckedUpdateWithoutTransactionInput>
  }

  export type positionUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    market?: marketUpdateOneWithoutPositionNestedInput
  }

  export type positionUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_groupCreateManyCategoryInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    resourceId?: number | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
  }

  export type resourceCreateManyCategoryInput = {
    id?: number
    createdAt?: Date | string
    name: string
    slug: string
  }

  export type market_groupUpdateWithoutCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUpdateManyWithoutMarket_groupNestedInput
    market?: marketUpdateManyWithoutMarket_groupNestedInput
    resource?: resourceUpdateOneWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedUpdateManyWithoutMarket_groupNestedInput
    market?: marketUncheckedUpdateManyWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type resourceUpdateWithoutCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUpdateManyWithoutResourceNestedInput
    resource_price?: resource_priceUpdateManyWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    market_group?: market_groupUncheckedUpdateManyWithoutResourceNestedInput
    resource_price?: resource_priceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type resourceUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type positionCreateManyMarketInput = {
    id?: number
    createdAt?: Date | string
    positionId: number
    owner?: string | null
    isLP: boolean
    highPriceTick?: Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: Decimal | DecimalJsLike | number | string | null
    isSettled?: boolean | null
    lpBaseToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: Decimal | DecimalJsLike | number | string | null
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
  }

  export type positionUpdateWithoutMarketInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUpdateManyWithoutPositionNestedInput
  }

  export type positionUncheckedUpdateWithoutMarketInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: transactionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type positionUncheckedUpdateManyWithoutMarketInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: IntFieldUpdateOperationsInput | number
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    isLP?: BoolFieldUpdateOperationsInput | boolean
    highPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowPriceTick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isSettled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lpBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type eventCreateManyMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    transactionHash: string
    timestamp: bigint | number
    logIndex: number
    logData: JsonNullValueInput | InputJsonValue
  }

  export type marketCreateManyMarket_groupInput = {
    id?: number
    createdAt?: Date | string
    marketId: number
    startTimestamp?: number | null
    endTimestamp?: number | null
    startingSqrtPriceX96?: Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: Decimal | DecimalJsLike | number | string | null
    settled?: boolean | null
    baseAssetMinPriceTick?: number | null
    baseAssetMaxPriceTick?: number | null
    minPriceD18?: Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    public?: boolean
    question?: string | null
    poolAddress?: string | null
    optionName?: string | null
    rules?: string | null
  }

  export type eventUpdateWithoutMarket_groupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    transaction?: transactionUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
    transaction?: transactionUncheckedUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateManyWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    transactionHash?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    logIndex?: IntFieldUpdateOperationsInput | number
    logData?: JsonNullValueInput | InputJsonValue
  }

  export type marketUpdateWithoutMarket_groupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    position?: positionUpdateManyWithoutMarketNestedInput
  }

  export type marketUncheckedUpdateWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    position?: positionUncheckedUpdateManyWithoutMarketNestedInput
  }

  export type marketUncheckedUpdateManyWithoutMarket_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketId?: IntFieldUpdateOperationsInput | number
    startTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    startingSqrtPriceX96?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settlementPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    settled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    baseAssetMinPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    baseAssetMaxPriceTick?: NullableIntFieldUpdateOperationsInput | number | null
    minPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxPriceD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    public?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    optionName?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionCreateManyPositionInput = {
    id?: number
    createdAt?: Date | string
    tradeRatioD18?: Decimal | DecimalJsLike | number | string | null
    type: $Enums.transaction_type_enum
    baseToken?: Decimal | DecimalJsLike | number | string | null
    quoteToken?: Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: Decimal | DecimalJsLike | number | string | null
    collateral: Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: Decimal | DecimalJsLike | number | string | null
    eventId?: number | null
    marketPriceId?: number | null
    collateralTransferId?: number | null
  }

  export type transactionUpdateWithoutPositionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_transfer?: collateral_transferUpdateOneWithoutTransactionNestedInput
    market_price?: market_priceUpdateOneWithoutTransactionNestedInput
    event?: eventUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRatioD18?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: Enumtransaction_type_enumFieldUpdateOperationsInput | $Enums.transaction_type_enum
    baseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedBaseToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    borrowedQuoteToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lpBaseDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lpQuoteDeltaToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventId?: NullableIntFieldUpdateOperationsInput | number | null
    marketPriceId?: NullableIntFieldUpdateOperationsInput | number | null
    collateralTransferId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_groupCreateManyResourceInput = {
    id?: number
    createdAt?: Date | string
    address?: string | null
    vaultAddress?: string | null
    isYin?: boolean
    chainId: number
    deployTimestamp?: number | null
    deployTxnBlockNumber?: number | null
    owner?: string | null
    collateralAsset?: string | null
    marketParamsFeerate?: number | null
    marketParamsAssertionliveness?: Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: string | null
    marketParamsBondamount?: Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: string | null
    marketParamsUniswappositionmanager?: string | null
    marketParamsUniswapswaprouter?: string | null
    marketParamsUniswapquoter?: string | null
    marketParamsOptimisticoraclev3?: string | null
    isCumulative?: boolean
    categoryId?: number | null
    question?: string | null
    baseTokenName?: string | null
    quoteTokenName?: string | null
    collateralDecimals?: number | null
    collateralSymbol?: string | null
    initializationNonce?: string | null
    factoryAddress?: string | null
    minTradeSize?: Decimal | DecimalJsLike | number | string | null
  }

  export type resource_priceCreateManyResourceInput = {
    id?: number
    createdAt?: Date | string
    blockNumber: number
    timestamp: number
    value: Decimal | DecimalJsLike | number | string
    used: Decimal | DecimalJsLike | number | string
    feePaid: Decimal | DecimalJsLike | number | string
  }

  export type market_groupUpdateWithoutResourceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUpdateManyWithoutMarket_groupNestedInput
    market?: marketUpdateManyWithoutMarket_groupNestedInput
    category?: categoryUpdateOneWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    event?: eventUncheckedUpdateManyWithoutMarket_groupNestedInput
    market?: marketUncheckedUpdateManyWithoutMarket_groupNestedInput
  }

  export type market_groupUncheckedUpdateManyWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vaultAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isYin?: BoolFieldUpdateOperationsInput | boolean
    chainId?: IntFieldUpdateOperationsInput | number
    deployTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    deployTxnBlockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    collateralAsset?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsFeerate?: NullableIntFieldUpdateOperationsInput | number | null
    marketParamsAssertionliveness?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsBondcurrency?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsBondamount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketParamsClaimstatement?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswappositionmanager?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapswaprouter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsUniswapquoter?: NullableStringFieldUpdateOperationsInput | string | null
    marketParamsOptimisticoraclev3?: NullableStringFieldUpdateOperationsInput | string | null
    isCumulative?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    question?: NullableStringFieldUpdateOperationsInput | string | null
    baseTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    quoteTokenName?: NullableStringFieldUpdateOperationsInput | string | null
    collateralDecimals?: NullableIntFieldUpdateOperationsInput | number | null
    collateralSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    initializationNonce?: NullableStringFieldUpdateOperationsInput | string | null
    factoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    minTradeSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type resource_priceUpdateWithoutResourceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type resource_priceUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type resource_priceUncheckedUpdateManyWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    used?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}